<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Play Clesto, the Jungle Chess game online. A strategy board game with unique animal movements and rules.">
    <title>CLESTO: The Jungle Chess Game</title>

    <!-- Preload key visual assets -->
    <link rel="preload" as="image" href="https://staticjw.com/clesto/board.png">
    <link rel="preload" as="image" href="https://staticjw.com/clesto/animals/elephant-orange.png">
    <link rel="preload" as="image" href="https://staticjw.com/clesto/animals/elephant-yellow.png">
    <link rel="preload" as="image" href="https://staticjw.com/clesto/animals/lion-orange.png">
    <link rel="preload" as="image" href="https://staticjw.com/clesto/animals/lion-yellow.png">
    <link rel="preload" as="image" href="https://staticjw.com/clesto/animals/tiger-orange.png">
    <link rel="preload" as="image" href="https://staticjw.com/clesto/animals/tiger-yellow.png">
    <link rel="preload" as="image" href="https://staticjw.com/clesto/animals/leopard-orange.png">
    <link rel="preload" as="image" href="https://staticjw.com/clesto/animals/leopard-yellow.png">
    <link rel="preload" as="image" href="https://staticjw.com/clesto/animals/wolf-orange.png">
    <link rel="preload" as="image" href="https://staticjw.com/clesto/animals/wolf-yellow.png">
    <link rel="preload" as="image" href="https://staticjw.com/clesto/animals/dog-orange.png">
    <link rel="preload" as="image" href="https://staticjw.com/clesto/animals/dog-yellow.png">
    <link rel="preload" as="image" href="https://staticjw.com/clesto/animals/cat-orange.png">
    <link rel="preload" as="image" href="https://staticjw.com/clesto/animals/cat-yellow.png">
    <link rel="preload" as="image" href="https://staticjw.com/clesto/animals/rat-orange.png">
    <link rel="preload" as="image" href="https://staticjw.com/clesto/animals/rat-yellow.png">

    <style>
        /* --- Global Variables & Basic Setup --- */
        :root {
            /* Player Colors (Keep As Is) */
            --orange-color: #E67E22;
            --yellow-color: #F1C40F;
            --dark-orange: #D35400;
            --dark-yellow: #F39C12;

            /* UI Colors (Will be largely overridden, but set sensible defaults) */
            --primary-bg: #6fb367;      /* Main Green Background */
            --secondary-bg: #fdf6e3;    /* Light Cream/Beige for Panels */
            --tertiary-bg: #f5f5f5;     /* Lighter Grey for Logs/Code */
            --text-dark: #4a4a4a;       /* Dark Text for Readability */
            --text-light: #ffffff;      /* Light Text (e.g., on buttons) */
            --border-color: #a9a9a9;    /* Default Border */
            --button-default-bg: #4CAF50; /* Default Green Button */
            --button-default-hover: #45a049; /* Darker Green Hover */

            /* Highlight & Feedback Colors (Keep As Is) */
            --cell-highlight-move: rgba(0, 255, 0, 0.7);
            --cell-highlight-attack: rgba(255, 0, 0, 0.7);
            --piece-select-glow: rgba(0, 191, 255, 0.9);
            --hungry-outline: rgba(255, 0, 0, 0.8);
            --ai-move-from-bg: rgba(0, 0, 255, 0.15);
            --ai-move-to-bg: rgba(0, 0, 255, 0.3);
            --focus-outline: 2px solid #007bff;

            /* Layout Dimensions (Keep As Is) */
            --board-max-width: 550px;
            --ui-max-width: 300px;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: var(--primary-bg); /* Use Green Background */
            color: var(--text-dark);           /* Default Dark Text */
            padding: 10px;
            margin: 0;
            box-sizing: border-box;
            width: 100%;
            min-height: 100vh;
        }

        h1 {
            margin-top: 10px;
            margin-bottom: 15px;
            color: var(--text-light); /* White text on green background */
            font-weight: 300;
            /* border-bottom: 1px solid var(--medium-gray); Remove border */
            padding-bottom: 10px;
            font-size: 1.8em;
            text-align: center;
            width: 100%;
            max-width: calc(var(--board-max-width) + var(--ui-max-width) + 40px);
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.4); /* Add subtle shadow */
        }

        main {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            margin-top: 10px;
            width: 100%;
            max-width: calc(var(--board-max-width) + var(--ui-max-width) + 40px);
            box-sizing: border-box;
        }

        /* --- Board Styling --- */
        #board {
            /* Outer container: Sets dimensions, background image, and padding */
            width: var(--board-max-width);
            max-width: 100%;
            /* Responsive width */
            aspect-ratio: 7.1 / 9;
            /* Maintain board proportions */
            height: auto;
            border: none;
            position: relative;
            background-image: url('https://staticjw.com/clesto/board.png');
            background-size: cover;
            background-position: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
            border-radius: 5px;
            outline: none;
            /* For custom focus */
            box-sizing: border-box;
            padding: 22px;
            /* Adjust padding to align grid with background */
            overflow: hidden;
            /* Clip any potential overflow */
        }

        #board-grid-wrapper {
            /* Inner container: Holds the grid cells and pieces */
            width: 100%;
            height: 100%;
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            grid-template-rows: repeat(9, 1fr);
            position: relative;
            outline: none;
        }

        #board:focus {
            /* Custom focus style for the board */
            box-shadow: 0 0 0 3px var(--focus-outline);
        }

        .cell {
            /* Individual grid cells */
            width: 100%;
            height: 100%;
            border: none;
            box-sizing: border-box;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.6em;
            /* For coordinate display (optional) */
            color: rgba(0, 0, 0, 0.3);
            user-select: none;
            background-clip: padding-box;
            /* Ensure background doesn't overlap borders */
            transition: background-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            outline: none;
            /* For custom focus */
        }

        .cell:focus {
            /* Custom focus style for cells */
            box-shadow: inset 0 0 0 3px var(--focus-outline);
            z-index: 5;
            /* Bring focus outline above other elements */
        }

        .cell::before {
            /* Pseudo-element for styling special terrain (water, traps, dens) */
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            /* Doesn't interfere with clicks/drags */
            box-sizing: border-box;
            border-radius: inherit;
            opacity: 0.8;
            /* Slightly transparent overlay */
        }

        /* Specific terrain styles using the ::before pseudo-element */
        .water::before {
            background-color: rgba(100, 150, 255, 0.3);
        }

        .trap-orange::before { /* Affects Orange, near Yellow den */
            /* background-color: rgba(255, 255, 150, 0.3); */
            /* border: 2px dashed var(--dark-yellow); */
        }

        .trap-yellow::before { /* Affects Yellow, near Orange den */
            /* background-color: rgba(255, 150, 150, 0.3); */
            /* border: 2px dashed var(--hungry-outline); */
        }

        .den-orange::before {
            /* background-color: rgba(255, 100, 0, 0.4); */
            /* border: 3px solid var(--dark-orange); */
        }

        .den-yellow::before {
            /* background-color: rgba(255, 255, 0, 0.4); */
            /* border: 3px solid var(--dark-yellow); */
        }

        /* Highlighting for AI's last move */
        .ai-move-from {
            background-color: var(--ai-move-from-bg) !important;
        }

        .ai-move-to {
            background-color: var(--ai-move-to-bg) !important;
        }

        /* --- Highlighting for Last Moves --- */
        /* Generic cell styles (apply to both players) */
        .last-move-from {
            background-color: rgba(0, 0, 255, 0.1); /* Light background for origin */
             transition: background-color 0.3s ease-out;
        }
        .last-move-to {
            background-color: rgba(0, 0, 255, 0.25); /* Darker background for destination */
             transition: background-color 0.3s ease-out;
        }
        /* Player-specific border/glow (optional, can use background only) */
        .orange-last-move {
            background-color: rgba(0, 0, 255, 0.25); /* Light background for origin */
             transition: background-color 0.3s ease-out;
        }
        .yellow-last-move {
            background-color: rgba(0, 0, 255, 0.25); /* Darker background for destination */
             transition: background-color 0.3s ease-out;
        }

        /* --- Piece Styling --- */
        .piece {
            /* Width calculated as a percentage of the GRID WRAPPER */
            /* Cell Width = 100% / 7 columns â‰ˆ 14.2857% */
            /* Piece Width = 84.5% of Cell Width */
            /* Piece % of Wrapper = (100/7) * 0.845 â‰ˆ 12.07% */
            width: 12.07%;
            aspect-ratio: 1 / 1;
            /* Make piece square relative to its width */
            height: auto;
            /* Height is automatically determined by width + aspect ratio */

            position: absolute;
            /* Positioned relative to #board-grid-wrapper */
            left: 0;
            /* Left position set by JavaScript */
            top: 0;
            /* Top position set by JavaScript */

            /* CURSOR REMOVED - Will be applied conditionally via JS/CSS class */
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.25);
            z-index: 10;
            /* Pieces sit above cells */
            /* Smooth transitions for movement, scaling, and effects */
            transition: transform 0.3s ease-in-out, box-shadow 0.2s ease, outline 0.2s ease, left 0.3s ease-in-out, top 0.3s ease-in-out;
            user-select: none;
            /* Prevent text selection */
            overflow: visible;
            /* Allow outlines/glows to extend slightly */
            background: none;
            border: none;
            border-radius: 50%;
            /* Circular pieces */
            outline: none;
            /* Custom focus/selection */
            touch-action: none;
            /* Improve touch interactions */
        }

        .piece img {
            /* Styling for the animal image inside the piece div */
            width: 100%;
            height: 100%;
            display: block;
            object-fit: contain;
            /* Scale image while preserving aspect ratio */
            pointer-events: none;
            /* Image doesn't interfere with events on the parent div */
            border-radius: 50%;
        }

        .piece:focus {
            /* Custom focus style for pieces 
            outline: 3px solid var(--focus-outline);
            outline-offset: 1px;
            z-index: 15; */
            /* Bring focused piece above others */
        }

        .piece.dragging {
            /* Style applied when a piece is being dragged */
            opacity: 0.6;
            cursor: grabbing;
            z-index: 100;
            /* Ensure dragged piece is on top */
            transform: scale(1.1);
            /* Slightly enlarge */
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            /* Enhance shadow */
            transition: transform 0.15s ease-out, box-shadow 0.2s ease, outline 0.2s ease;
            /* Faster transition while dragging */
        }

        /* --- Movable Piece Cursor --- */
        .piece.movable {
             cursor: grab; /* Apply hand cursor only when piece is interactive */
        }

        .piece.captured {
            /* Animation for captured pieces */
            animation: capture-animation 0.4s ease-out forwards;
        }

        /* --- Trap Rank Indicator Styling --- */
        .trap-rank-indicator {
            position: absolute;
            top: -2px; /* Position slightly above the piece image */
            left: 0;
            width: 100%;
            text-align: center;
            font-size: 0.75em; /* Smaller font size */
            font-weight: bold;
            color: white; /* White text */
            background-color: rgba(200, 0, 0, 0.75); /* Reddish semi-transparent background */
            border-radius: 3px;
            padding: 0 2px;
            z-index: 1; /* Above the image (z-index 0 default) but below selection/hungry (z-index > 1) */
            pointer-events: none; /* So it doesn't interfere with clicks/drags */
            display: none; /* Hidden by default */
            box-sizing: border-box;
            user-select: none; /* Prevent text selection */
        }

        .trap-rank-indicator.visible {
            display: block; /* Show the indicator when this class is added */
        }

        @keyframes capture-animation {
            0% {
                transform: scale(1);
                opacity: 1;
            }

            100% {
                transform: scale(0.5);
                opacity: 0;
            }
        }

        /* --- Visual Feedback --- */
        .valid-move {
            /* Style for cells representing a valid non-attack move */
            box-shadow: inset 0 0 0 3px var(--cell-highlight-move);
            background-color: rgba(0, 255, 0, 0.1);
        }

        .valid-attack {
            /* Style for cells representing a valid attack move */
            box-shadow: inset 0 0 0 3px var(--cell-highlight-attack);
            background-color: rgba(255, 0, 0, 0.1);
        }

        .selected {
            /* Outline for the currently selected piece */
            /* outline: 3px solid var(--piece-select-glow); */ /* Blue solid */
            /* outline-offset: 1px;
            z-index: 16; */ /* Ensure selected outline is visually prominent */
        }

        .hungry {
            /* Box-shadow glow for pieces that must attack if possible */
            /* outline: 3px dashed var(--hungry-outline); */ /* Keep old style commented */
            /* outline-offset: 2px; */
            box-shadow: 0 0 0 3px var(--hungry-outline); /* Red 'glow' effect */
             /* Optional: Add a subtle animation */
            /* animation: hungry-pulse 1.5s infinite ease-in-out; */
        }

        /* Optional pulse animation for hungry pieces */
        @keyframes hungry-pulse {
            0% { box-shadow: 0 0 0 3px var(--hungry-outline); }
            50% { box-shadow: 0 0 0 5px rgba(255, 0, 0, 0.5); } /* Slightly wider, semi-transparent */
            100% { box-shadow: 0 0 0 3px var(--hungry-outline); }
        }

        /* --- UI Info Panel Styling --- */
        #ui-info-section {
            width: var(--ui-max-width);
            max-width: 100%;
            border: 1px solid var(--border-color); /* Use new border color */
            padding: 20px;
            background-color: var(--secondary-bg); /* Use Cream/Beige background */
            height: fit-content;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
        }

        #ui-info-section h2,
        #ui-info-section h3 {
            margin-top: 0;
            margin-bottom: 15px;
            border-bottom: 1px solid var(--border-color); /* Use new border color */
            padding-bottom: 8px;
            font-weight: 500; /* Slightly bolder */
            color: var(--text-dark); /* Use new dark text color */
        }

        #ui-info-section h3 {
            margin-top: 15px;
            /* Space above subheadings */
        }

        #ui-info-section p {
            margin: 10px 0;
            line-height: 1.5;
        }

        #turn-indicator {
            font-weight: 600;
            padding: 3px 6px;
            border-radius: 4px;
            color: white;
        }

        /* Player-specific turn indicator colors */
        #turn-indicator.orange {
            background-color: var(--orange-color);
        }

        #turn-indicator.yellow {
            background-color: var(--yellow-color);
            color: var(--dark-gray);
            /* Better contrast */
        }

        #turn-indicator.game-over {
            background-color: #dc3545;
            /* Red for game over */
        }

        #status-message {
            min-height: 1.5em;
            /* Prevent layout shifts */
        }

        /* --- Clock Styling --- */
        .clock-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 10px;
            margin: 4px 0 8px 0;
            border: 1px solid var(--border-color); /* Use new border color */
            border-radius: 4px;
            background-color: #f0e8d1; /* Slightly different cream for clocks */
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }

        .clock-label {
            font-weight: 500;
            font-size: 0.9em;
            margin-right: 10px;
            color: var(--text-dark); /* Use new dark text color */
        }

        .clock-time {
            font-family: 'Courier New', Courier, monospace;
            font-size: 1.1em;
            font-weight: bold;
            padding: 2px 5px;
            border-radius: 3px;
            background-color: #e9e0c7; /* Background matching hover/active toggle */
            color: var(--text-dark); /* Default dark text */
        }

        /* Style for clock time when it runs out */
        .clock-time.time-out {
            color: #dc3545; /* Red color */
            /* Optional: Add other styles like background */
            /* background-color: #f8d7da; */ /* Light red background */
        }

        /* Style for the active clock */
        .clock-container.clock-active {
            border-color: var(--text-dark); /* Use dark text color for active border */
            background-color: #e9e0c7; /* Match time background */
        }

        /* Player-specific active clock time background (optional) */
        #orange-clock-container.clock-active .clock-time {
             background-color: var(--orange-color);
             color: white;
        }
         #yellow-clock-container.clock-active .clock-time {
             background-color: var(--yellow-color);
             color: var(--dark-gray);
         }

        /* --- Buttons --- */
        .button-container {
            padding-top: 10px;
            margin-bottom: 15px;
            display: flex;
            gap: 10px;
            justify-content: space-around;
            flex-wrap: wrap;
        }

        .game-button {
            padding: 10px 18px;
            cursor: pointer;
            border-radius: 5px;
            border: none;
            font-size: 0.95em;
            transition: background-color 0.2s ease, box-shadow 0.2s ease;
            background-color: var(--button-default-bg); /* Use Green Button color */
            color: var(--text-light);                   /* Use Light Text color */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            outline: none;
            margin-bottom: 5px;
        }

        .game-button:hover {
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.15);
            background-color: var(--button-default-hover); /* Darker green on hover */
        }

        .game-button:focus-visible {
            /* Style for keyboard focus */
            box-shadow: 0 0 0 3px var(--focus-outline);
        }

        /* Specific button colors */
        #reset-button {
            background-color: var(--button-default-bg); /* Match default green */
        }

        #reset-button:hover {
            background-color: var(--button-default-hover); /* Match default green hover */
        }

        #undo-button {
            background-color: #ffc107;
            /* Yellow */
            color: var(--dark-gray);
        }

        #undo-button:hover {
            background-color: #e0a800;
        }

        #undo-button:disabled {
            background-color: #adb5bd;
            cursor: not-allowed;
            box-shadow: none;
        }

        /* --- Audio Controls Styling --- */
        .audio-controls-container {
            display: flex;
            align-items: center; /* Vertically center items */
            padding: 10px 10px;
            margin: 10px 0 5px 0;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            background-color: #f0e8d1;
            gap: 15px; /* Space between music and SFX groups */
            /* overflow: hidden; */ /* Temporarily removed for debugging if needed */
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-shrink: 0;
        }

        /* Music group expands to fill space */
        .music-control {
             flex-grow: 1;
             /* Optional: Set a min-width if needed, but flex-grow should handle expansion */
             max-width: 135px;
             /* Ensure the inner elements don't overflow this group if space is really tight */
             overflow: hidden;
             min-width: 0; /* Allow shrinking below intrinsic size if necessary */
        }

        /* SFX group stays at its natural size */
        .sfx-control {
            flex-grow: 0;
            flex-shrink: 0;
        }

        .control-icon {
            font-size: 1.4em;
            user-select: none;
            line-height: 1;
            flex-shrink: 0; /* Prevent icons shrinking */
        }

        /* Style the volume slider to fill its parent */
        #music-volume-slider {
            width: 100%; /* Make slider fill the available width in its group */
            /* Removed flex-grow, max-width, min-width from slider */
            cursor: pointer;
            accent-color: var(--orange-color);
            height: 8px; /* Or adjust as needed */
        }
        /* Slider track/thumb styles remain the same */
        #music-volume-slider::-webkit-slider-runnable-track {
            background: #ddd;
            border-radius: 4px;
            height: 8px;
        }
        #music-volume-slider::-moz-range-track {
             background: #ddd;
             border-radius: 4px;
             height: 8px;
        }
        #music-volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: var(--orange-color);
            border-radius: 50%;
            margin-top: -4px;
        }
        #music-volume-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: var(--orange-color);
            border-radius: 50%;
            border: none;
        }

        /* Optional Volume Percentage Display */
        .volume-display {
            font-size: 0.85em;
            min-width: 35px;
            text-align: right;
            color: var(--text-dark);
            font-family: monospace;
            flex-shrink: 0; /* Prevent text display shrinking */
        }

        /* SFX Switch styles remain the same */
        .sfx-switch { }
        .sfx-switch input:checked + .slider {
            background-color: var(--button-default-bg);
        }
         .sfx-switch input:focus-visible + .slider {
             outline: 2px solid var(--focus-outline);
             outline-offset: 1px;
         }
        /* --- End Audio Controls Styling --- */

        /* --- PvP Toggle Switch Styling --- */
        .pvp-toggle-container {
            display: flex;
            align-items: center;
            justify-content: space-between; /* Adjust as needed */
            margin-top: 8px;
            margin-bottom: 8px;
            padding: 5px 0;
        }

        .pvp-label {
            margin-right: 10px;
            font-weight: 500;
            font-size: 0.95em;
        }

        /* The switch - a wrapper around the checkbox and slider */
        .switch {
            position: relative;
            display: inline-block;
            width: 50px; /* Width of the switch */
            height: 24px; /* Height of the switch */
        }

        /* Hide default HTML checkbox */
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        /* The slider */
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #bdbdbd; /* Darker gray for inactive */
            transition: .4s;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 18px; /* Height of the knob */
            width: 18px; /* Width of the knob */
            left: 3px; /* Position from left */
            bottom: 3px; /* Position from bottom */
            background-color: white;
            transition: .4s;
        }

        input:checked + .slider {
            background-color: var(--orange-color); /* Use a game color when active */
        }

        input:focus + .slider {
            box-shadow: 0 0 1px var(--orange-color);
        }
         input:focus-visible + .slider { /* Better focus styling */
             outline: 2px solid var(--focus-outline);
             outline-offset: 1px;
         }


        input:checked + .slider:before {
            transform: translateX(26px); /* Move knob to the right */
        }

        /* Rounded sliders */
        .slider.round {
            border-radius: 24px; /* Make the track round */
        }

        .slider.round:before {
            border-radius: 50%; /* Make the knob round */
        }

        /* --- PvP Info Icon & Tooltip Styling --- */
        .pvp-info-icon {
            display: inline-block;
            margin-left: 8px;       /* Space between label and icon */
            cursor: help;           /* Use help cursor */
            color: #007bff;         /* Blue color for the icon */
            font-weight: bold;
            font-size: 1.1em;
            line-height: 1;         /* Prevent extra vertical space */
            border-radius: 50%;     /* Make focus outline round */
            padding: 0 2px;        /* Small padding for focus */
            vertical-align: middle;
        }

        .pvp-info-icon:focus {
            outline: var(--focus-outline); /* Use standard focus outline */
            outline-offset: 1px;
        }

        .tooltip-text {
            visibility: hidden;
            opacity: 0;
            position: absolute;
            background-color: var(--text-dark);
            color: var(--text-light);
            text-align: center;
            padding: 6px 10px;
            border-radius: 5px;
            z-index: 101;
            font-size: 0.85em;
            width: 180px;
            /* Position above the ICON (which is now inside switch-icon-wrapper) */
            bottom: 130%; /* Adjust vertical distance from icon */
            left: 50%; /* Start at the center of the icon */
            /* Translate leftwards by roughly half tooltip width PLUS half icon width approx */
            transform: translateX(-50%); /* Use transform for better centering */
            transition: opacity 0.3s ease;
            pointer-events: none;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        /* Show tooltip on hover or focus */
        .pvp-info-icon:hover + .tooltip-text,
        .pvp-info-icon:focus + .tooltip-text {
            visibility: visible;
            opacity: 1;
        }

        /* Optional: Add a little arrow/pointer below the tooltip */
        .tooltip-text::after {
            content: "";
            position: absolute;
            top: 100%; /* At the bottom of the tooltip */
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: var(--text-dark) transparent transparent transparent; /* Arrow pointing down */
        }

        .tooltip-text::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%; /* Center relative to tooltip */
            transform: translateX(-50%); /* Ensure arrow is centered */
            margin-left: 0; /* Reset margin-left used previously */
            border-width: 5px;
            border-style: solid;
            border-color: var(--text-dark) transparent transparent transparent;
        }

        .switch-icon-wrapper { 
            display: flex; /* Align switch and icon horizontally */ 
            align-items: center; /* Vertically center them */ 
            position: relative; /* Crucial for tooltip positioning */ 
        }

        /* --- Logs --- */

        /* Basic styling for the copy button */
        .copy-button {
            display: inline-block; /* Or block depending on desired layout */
            padding: 4px 8px;
            margin-bottom: 5px; /* Space below button, above log */
            font-size: 0.9em;
            cursor: pointer;
            border: 1px solid #ccc;
            border-radius: 4px;
            background-color: #f0f0f0;
            transition: background-color 0.2s ease;
        }

        .copy-button:hover {
            background-color: #e0e0e0;
        }

        .copy-button:active {
            background-color: #d0d0d0;
        }

        .copy-button:disabled {
            cursor: not-allowed;
            opacity: 0.6;
        }

        #move-log {
            height: 220px;
            overflow-y: auto;
            border: 1px solid var(--border-color); /* Use new border color */
            border-radius: 5px;
            padding: 8px 10px;
            margin-top: 10px;
            font-size: 0.9em;
            background-color: var(--tertiary-bg); /* Use Lighter Grey background */
            line-height: 1.6;
        }

        .log-entry {
            padding: 3px 0;
            border-bottom: 1px dashed var(--medium-gray);
        }

        .log-entry:last-child {
            border-bottom: none;
        }

        .log-entry .turn-number {
            display: inline-block;
            width: 25px;
            font-weight: bold;
            color: #6c757d;
            margin-right: 5px;
        }

        .log-entry .log-orange,
        .log-entry .log-yellow {
            display: inline-block;
            min-width: 60px;
            padding: 2px 5px;
            border-radius: 3px;
            margin: 0 3px;
            text-align: center;
        }

        /* Move log colors matching player colors */
        .log-entry .log-orange {
            background-color: rgba(230, 126, 34, 0.15);
            color: var(--dark-orange);
            border: 1px solid rgba(230, 126, 34, 0.3);
        }

        .log-entry .log-yellow {
            background-color: rgba(241, 196, 15, 0.15);
            color: #c78b02;
            /* Darker yellow for text */
            border: 1px solid rgba(241, 196, 15, 0.3);
        }

        .log-entry .placeholder {
            /* Style for when a player hasn't moved yet in the current turn */
            color: #adb5bd;
            font-style: italic;
            display: inline-block;
            min-width: 60px;
            text-align: center;
        }

        /* --- Move Log Tooltip Styling --- */
        .log-entry .log-orange,
        .log-entry .log-yellow {
            position: relative; /* Needed for absolute positioning of the tooltip */
            cursor: help;       /* Indicate more info is available */
            /* Optional: Add subtle underline on hover/focus */
             /* text-decoration: none; */
             /* transition: text-decoration 0.2s ease; */
        }

        .log-entry .log-orange:hover,
        .log-entry .log-yellow:hover,
        .log-entry .log-orange:focus,
        .log-entry .log-yellow:focus {
            /* Optional: Style on hover/focus */
            /* text-decoration: underline; */
            outline: none; /* Remove default focus outline if custom one is not desired */
        }
        .log-entry .log-orange:focus-visible,
        .log-entry .log-yellow:focus-visible {
             /* Add a visible focus style for keyboard nav */
             box-shadow: 0 0 0 2px var(--focus-outline);
             outline: none;
        }

        /* --- Shared Move Log Tooltip --- */
        .shared-tooltip {
            position: fixed; /* Position relative to viewport */
            background-color: rgba(50, 50, 50, 0.9); /* Dark semi-transparent */
            color: var(--text-light);
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 0.9em;
            line-height: 1.4;
            white-space: normal;
            word-wrap: break-word;
            z-index: 1100; /* High z-index */
            max-width: 240px;
            /* Hide initially */
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.2s ease, visibility 0.2s ease;
            pointer-events: none; /* Prevent interaction */
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            /* Reset potential inherited styles */
            display: block;
            margin: 0;
            text-align: left;
        }

        #board-state-log {
            margin-top: 10px;
            border: 1px solid var(--border-color); /* Use new border color */
            border-radius: 5px;
            padding: 10px;
            font-size: 0.75em;
            font-family: monospace;
            word-wrap: break-word;
            background-color: var(--tertiary-bg); /* Use Lighter Grey background */
            max-height: 90px;
            overflow-y: auto;
            line-height: 1.4;
        }

        /* --- Debug Log Section Styling (Optional) --- */
        #debug-log-container {
            width: 100%;
            max-width: calc(var(--board-max-width) + var(--ui-max-width) + 40px);
            margin-top: 20px;
            padding: 15px;
            background-color: var(--secondary-bg); /* Use Cream/Beige background */
            border: 1px solid var(--border-color); /* Use new border color */
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            box-sizing: border-box;
        }

        #debug-log-container h2 {
            margin-top: 0;
            margin-bottom: 10px;
            font-weight: 500; /* Slightly bolder */
            border-bottom: 1px solid var(--border-color); /* Use new border color */
            padding-bottom: 5px;
            font-size: 1.2em;
            color: var(--text-dark); /* Use new dark text color */
        }

        #debug-log-output {
            height: 200px;
            max-height: 40vh;
            overflow-y: auto;
            background-color: var(--tertiary-bg); /* Use Lighter Grey background */
            border: 1px solid var(--border-color); /* Use new border color */
            border-radius: 3px;
            padding: 8px;
            font-family: monospace;
            font-size: 0.8em;
            white-space: pre-wrap;
            word-break: break-word;
            line-height: 1.4;
            color: var(--text-dark); /* Ensure default text color */
        }

        .debug-log-entry {
            padding: 2px 0;
            border-bottom: 1px dashed #e9ecef;
        }

        .debug-log-entry:last-child {
            border-bottom: none;
        }

        .debug-log-timestamp {
            color: #6c757d;
            margin-right: 8px;
        }

        /* Color coding for debug levels */
        .debug-log-warn {
            color: #fd7e14;
        }

        .debug-log-error {
            color: #dc3545;
            font-weight: bold;
        }

        .debug-hidden {
            /* Class to hide the debug section */
            display: none;
        }

        /* --- Rules Accordion Styling --- */
        #rules-accordion-container {
            width: 100%;
            max-width: calc(var(--board-max-width) + var(--ui-max-width) + 40px); /* Match main content width */
            margin: 15px auto 15px auto; /* Add some space around it */
            border: 1px solid var(--border-color); /* Use new border color */
            border-radius: 5px;
            overflow: hidden; /* Clip content during transition */
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            box-sizing: border-box;
            background-color: var(--secondary-bg); /* Use Cream/Beige background */
        }

        .rules-toggle-button {
            background-color: #e8e0c9; /* Slightly darker cream for header */
            color: var(--text-dark); /* Use new dark text color */
            cursor: pointer;
            padding: 12px 18px;
            width: 100%;
            border: none;
            text-align: left;
            outline: none;
            font-size: 1.1em;
            transition: background-color 0.3s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 500;
        }

        .rules-toggle-button:hover,
        .rules-toggle-button.active {
            background-color: #dcd4b8; /* Darker cream on hover/active */
        }

        .rules-toggle-button:focus-visible {
             box-shadow: 0 0 0 3px var(--focus-outline);
             z-index: 1; /* Ensure focus outline is visible */
             position: relative; /* Needed for z-index */
        }

        .rules-icon {
            font-size: 1.2em;
            font-weight: bold;
            transition: transform 0.3s ease;
        }

        .rules-toggle-button.active .rules-icon {
            transform: rotate(45deg); /* Rotate '+' to 'x' */
        }

        .rules-content {
            padding: 0 18px;
            background-color: var(--secondary-bg); /* Match panel background */
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out, padding 0.3s ease-out;
            border-top: 1px solid var(--border-color); /* Use new border color */
            color: var(--text-dark); /* Ensure text color */
        }

        .rules-content.expanded {
             padding: 15px 18px; /* Padding when expanded */
             /* max-height is set by JS */
        }


        .rules-content h3 {
            margin-top: 15px;
            margin-bottom: 8px;
            color: var(--text-dark); /* Use standard dark text */
            font-weight: 600;      /* Make slightly bolder */
            border-bottom: 1px solid var(--border-color); /* Use new border color */
            padding-bottom: 4px;
        }
         .rules-content h3:first-child {
            margin-top: 0;
         }

        .rules-content h4 {
            margin-top: 12px;
            margin-bottom: 5px;
            color: #5a5a5a; /* Slightly lighter dark text */
        }


        .rules-content p,
        .rules-content ul,
        .rules-content ol {
            margin-bottom: 10px;
            line-height: 1.6;
        }

        .rules-content ul,
        .rules-content ol {
            padding-left: 25px; /* Indent lists */
        }
         .rules-content ul ul,
         .rules-content ol ol,
         .rules-content ul ol,
         .rules-content ol ul {
             margin-bottom: 5px; /* Less space for nested lists */
         }

        .rules-content li {
            margin-bottom: 5px;
        }

        .rules-content strong {
            font-weight: 600; /* Make bold text stand out */
        }

        /* --- Mobile Responsiveness --- */
        @media (max-width: 850px) {

            /* Adjust layout for smaller screens */
            body {
                padding: 5px;
            }

            h1 {
                font-size: 1.5em;
                margin-bottom: 10px;
            }

            main {
                flex-direction: column;
                align-items: center;
                gap: 15px;
                padding: 0 5px;
                max-width: 100%;
            }

            /* Stack board and UI vertically */
            #board {
                width: 95vw;
                /* Use viewport width */
                max-width: var(--board-max-width);
                /* Still respect max width */
                padding: 25px 21px;
                /* Slightly reduce padding */
                order: 1;
                /* Place board first */
            }

            #ui-info-section {
                width: 95vw;
                max-width: var(--board-max-width);
                /* Match board max width */
                order: 2;
                /* Place UI below board */
            }

            /* Reduce log heights */
            #move-log {
                height: 150px;
            }

            #board-state-log {
                max-height: 60px;
            }

            .button-container {
                padding-top: 10px;
            }

            .game-button {
                padding: 8px 12px;
                font-size: 0.9em;
            }

            #debug-log-container {
                margin-top: 15px;
                width: 95vw;
                max-width: var(--board-max-width);
            }

            #debug-log-output {
                height: 150px;
            }
        }

        @media (max-width: 600px) {
            #board {
                padding: 16px 20px;
            }
        }
    </style>
</head>

<body>

    <!-- <h1>CLESTO: The Jungle Chess Game</h1> -->

    <main id="game-container" role="main">
        <!-- Game Board Section -->
        <section aria-labelledby="board-label">
            <h2 id="board-label" class="visually-hidden">Game Board</h2>
            <div id="board" tabindex="0"> <!-- Outer container for board background/focus -->
                <div id="board-grid-wrapper"> <!-- Inner container for grid layout and pieces -->
                    <!-- Cells will be generated by JavaScript here -->
                </div>
            </div>
        </section>

        <!-- UI and Information Section -->
        <section id="ui-info-section" role="region" aria-labelledby="ui-info-heading">
            <h2 id="ui-info-heading">Game Info</h2>

            <!-- START: Clock Displays -->
            <div class="clock-container" id="orange-clock-container">
                <span class="clock-label">Orange Time:</span>
                <span class="clock-time" id="orange-clock-time">10:00</span>
            </div>
            <div class="clock-container" id="yellow-clock-container">
                <span class="clock-label">Yellow Time:</span>
                <span class="clock-time" id="yellow-clock-time">10:00</span>
            </div>
            <!-- END: Clock Displays -->

            <p>Turn: <span id="turn-indicator">Orange</span></p>
            <p>Status: <span id="status-message" aria-live="polite">Loading...</span></p>

            <!-- Player vs Player Toggle -->
            <div class="pvp-toggle-container"> <!-- START: Add this container div -->
                <label for="pvp-toggle" class="pvp-label">Player vs Player Mode:</label>
                <div class="switch-icon-wrapper"> <!-- Wrapper for switch and icon -->
                    <label class="switch">
                        <input type="checkbox" id="pvp-toggle">
                        <span class="slider round"></span>
                    </label>
                    <span class="pvp-info-icon" tabindex="0" role="button" aria-label="About Player vs Player Mode" aria-describedby="pvp-tooltip-content">â“˜</span>
                    <span class="tooltip-text" id="pvp-tooltip-content" role="tooltip">Two players take turns on the same device.</span>
                </div>
            </div> <!-- END: Add this container div -->

            <!-- START: Audio Controls -->
            <div class="audio-controls-container">
                <div class="control-group music-control">
                    <span class="control-icon" aria-hidden="true">ðŸŽµ</span> <!-- Music Icon -->
                    <label for="music-volume-slider" class="visually-hidden">Music Volume</label>
                    <input type="range" id="music-volume-slider" min="0" max="1" step="0.01" value="0.5" aria-label="Music Volume">
                     <span id="music-volume-display" class="volume-display">50%</span> <!-- Optional Volume Display -->
                </div>
                <div class="control-group sfx-control">
                    <span class="control-icon" aria-hidden="true">ðŸ”Š</span> <!-- Sound Icon -->
                    <label for="sfx-toggle" class="visually-hidden">Sound Effects</label>
                     <!-- Using a similar switch style as PvP toggle -->
                    <label class="switch sfx-switch">
                        <input type="checkbox" id="sfx-toggle" checked aria-label="Toggle Sound Effects">
                        <span class="slider round"></span>
                    </label>
                </div>
            </div>
            <!-- END: Audio Controls -->

            <div class="button-container">
                <button id="undo-button" class="game-button" disabled>Undo Turn</button>
                <button id="reset-button" class="game-button">Reset Game</button>
            </div>

            <h3>Move Log</h3>
            <button id="copy-log-button" class="copy-button" title="Copy move log to clipboard">
                Copy Log ðŸ“‹ <!-- You can use an icon here later if you prefer -->
            </button>
            <div id="move-log" class="scrollable-log" aria-live="polite">
                <!-- Log entries will be added here by JS -->
            </div>

            <h3>Board State</h3>
            <button id="copy-state-button" class="copy-button" title="Copy board state hash to clipboard">
                    Copy Board State ðŸ“‹
            </button>
            <div id="board-state-log">
                <!-- Board state string for debugging/repetition check -->
            </div>

            <!-- Load From State Section -->
            <div style="margin-top: 15px; border-top: 1px solid var(--medium-gray); padding-top: 10px;">
                <label for="board-state-input" style="display: block; margin-bottom: 5px; font-weight: bold;">Load Board State:</label>
                <input type="text" id="board-state-input" placeholder="Paste board state (e.g., 8G7,7A9,...)" style="width: calc(100% - 12px); padding: 6px; margin-bottom: 8px; border: 1px solid var(--medium-gray); border-radius: 3px;">
                <button id="load-state-button" class="game-button" style="background-color: #28a745;">Load Board State</button> <!-- Green button -->
                <p id="load-status-message" style="font-size: 0.85em; color: #6c757d; min-height: 1.2em; margin-top: 5px;"></p>
            </div>
            <!-- End Load From State Section -->
        </section>
    </main>

    <!-- Rules Accordion Section -->
    <section id="rules-accordion-container" aria-labelledby="rules-heading">
        <button id="rules-toggle-button" class="rules-toggle-button" aria-expanded="false" aria-controls="rules-content">
            <span class="rules-button-text">Show Game Rules</span>
            <span class="rules-icon" aria-hidden="true">+</span>
        </button>
        <div id="rules-content" class="rules-content" role="region" aria-hidden="true">
            <h2 id="rules-heading" class="visually-hidden">Game Rules</h2>

            <h3>Objective</h3>
            <p>Be the first player to move any of your animals into the opponent's <strong>Den</strong> square.</p>
            <ul>
                <li>Orange's Den: <strong>d1</strong></li>
                <li>Yellow's Den: <strong>d9</strong></li>
            </ul>

            <h3>Gameplay</h3>
            <ul>
                <li>Orange starts the game.</li>
                <li>Players take turns moving one animal per turn.</li>
                <li>Animals move one square horizontally or vertically (never diagonally).</li>
                <li>You cannot move onto a square occupied by your own animal.</li>
            </ul>

            <h4>Attacking</h4>
            <ul>
                <li>You can move onto a square occupied by an opponent's animal if your animal's rank is <strong>equal to or higher than</strong> the opponent's rank.</li>
                <li>This is an attack, and the opponent's captured animal is removed from the board.</li>
                <li><strong>Exception:</strong> See Special Powers for Rat vs. Elephant.</li>
            </ul>

            <h4>End of Turn Sequence</h4>
            <p>After making your move, the following checks happen automatically:</p>
            <ol>
                <li><strong>Declare Hungry:</strong> Any of the <em>opponent's</em> animals that can now make a valid attack are marked as <strong>hungry</strong> (red glow).</li>
                <li><strong>Check Starvation:</strong> If any of <em>your own</em> animals were marked as hungry at the <em>start</em> of your turn, but you did not make an attacking move with any of them, those hungry animals starve and are removed from the board.</li>
            </ol>

            <h4>Special Squares</h4>
            <ul>
                <li><strong>Den:</strong> Your own Den (Orange: d1, Yellow: d9) cannot be entered by your pieces. Reaching the opponent's Den wins the game. A <strong>hungry</strong> animal cannot enter the opponent's Den.</li>
                <li><strong>Water (b4-c6, e4-f6):</strong> Only specific animals can enter or move on water (see Special Powers).</li>
                <li><strong>Traps:</strong>
                    <ul>
                        <li>Orange Traps: <strong>c1, d2, e1</strong></li>
                        <li>Yellow Traps: <strong>c9, d8, e9</strong></li>
                    </ul>
                    Any animal landing on a Trap square has its rank effectively reduced to <strong>0</strong> for the purpose of being attacked while on that square. A "(0)" marker appears above trapped animals. However, an animal attacking <em>from</em> a trap square uses its normal rank.
                 </li>
            </ul>

            <h4>Other Rules</h4>
            <ul>
                <li>You must make a move each turn (passing is not allowed).</li>
                <li>The game cannot end in a draw.</li>
            </ul>

            <h3>Special Powers</h3>
            <ul>
                <li><strong>Rat [1]:</strong>
                    <ul>
                        <li>Can enter, move on, and <strong>attack from Water</strong> squares.</li>
                        <li>Can attack the <strong>Elephant [8]</strong>, but only when attacking from a land square (cannot attack Elephant when starting from Water).</li>
                    </ul>
                 </li>
                 <li><strong>Dog [3]:</strong>
                    <ul>
                         <li>Can enter, move on, and <strong>attack from Water</strong> squares.</li>
                    </ul>
                 </li>
                 <li><strong>Lion [7] and Tiger [6]:</strong>
                    <ul>
                        <li>Can <strong>jump</strong> horizontally or vertically over <strong>Water</strong> squares.</li>
                        <li>A jump moves from a land square directly across 2 or 3 water squares to another land square.</li>
                        <li>Jumps can be used to move or attack.</li>
                        <li>A jump is blocked if an opponent's swimming animal (Rat or Dog) occupies any water square along the jump path.</li>
                    </ul>
                </li>
                 <li><strong>Leopard [5]:</strong>
                    <ul>
                        <li>Can <strong>jump horizontally</strong> over <strong>Water</strong> squares (across 2 water squares).</li>
                        <li>Cannot jump vertically.</li>
                        <li>Jumps follow the same blocking rules as Lion/Tiger.</li>
                    </ul>
                </li>
                <li><strong>Elephant [8]:</strong> Can attack the Rat [1].</li>
            </ul>

            <h3>Repetition Limit</h3>
            <p>To prevent endless loops and ensure a winner, a repetition rule exists:</p>
            <ul>
                <li>Determine which player currently has more animals on the board. If tied, the starting player (Orange) is considered the "leading player".</li>
                <li>The leading player is <strong>not allowed</strong> to make a move that results in a board position that has already occurred <strong>3 times</strong> previously during the game.</li>
            </ul>
            <p><em>(Board positions are tracked automatically.)</em></p>

        </div><!-- /#rules-content -->
    </section><!-- /#rules-accordion-container -->

    <!-- Debug Log Section (conditionally displayed) -->
    <section id="debug-log-container" aria-labelledby="debug-log-heading">
        <h2 id="debug-log-heading">Debug Log</h2>
        <div id="debug-log-output">
            <!-- Console messages mirrored here if debug = true -->
        </div>
        <button id="clear-debug-log" class="game-button" style="margin-top: 10px; background-color: #dc3545;">Clear Log</button>
    </section>

    <!-- Utility class to visually hide elements but keep them accessible -->
    <style>
        .visually-hidden {
            position: absolute;
            width: 1px;
            height: 1px;
            margin: -1px;
            padding: 0;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            border: 0;
        }
    </style>

    <!-- Hidden container for preloading/caching piece image assets -->
    <div id="piece-assets" style="display: none;">
        <!-- Orange Pieces -->
        <img data-piece="O_8" src="https://staticjw.com/clesto/animals/elephant-orange.png" alt="Orange Elephant (8)" loading="lazy">
        <img data-piece="O_7" src="https://staticjw.com/clesto/animals/lion-orange.png" alt="Orange Lion (7)" loading="lazy">
        <img data-piece="O_6" src="https://staticjw.com/clesto/animals/tiger-orange.png" alt="Orange Tiger (6)" loading="lazy">
        <img data-piece="O_5" src="https://staticjw.com/clesto/animals/leopard-orange.png" alt="Orange Leopard (5)" loading="lazy">
        <img data-piece="O_4" src="https://staticjw.com/clesto/animals/wolf-orange.png" alt="Orange Wolf (4)" loading="lazy">
        <img data-piece="O_3" src="https://staticjw.com/clesto/animals/dog-orange.png" alt="Orange Dog (3)" loading="lazy">
        <img data-piece="O_2" src="https://staticjw.com/clesto/animals/cat-orange.png" alt="Orange Cat (2)" loading="lazy">
        <img data-piece="O_1" src="https://staticjw.com/clesto/animals/rat-orange.png" alt="Orange Rat (1)" loading="lazy">
        <!-- Yellow Pieces -->
        <img data-piece="Y_8" src="https://staticjw.com/clesto/animals/elephant-yellow.png" alt="Yellow Elephant (8)" loading="lazy">
        <img data-piece="Y_7" src="https://staticjw.com/clesto/animals/lion-yellow.png" alt="Yellow Lion (7)" loading="lazy">
        <img data-piece="Y_6" src="https://staticjw.com/clesto/animals/tiger-yellow.png" alt="Yellow Tiger (6)" loading="lazy">
        <img data-piece="Y_5" src="https://staticjw.com/clesto/animals/leopard-yellow.png" alt="Yellow Leopard (5)" loading="lazy">
        <img data-piece="Y_4" src="https://staticjw.com/clesto/animals/wolf-yellow.png" alt="Yellow Wolf (4)" loading="lazy">
        <img data-piece="Y_3" src="https://staticjw.com/clesto/animals/dog-yellow.png" alt="Yellow Dog (3)" loading="lazy">
        <img data-piece="Y_2" src="https://staticjw.com/clesto/animals/cat-yellow.png" alt="Yellow Cat (2)" loading="lazy">
        <img data-piece="Y_1" src="https://staticjw.com/clesto/animals/rat-yellow.png" alt="Yellow Rat (1)" loading="lazy">
    </div>

    <!-- Shared Tooltip for Move Log -->
    <span id="move-log-tooltip" class="log-tooltip shared-tooltip" role="tooltip" aria-hidden="true"></span>

    <!-- Turn Start Sound -->
    <audio id="turn-start-sound" src="https://staticjw.com/clesto/play/notification-alert.mp3" preload="auto"></audio>
    <audio id="capture-sound" src="https://staticjw.com/clesto/play/capture.mp3" preload="auto"></audio>
    <audio id="error-sound" src="https://staticjw.com/clesto/play/error.mp3" preload="auto"></audio>
    <audio id="hungry-warning-sound" src="https://staticjw.com/clesto/play/hungry-warning.mp3" preload="auto"></audio>
    <audio id="undo-sound" src="https://staticjw.com/clesto/play/undo-move.mp3" preload="auto"></audio>
    <audio id="win-sound" src="https://staticjw.com/clesto/play/win.mp3" preload="auto"></audio>
    <audio id="background-music" src="https://staticjw.com/clesto/play/background-music.mp3" preload="auto" loop></audio>

    <script>
    window.addEventListener('load', () => { // Changed from DOMContentLoaded
        // --- Debug Flag ---
        const debug = true; // SET TO true TO SHOW DEBUG PANEL, false TO HIDE

        // --- DOM Element References ---
        const boardElement = document.getElementById('board');
        const boardGridWrapper = document.getElementById('board-grid-wrapper');
        const turnIndicator = document.getElementById('turn-indicator');
        const statusMessage = document.getElementById('status-message');
        const resetButton = document.getElementById('reset-button');
        const undoButton = document.getElementById('undo-button');
        const moveLogElement = document.getElementById('move-log');
        const copyLogButton = document.getElementById('copy-log-button');
        const boardStateLogElement = document.getElementById('board-state-log');
        const copyStateButton = document.getElementById('copy-state-button');
        const pieceAssetContainer = document.getElementById('piece-assets');
        const debugLogContainer = document.getElementById('debug-log-container');
        const debugLogOutput = document.getElementById('debug-log-output');
        const clearDebugLogButton = document.getElementById('clear-debug-log');
        // --- DOM Element References (Add Clock Elements) ---
        const orangeClockContainer = document.getElementById('orange-clock-container');
        const yellowClockContainer = document.getElementById('yellow-clock-container');
        const orangeClockTimeElement = document.getElementById('orange-clock-time');
        const yellowClockTimeElement = document.getElementById('yellow-clock-time');
        // --- DOM Element References (Add Tooltip) ---
        const sharedMoveTooltip = document.getElementById('move-log-tooltip');

        // --- Sounds ---
        const turnSoundElement = document.getElementById('turn-start-sound');
        const captureSoundElement = document.getElementById('capture-sound');
        const errorSoundElement = document.getElementById('error-sound');
        const hungryWarningSoundElement = document.getElementById('hungry-warning-sound');
        const undoSoundElement = document.getElementById('undo-sound');
        const winSoundElement = document.getElementById('win-sound');

        // --- Set Win Sound Volume ---
        if (winSoundElement) winSoundElement.volume = 0.6; // Set win sound volume to 60%
        // --- End Win Sound Volume ---

        // --- Add Background Music & Control References ---
        const backgroundMusicElement = document.getElementById('background-music');
        const musicVolumeSlider = document.getElementById('music-volume-slider');
        const musicVolumeDisplay = document.getElementById('music-volume-display'); // Optional display
        const sfxToggleCheckbox = document.getElementById('sfx-toggle');
        // --- End Background Music & Control References ---

        // --- Audio State Variables ---
        let soundEffectsEnabled = true; // SFX are on by default
        let hasInteracted = false; // To track first user interaction for starting music

        // --- Console Override & Debug Panel Logic ---
        // Store original console methods
        const originalConsole = {
            log: console.log,
            warn: console.warn,
            error: console.error
        };

        /**
         * Plays the specified sound effect element IF sound effects are enabled.
         * Resets playback position and handles potential browser errors.
         * @param {HTMLAudioElement|null} soundElement - The audio element to play.
         * @param {string} soundName - A descriptive name for logging purposes.
         */
        function playSound(soundElement, soundName = 'Sound') {
            // *** ADD CHECK FOR SFX ENABLED ***
            if (!soundEffectsEnabled) {
                // console.log(`SFX Skipped: ${soundName} (Sound effects are OFF)`);
                return; // Don't play if SFX are toggled off
            }
            // *** END CHECK ***

            if (soundElement) {
                soundElement.currentTime = 0; // Rewind to start
                soundElement.play().catch(error => {
                    console.warn(`${soundName} playback failed:`, error);
                });
            } else {
                console.warn(`Attempted to play non-existent sound element: ${soundName}`);
            }
        }

        /** function to attempt starting background music
         * Attempts to start the background music playback.
         * Called after first user interaction.
         */
        function startBackgroundMusic() {
            if (!backgroundMusicElement) {
                console.warn("Background music element not found.");
                return;
            }
            // Check if already playing to avoid interrupting itself
            if (backgroundMusicElement.paused) {
                backgroundMusicElement.play().then(() => {
                    console.log("Background music started.");
                }).catch(error => {
                    console.warn("Background music playback failed (likely requires user interaction first):", error);
                    // Don't set hasInteracted = false here, let subsequent interactions try again.
                });
            }
        }

        // --- Copy Log Button Logic ---
        if (copyLogButton && moveLogElement) {
            copyLogButton.addEventListener('click', handleCopyLogClick);
        } else {
            console.warn("Could not find Copy Log button or Move Log element.");
        }

        /**
         * Handles the click event for the Copy Log button.
         * Extracts text from the move log, formats it, and copies it to the clipboard.
         * Provides user feedback on the button.
         */
        function handleCopyLogClick() {
            const logEntries = moveLogElement.querySelectorAll('.log-entry');
            if (logEntries.length === 0) {
                copyLogButton.textContent = "Log Empty ðŸ“‹";
                copyLogButton.disabled = true;
                setTimeout(() => {
                    copyLogButton.textContent = "Copy Log ðŸ“‹";
                    copyLogButton.disabled = false;
                }, 1500);
                return;
            }

            // Extract text content from each entry.
            // The non-breaking spaces should now be included correctly.
            const logLines = Array.from(logEntries).map(entry => {
                 // Trim potential extra whitespace around the whole line just in case
                return entry.textContent.trim();
            });
            const formattedLogText = logLines.join('\n'); // Join lines with newline characters

            if (!navigator.clipboard) {
                console.error("Clipboard API not available. Cannot copy.");
                copyLogButton.textContent = "Copy Failed";
                // Optionally disable button permanently if API is missing
                // copyLogButton.disabled = true;
                setTimeout(() => { copyLogButton.textContent = "Copy Log ðŸ“‹"; }, 2000);
                return;
            }

            // Use the Clipboard API to write the text
            navigator.clipboard.writeText(formattedLogText).then(() => {
                // Success feedback
                const originalText = "Copy Log ðŸ“‹"; // Store original text
                copyLogButton.textContent = "Copied! ðŸ“‹";
                copyLogButton.disabled = true; // Briefly disable
                console.log("Move log copied to clipboard.");

                // Revert button text and state after a delay
                setTimeout(() => {
                    copyLogButton.textContent = originalText;
                    copyLogButton.disabled = false;
                }, 1500); // Revert after 1.5 seconds

            }).catch(err => {
                // Error feedback
                console.error('Failed to copy move log: ', err);
                copyLogButton.textContent = "Copy Failed";
                 setTimeout(() => { copyLogButton.textContent = "Copy Log"; }, 2000);
            });
        }
        // --- End Copy Log Button Logic ---

        // --- Copy Board State Button Logic ---
        if (copyStateButton && boardStateLogElement) {
            copyStateButton.addEventListener('click', handleCopyStateClick);
        } else {
            console.warn("Could not find Copy State button or Board State Log element.");
        }

        /**
         * Handles the click event for the Copy State button.
         * Extracts the board state string from its display element and copies it to the clipboard.
         * Provides user feedback on the button.
         */
        function handleCopyStateClick() {
            const stateString = boardStateLogElement.textContent; // Get text from the display element

            if (!stateString || stateString.trim() === '') {
                copyStateButton.textContent = "State Empty ðŸ“‹";
                copyStateButton.disabled = true;
                setTimeout(() => {
                    copyStateButton.textContent = "Copy Board State ðŸ“‹";
                    copyStateButton.disabled = false;
                }, 1500);
                return;
            }

            if (!navigator.clipboard) {
                console.error("Clipboard API not available. Cannot copy.");
                copyStateButton.textContent = "Copy Failed ðŸ“‹";
                setTimeout(() => { copyStateButton.textContent = "Copy Board State ðŸ“‹"; }, 2000);
                return;
            }

            // Use the Clipboard API to write the text
            navigator.clipboard.writeText(stateString).then(() => {
                // Success feedback
                const originalText = "Copy Board State ðŸ“‹"; // Store original text
                copyStateButton.textContent = "Copied! ðŸ“‹";
                copyStateButton.disabled = true; // Briefly disable
                console.log("Board state string copied to clipboard.");

                // Revert button text and state after a delay
                setTimeout(() => {
                    copyStateButton.textContent = originalText;
                    copyStateButton.disabled = false;
                }, 1500); // Revert after 1.5 seconds

            }).catch(err => {
                // Error feedback
                console.error('Failed to copy board state string: ', err);
                copyStateButton.textContent = "Copy Failed ðŸ“‹";
                setTimeout(() => { copyStateButton.textContent = "Copy Board State ðŸ“‹"; }, 2000);
            });
        }
        // --- End Copy Board State Button Logic ---

        /** // NEW function to handle the first user interaction
         * Called on first click/touch/drag to enable audio context and start music.
         */
        function handleFirstInteraction() {
            if (!hasInteracted) {
                console.log("First user interaction detected, attempting to start background music.");
                hasInteracted = true; // Set flag so this only runs once
                // Attempt to start the background music
                startBackgroundMusic();
                // Optional: Try to play a silent sound to unlock audio context on some mobile browsers
                // const dummySound = new Audio();
                // dummySound.src = 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA'; // Tiny silent wav
                // dummySound.play().catch(()=>{});
            }
        }

        /**
         * Formats console arguments into a single string, handling objects and circular references.
         * @param {Array} args - The arguments passed to the console method.
         * @returns {string} A formatted string representation of the arguments.
         */
        function formatArgs(args) {
            const seen = new Set(); // Used to detect circular references in objects
            return Array.from(args).map(arg => {
                if (typeof arg === 'object' && arg !== null) {
                    try {
                        // Stringify objects, handling circular references
                        seen.clear(); // Reset for each top-level object
                        return JSON.stringify(arg, (key, value) => {
                            if (typeof value === 'object' && value !== null) {
                                if (seen.has(value)) {
                                    return '[Circular]'; // Placeholder for circular reference
                                }
                                seen.add(value);
                            }
                            return value;
                        }, 2); // Indent with 2 spaces for readability
                    } catch (e) {
                        // Handle potential errors during stringification
                        if (e instanceof TypeError && e.message.includes('circular structure')) {
                            return '[Circular Object]';
                        }
                        return '[Unserializable Object]';
                    }
                }
                if (typeof arg === 'function') {
                    return '[Function]';
                }
                if (typeof arg === 'undefined') {
                    return 'undefined';
                }
                return String(arg); // Convert other types to string
            }).join(' '); // Join arguments with spaces
        }

        /**
         * Logs a message to the debug panel if debugging is enabled.
         * @param {string} level - The log level ('log', 'warn', 'error').
         * @param {Array} args - The original arguments passed to the console method.
         */
        function logToPanel(level, args) {
            if (!debug || !debugLogOutput) return; // Only log if debug is true and panel exists

            const message = formatArgs(args);
            const timestamp = new Date().toLocaleTimeString();
            const entry = document.createElement('div');
            entry.classList.add('debug-log-entry');

            // Add timestamp
            const timeSpan = document.createElement('span');
            timeSpan.classList.add('debug-log-timestamp');
            timeSpan.textContent = `[${timestamp}]`;
            entry.appendChild(timeSpan);

            // Add message content with appropriate styling
            const messageSpan = document.createElement('span');
            messageSpan.textContent = message;
            if (level === 'warn') {
                messageSpan.classList.add('debug-log-warn');
            } else if (level === 'error') {
                messageSpan.classList.add('debug-log-error');
            }
            entry.appendChild(messageSpan);

            // Append to panel and scroll to bottom
            debugLogOutput.appendChild(entry);
            debugLogOutput.scrollTop = debugLogOutput.scrollHeight;
        }

        // Override console methods to also log to the panel and suppress console output if debug is false
        console.log = function(...args) {
            // Only call the original console.log if debug is true
            if (debug) {
                originalConsole.log.apply(console, args);
            }
            // Always attempt to log to the panel (it has its own internal debug check)
            logToPanel('log', args);
        };
        console.warn = function(...args) {
            // Only call the original console.warn if debug is true
            if (debug) {
                originalConsole.warn.apply(console, args);
            }
            // Always attempt to log to the panel (it has its own internal debug check)
            logToPanel('warn', args);
        };
        console.error = function(...args) {
            // Only call the original console.error if debug is true
            if (debug) {
                originalConsole.error.apply(console, args);
            }
            // Always attempt to log to the panel (it has its own internal debug check)
            logToPanel('error', args);
        };

        // Show or hide the debug panel based on the debug flag
        if (!debug && debugLogContainer) {
            debugLogContainer.classList.add('debug-hidden');
        } else if (debugLogContainer) {
            debugLogContainer.classList.remove('debug-hidden');
        }

        // Add event listener for the "Clear Log" button
        if (clearDebugLogButton && debugLogOutput) {
            clearDebugLogButton.addEventListener('click', () => {
                debugLogOutput.innerHTML = ''; // Clear panel content
                // Log clearing only if debug is enabled
                if (debug) {
                     originalConsole.log("Debug log cleared."); // Use originalConsole here directly if desired, or rely on the override
                }
                 logToPanel('log', ["Debug log cleared."]); // Log to panel regardless
            });
        }
        // --- END Console Override ---


        // --- Game Constants ---
        const ROWS = 9;
        const COLS = 7;
        const NUM_PIECE_TYPES = 16; // 8 ranks * 2 players
        const SQUARES = 63; // 9 rows * 7 columns
        const TT_ENTRY_TYPE = {
            EXACT: 0,       // Score is the exact value for the node
            LOWER_BOUND: 1, // Score is at least this value (alpha cutoff occurred)
            UPPER_BOUND: 2  // Score is at most this value (beta cutoff occurred / no move improved alpha)
        };
        const TRANSPOSITION_TABLE_SIZE = 1 << 20; // Approx 1 million entries (conceptual size)
        const PLAYERS = {
            ORANGE: 'orange',
            YELLOW: 'yellow'
        };
        const RANK_TO_NAME = {
            8: 'Elephant',
            7: 'Lion',
            6: 'Tiger',
            5: 'Leopard',
            4: 'Wolf',
            3: 'Dog',
            2: 'Cat',
            1: 'Rat'
        };
        const RANK_TO_CODE = { // Used for move notation
            8: '8',
            7: '7',
            6: '6',
            5: '5',
            4: '4',
            3: '3',
            2: '2',
            1: '1'
        };
        const SPECIAL_ABILITIES = { // Defines unique animal traits
            1: {
                name: 'Rat',
                rank: 1,
                swims: true,
                attacksElephant: true
            }, // Can swim, attack Elephant (unless Elephant is in water)
            2: {
                name: 'Cat',
                rank: 2
            },
            3: {
                name: 'Dog',
                rank: 3,
                swims: true
            }, // Can swim
            4: {
                name: 'Wolf',
                rank: 4
            },
            5: {
                name: 'Leopard',
                rank: 5,
                jumpH: true
            }, // Can jump horizontally over water
            6: {
                name: 'Tiger',
                rank: 6,
                jumpH: true,
                jumpV: true
            }, // Can jump horizontally and vertically over water
            7: {
                name: 'Lion',
                rank: 7,
                jumpH: true,
                jumpV: true
            }, // Can jump horizontally and vertically over water
            8: {
                name: 'Elephant',
                rank: 8
            } // Cannot be attacked by Rat (except special case)
        };
        const INITIAL_SETUP = { // Standard starting positions
            // Orange Pieces (Bottom Row Area) - Sorted Rank 8 to 1
            'a3': { player: PLAYERS.ORANGE, rank: 8 }, // Elephant
            'g1': { player: PLAYERS.ORANGE, rank: 7 }, // Lion
            'a1': { player: PLAYERS.ORANGE, rank: 6 }, // Tiger
            'e3': { player: PLAYERS.ORANGE, rank: 5 }, // Leopard
            'f2': { player: PLAYERS.ORANGE, rank: 4 }, // Wolf
            'c3': { player: PLAYERS.ORANGE, rank: 3 }, // Dog
            'b2': { player: PLAYERS.ORANGE, rank: 2 }, // Cat
            'g3': { player: PLAYERS.ORANGE, rank: 1 }, // Rat
            // Yellow Pieces (Top Row Area) - Sorted Rank 8 to 1
            'g7': { player: PLAYERS.YELLOW, rank: 8 }, // Elephant
            'a9': { player: PLAYERS.YELLOW, rank: 7 }, // Lion
            'g9': { player: PLAYERS.YELLOW, rank: 6 }, // Tiger
            'c7': { player: PLAYERS.YELLOW, rank: 5 }, // Leopard
            'b8': { player: PLAYERS.YELLOW, rank: 4 }, // Wolf
            'e7': { player: PLAYERS.YELLOW, rank: 3 }, // Dog
            'f8': { player: PLAYERS.YELLOW, rank: 2 }, // Cat
            'a7': { player: PLAYERS.YELLOW, rank: 1 }  // Rat
        };
        const WATER_SQUARES = new Set(['b4', 'c4', 'e4', 'f4', 'b5', 'c5', 'e5', 'f5', 'b6', 'c6', 'e6', 'f6']);
        const TRAPS = { // Opponent's pieces lose rank on these squares
            orange: new Set(['c9', 'd8', 'e9']), // Traps near Yellow's Den (affect Yellow pieces)
            yellow: new Set(['c1', 'd2', 'e1']) // Traps near Orange's Den (affect Orange pieces)
        };
        const ALL_TRAP_SQUARES = new Set([...TRAPS.orange, ...TRAPS.yellow]);
        const DENS = { // Winning squares for each player
            orange: 'd1', // Orange's Den
            yellow: 'd9' // Yellow's Den
        };
        const MINIMAX_DEPTH = 10; // Depth for AI search (higher = stronger but slower)
        const MAX_SEARCH_DEPTH = MINIMAX_DEPTH; // Max depth for main search
        const MAX_QUIESCENCE_DEPTH = 4; // How deep qsearch can go beyond main depth
        // Time Management Constants
        const TIME_USAGE_FACTOR = 1 / 20; // Use roughly 1/20th of remaining time per move
        const MIN_TIME_PER_MOVE = 1000;  // Minimum milliseconds AI will spend (if time allows)
        // Factor used for pre-emptive time check in ID. If elapsed time > timeLimit * factor, stop deepening.
        const TIME_PREDICTION_FACTOR = 0.65; // Stop if > 65% of time is used (tune this)

        // ==============================================
        // AI Evaluation Constants (Consolidated & Rescaled)
        // ==============================================

        // --- Core Scores ---
        const AI_WIN_SCORE = 10000; // Keep large for definitive win/loss
        const AI_LOSE_SCORE = -10000;

        // --- Mate Score Adjustments (Derived from Core Scores) ---
        // These remain relative to the large win/loss scores
        const MATE_SCORE_THRESHOLD = AI_WIN_SCORE / 1.1;
        const MATED_SCORE_THRESHOLD = AI_LOSE_SCORE / 1.1;

        // --- Material ---
        const AI_MATERIAL_MULT = 1.0; // Multiplier remains 1
        // *** NEW RESCALED PIECE VALUES ***
        const AI_PIECE_VALUES = { 1: 3, 2: 1, 3: 3, 4: 2, 5: 4, 6: 6, 7: 9, 8: 7 };

        // --- Mobility (Scaled down significantly) ---
        const AI_MOBILITY_BONUS = 0.1; // Small bonus per move
        const AI_OPP_MOBILITY_PENALTY = 0.1; // Small penalty per opponent move

        // --- Positional Factors (Scaled down) ---
        const AI_ADVANCE_ROW_BONUS = 0.4; // Smaller bonus per row advanced
        const AI_RIVER_CROSS_BONUS = 3;   // Smaller bonus for crossing river
        const AI_CENTER_COL_BONUS = 0.5;  // Small bonus for center columns
        const AI_CENTER_CONTROL_BONUS = 1; // Small additional bonus for center past river
        const AI_WATER_CONTROL_BONUS = 2.5; // Scaled bonus for Rat/Dog on water

        // --- Den Proximity & Threats (Scaled down, but keep relative impact high) ---
        const AI_DEN_PROXIMITY_BONUS_1 = 60;  // Significant bonus for adjacent to den
        const AI_DEN_PROXIMITY_BONUS_2 = 25;  // Moderate bonus for 2 steps away
        // Keep win/loss adjacent bonuses relative to the main win/loss scores
        const AI_WIN_ADJACENT_BONUS = AI_WIN_SCORE * 0.8;
        const AI_OWN_DEN_NEAR_PENALTY = -5;   // Scaled penalty for opponent near own den
        const AI_IMMEDIATE_WIN_THREAT_PENALTY = -AI_WIN_SCORE * 0.9;

        // --- Trap Interaction (Scaled down) ---
        const AI_TRAP_DANGER_PENALTY = -25;     // Scaled base penalty for AI on own trap
        const AI_GUARDED_TRAP_MULT = 2.0;       // Multiplier remains the same
        const AI_NEAR_OPP_TRAP_BONUS = 1.5;     // Scaled bonus for AI near opponent trap

        // --- Piece Safety & Threats (Scaled down) ---
        const AI_PIECE_THREATENED_PENALTY_MULT = 0.5; // Multiplier applied to *new* piece value
        const AI_THREATENING_BONUS = 4;           // Scaled bonus for threatening an opponent piece
        const AI_THREATENED_OPP_BONUS_MULT = 0.4;   // Multiplier applied to *new* piece value

        // --- Specific Piece Roles / Hunger (Scaled down) ---
        const AI_HUNGER_PENALTY = -6;             // Scaled penalty per hungry AI piece
        const AI_WOLF_CAT_DEFENSE_BONUS = 1;      // Scaled bonus for defensive Wolf/Cat
        const AI_WOLF_CAT_ADVANCE_PENALTY = -0.3; // Scaled penalty *per row* advanced for Wolf/Cat
        const AI_BLOCKING_JUMPER_PENALTY = -15;   // Scaled penalty for blocking friendly jumpers

        // --- Move Ordering Bonuses (Adjusted to fit new eval scale) ---
        // These don't need strict scaling, just logical placement relative to eval scores
        const AI_KILLER_MOVE_BONUS = 50; // Keep reasonably high to prioritize over history/quiet
        const AI_HISTORY_MAX = 1000;     // Cap for history scores (can be lower if needed)

        // --- Game State Variables ---
        let gameState = {}; // Holds current board, player, turn, etc.
        let gameHistory = []; // Stores previous game states for undo functionality
        let zobristKeys = {}; // To store Zobrist keys
        let transpositionTable = new Map(); // Transposition Table
        let killerMoves = [];

        // Stores history scores [pieceTypeIndex][toSquareIndex] -> score
        // Size initialized in initializeAISearchState
        let historyHeuristic = [];

        let timeLimit = 0; // Dynamic time limit per move in ms
        let nodeCount = 0;
        let searchStartTime = 0;
        let searchCancelled = false;
        let draggedPieceElement = null; // Reference to the DOM element being dragged
        let sourceCoords = null; // Coordinates of the piece being dragged/clicked
        let selectedPieceCoords = null; // Coordinates of the piece selected via click/tap
        let focusedCoords = null; // Coordinates of the currently focused cell/piece (for keyboard nav)
        let playerLastMoves = {
            [PLAYERS.ORANGE]: { from: null, to: null },
            [PLAYERS.YELLOW]: { from: null, to: null }
        };
        let isDragging = false; // Flag to track if a drag operation is in progress
        let isPlayerVsPlayerMode = false; // Flag for PvP mode (default is PvE)
        let aiMoveTimeoutId = null; // To store the AI delay timeout
        let isLoadStateInputFocused = false; // Flag for input focus

        // --- Clock Constants & State ---
        const INITIAL_TIME_SECONDS = 10 * 60; // 10 minutes
        const INCREMENT_SECONDS = 2; // 2 seconds bonus per move
        let orangeTime = INITIAL_TIME_SECONDS;
        let yellowTime = INITIAL_TIME_SECONDS;
        let orangeTimerId = null; // To store the interval ID for Orange's clock
        let yellowTimerId = null; // To store the interval ID for Yellow's clock


        // --- Utility Functions ---
        /**
         * Converts zero-based row and column indices to algebraic notation (e.g., 0,0 -> 'a9').
         * @param {number} row - The row index (0-8).
         * @param {number} col - The column index (0-6).
         * @returns {string|null} The algebraic coordinates (e.g., 'a1', 'g9') or null if invalid.
         */
        function getCoords(row, col) {
            if (row < 0 || row >= ROWS || col < 0 || col >= COLS) return null;
            // Column 'a' is ASCII 97. Row 9 is at index 0.
            return `${String.fromCharCode(97 + col)}${ROWS - row}`;
        }

        /**
         * Converts algebraic notation coordinates to zero-based row and column indices.
         * @param {string} coords - The algebraic coordinates (e.g., 'a1').
         * @returns {{row: number, col: number}|null} An object with row and col indices, or null if invalid.
         */
        function getRowCol(coords) {
            if (!coords || coords.length < 2) return null;
            const col = coords.charCodeAt(0) - 97; // 'a' -> 0, 'b' -> 1, ...
            const rowNum = parseInt(coords.substring(1));
            if (isNaN(rowNum)) return null;
            const row = ROWS - rowNum; // '9' -> 0, '8' -> 1, ...
            if (row < 0 || row >= ROWS || col < 0 || col >= COLS) return null;
            return { row, col };
        }

        /**
         * Determines which player is currently restricted by the repetition rule.
         * The player with more pieces is restricted. If piece counts are equal, Orange is restricted.
         * @param {object} [board=gameState.board] - The board state to evaluate. Defaults to current game state.
         * @returns {string} The player ('orange' or 'yellow') who is restricted.
         */
        function getRestrictedPlayer(board = gameState.board) {
            const orangeCount = Object.values(board).filter(p => p?.player === PLAYERS.ORANGE).length;
            const yellowCount = Object.values(board).filter(p => p?.player === PLAYERS.YELLOW).length;

            if (orangeCount > yellowCount) {
                return PLAYERS.ORANGE;
            } else if (yellowCount > orangeCount) {
                return PLAYERS.YELLOW;
            } else {
                // If counts are equal, the starting player (Orange) is restricted
                return PLAYERS.ORANGE;
            }
        }

        /**
         * Retrieves the data object for a piece at the given coordinates from the current game state.
         * @param {string} coords - The algebraic coordinates (e.g., 'a1').
         * @returns {object|null} The piece data object ({player, rank, ...}) or null if the square is empty.
         */
        function getPieceData(coords) {
            return gameState.board[coords] || null;
        }

        /**
         * Generates the DOM ID for a piece element based on its coordinates.
         * @param {string} coords - The coordinates (e.g., 'a1').
         * @returns {string} The DOM ID string (e.g., 'piece-a1').
         */
        function getPieceElementId(coords) {
            return `piece-${coords}`;
        }

        /**
         * Generates the DOM ID for a cell element based on coordinates.
         * @param {string} coords - The coordinates (e.g., 'a1').
         * @returns {string} The DOM ID string (e.g., 'cell-a1').
         */
        function getCellElementId(coords) {
            return `cell-${coords}`;
        }

        /**
         * Gets orthogonal adjacent coordinates for a given square.
         * @param {string} coords - The algebraic coordinates (e.g., 'd9').
         * @returns {string[]} An array of valid adjacent coordinate strings.
         */
        function getAdjacentCoords(coords) {
            const adjacent = [];
            const rc = getRowCol(coords);
            if (!rc) return [];
            const { row, col } = rc;
            const potential = [
                getCoords(row + 1, col), // Down
                getCoords(row - 1, col), // Up
                getCoords(row, col + 1), // Right
                getCoords(row, col - 1)  // Left
            ];
            potential.forEach(c => {
                if (c) adjacent.push(c); // Add if valid coords
            });
            return adjacent;
        }

        /**
         * Gets a set of unique adjacent coordinates for a given set of starting coordinates.
         * @param {Set<string>} coordsSet - A Set of algebraic coordinates (e.g., trap squares).
         * @returns {Set<string>} A Set of unique, valid adjacent coordinate strings.
         */
        function getAdjacentCoordsSet(coordsSet) {
            const allAdjacent = new Set();
            if (!coordsSet) return allAdjacent;

            coordsSet.forEach(coord => {
                const adjacent = getAdjacentCoords(coord); // Use existing helper
                adjacent.forEach(adjCoord => {
                    if (adjCoord) allAdjacent.add(adjCoord);
                });
            });
            return allAdjacent;
        }

        /**
         * Checks if the given coordinates correspond to ANY trap square.
         * @param {string} coords - The algebraic coordinates to check.
         * @returns {boolean} True if the coordinates are a trap square, false otherwise.
         */
        function isOnTrapSquare(coords) {
            if (!coords) return false;
            // Use the pre-defined Set containing all trap squares
            return ALL_TRAP_SQUARES.has(coords);
        }

        /**
         * Generates a random 64-bit BigInt.
         * Uses Math.random() which is pseudo-random, sufficient for this purpose.
         * Ensures the result is non-zero.
         * @returns {bigint} A random BigInt between 1 and 2^64 - 1.
         */
        function generateRandomBigInt() {
            let randomBigInt;
            do {
                // Generate two 32-bit random numbers and combine them
                const high = BigInt(Math.floor(Math.random() * (2 ** 32)));
                const low = BigInt(Math.floor(Math.random() * (2 ** 32)));
                // Shift the high part by 32 bits and combine with the low part
                randomBigInt = (high << 32n) | low;
            } while (randomBigInt === 0n); // Ensure the key is not zero
            return randomBigInt;
        }

        /**
         * Initializes the coordinate-to-index mapping used by Zobrist hashing.
         * Must be called before any Zobrist functions relying on square indices.
         * Stores the mapping in `zobristKeys.squareCoords`.
         * Example: 'a9' -> 0, 'b9' -> 1, ..., 'g1' -> 62
         */
        function initializeCoordMaps() {
            if (zobristKeys.squareCoords) return; // Already initialized

            zobristKeys.squareCoords = {};
            let index = 0;
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const coords = getCoords(r, c);
                    if (coords) {
                        zobristKeys.squareCoords[coords] = index;
                        index++;
                    }
                }
            }
            if (index !== SQUARES) {
                 console.error(`Zobrist Map Init Error: Expected ${SQUARES} squares, mapped ${index}.`);
            }
             // console.log("Initialized Zobrist coordinate mapping:", zobristKeys.squareCoords);
        }

        /**
         * Gets the unique index (0-15) for a given piece type (player and rank).
         * Orange ranks 1-8 map to 0-7.
         * Yellow ranks 1-8 map to 8-15.
         * @param {string} player - The player ('orange' or 'yellow').
         * @param {number} rank - The piece rank (1-8).
         * @returns {number} The piece type index (0-15), or -1 if invalid input.
         */
        function getPieceTypeIndex(player, rank) {
            if (rank < 1 || rank > 8) return -1;
            if (player === PLAYERS.ORANGE) {
                return rank - 1; // Orange R1=0, R2=1, ..., R8=7
            } else if (player === PLAYERS.YELLOW) {
                return rank - 1 + 8; // Yellow R1=8, R2=9, ..., R8=15
            }
            return -1; // Invalid player
        }

        /**
         * Gets the Zobrist square index (0-62) for given algebraic coordinates.
         * Relies on `zobristKeys.squareCoords` being initialized.
         * @param {string} coords - Algebraic coordinates (e.g., 'a1').
         * @returns {number} The square index, or -1 if invalid or map not ready.
         */
        function getSquareIndex(coords) {
            if (!zobristKeys.squareCoords) {
                console.error("getSquareIndex called before Zobrist maps initialized.");
                initializeCoordMaps(); // Attempt lazy initialization
            }
            const index = zobristKeys.squareCoords[coords];
            return (typeof index === 'number') ? index : -1; // Return -1 if coords not found
        }


        // --- Clock Helper Functions ---
        /**
         * Formats remaining seconds into MM:SS string format.
         * @param {number} totalSeconds - The total seconds remaining.
         * @returns {string} Formatted time string (e.g., "09:58").
         */
        function formatTime(totalSeconds) {
            const seconds = Math.max(0, totalSeconds); // Ensure time doesn't go below 0
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = Math.floor(seconds % 60);
            const formattedMinutes = String(minutes).padStart(2, '0');
            const formattedSeconds = String(remainingSeconds).padStart(2, '0');
            return `${formattedMinutes}:${formattedSeconds}`;
        }

        /**
         * Plays the turn start sound effect using the helper function.
         */
        function playTurnSound() {
             playSound(turnSoundElement, "Turn Sound"); // Use the helper
        }

        /**
         * Updates the clock display for a specific player in the DOM.
         * Also adds/removes a 'time-out' class if the time is zero or less.
         * @param {string} player - The player ('orange' or 'yellow').
         * @param {number} timeSeconds - The time in seconds to display.
         */
        function updateClockDisplay(player, timeSeconds) {
            const formattedTime = formatTime(timeSeconds);
            let clockElement = null;

            if (player === PLAYERS.ORANGE && orangeClockTimeElement) {
                clockElement = orangeClockTimeElement;
            } else if (player === PLAYERS.YELLOW && yellowClockTimeElement) {
                clockElement = yellowClockTimeElement;
            }

            if (clockElement) {
                clockElement.textContent = formattedTime; // Update time text

                // Add or remove the 'time-out' class based on the time value
                if (timeSeconds <= 0) {
                    clockElement.classList.add('time-out');
                } else {
                    clockElement.classList.remove('time-out');
                }
            }
        }

        /**
         * Stops the interval timer for a specific player's clock.
         * @param {string} player - The player ('orange' or 'yellow').
         */
        function stopClock(player) {
            if (player === PLAYERS.ORANGE) {
                if (orangeTimerId !== null) {
                    clearInterval(orangeTimerId);
                    orangeTimerId = null;
                    // console.log("Stopped Orange Clock");
                }
                 if (orangeClockContainer) orangeClockContainer.classList.remove('clock-active');
            } else if (player === PLAYERS.YELLOW) {
                if (yellowTimerId !== null) {
                    clearInterval(yellowTimerId);
                    yellowTimerId = null;
                    // console.log("Stopped Yellow Clock");
                }
                if (yellowClockContainer) yellowClockContainer.classList.remove('clock-active');
            }
        }

        /**
         * Starts the interval timer for a specific player's clock.
         * @param {string} player - The player ('orange' or 'yellow') whose clock to start.
         */
        function startClock(player) {
            // Don't start if game is over
            if (gameState.gameOver) return;

            // Stop the other player's clock first (safety measure)
            const otherPlayer = player === PLAYERS.ORANGE ? PLAYERS.YELLOW : PLAYERS.ORANGE;
            stopClock(otherPlayer);

            // Clear existing timer for the target player before starting a new one
            stopClock(player);

            // console.log(`Starting Clock for: ${player}`);
            const tick = () => {
                if (player === PLAYERS.ORANGE) {
                    orangeTime--;
                    updateClockDisplay(PLAYERS.ORANGE, orangeTime);
                    if (orangeTime <= 0) {
                        // console.log("Orange time ran out.");
                        stopClock(PLAYERS.ORANGE); // Stop the clock at 00:00
                        // Requirement: Do nothing else when time runs out
                    }
                } else if (player === PLAYERS.YELLOW) {
                    yellowTime--;
                    updateClockDisplay(PLAYERS.YELLOW, yellowTime);
                    if (yellowTime <= 0) {
                        // console.log("Yellow time ran out.");
                        stopClock(PLAYERS.YELLOW); // Stop the clock at 00:00
                         // Requirement: Do nothing else when time runs out
                    }
                }
            };

            // Initial immediate tick to avoid 1-second delay on start/resume
            tick();
            // Then set the interval
            if (player === PLAYERS.ORANGE) {
                orangeTimerId = setInterval(tick, 1000);
                if(orangeClockContainer) orangeClockContainer.classList.add('clock-active');
            } else if (player === PLAYERS.YELLOW) {
                yellowTimerId = setInterval(tick, 1000);
                if(yellowClockContainer) yellowClockContainer.classList.add('clock-active');
            }
        }

        /**
         * Stops both players' clocks. Used for game end or pausing.
         */
        function pauseAllClocks() {
            stopClock(PLAYERS.ORANGE);
            stopClock(PLAYERS.YELLOW);
            console.log("Paused All Clocks");
        }

        /**
         * Resets clock times to initial values and updates displays. Stops timers.
         */
        function initializeClocks() {
            pauseAllClocks(); // Ensure any running timers are stopped
            orangeTime = INITIAL_TIME_SECONDS;
            yellowTime = INITIAL_TIME_SECONDS;
            updateClockDisplay(PLAYERS.ORANGE, orangeTime);
            updateClockDisplay(PLAYERS.YELLOW, yellowTime);
             if(orangeClockContainer) orangeClockContainer.classList.remove('clock-active');
             if(yellowClockContainer) yellowClockContainer.classList.remove('clock-active');
            console.log("Clocks Initialized");
        }

        /**
         * Stops the clock of the player who just moved, adds increment, updates their display,
         * and starts the opponent's clock. Call this *before* switching gameState.currentPlayer.
         * @param {string} playerWhoMoved - The player who just completed their move.
         */
        function switchClocks(playerWhoMoved) {
            if (gameState.gameOver) return; // Don't switch if game ended

            // 1. Stop the clock for the player who moved
            stopClock(playerWhoMoved);

            // 2. Add increment
            if (playerWhoMoved === PLAYERS.ORANGE) {
                orangeTime += INCREMENT_SECONDS;
                updateClockDisplay(PLAYERS.ORANGE, orangeTime);
            } else if (playerWhoMoved === PLAYERS.YELLOW) {
                yellowTime += INCREMENT_SECONDS;
                updateClockDisplay(PLAYERS.YELLOW, yellowTime);
            }
             console.log(`${playerWhoMoved} clock stopped, increment added.`);

            // 3. Start the opponent's clock
            const opponent = playerWhoMoved === PLAYERS.ORANGE ? PLAYERS.YELLOW : PLAYERS.ORANGE;
            startClock(opponent);
        }

        /**
         * Resumes the clock for the currently active player based on gameState.
         * Used after loading state (undo) or switching game modes.
         */
        function resumeClockForCurrentPlayer() {
             if (gameState.gameOver) {
                 pauseAllClocks();
                 return;
             }
             console.log(`Resuming clock for current player: ${gameState.currentPlayer}`);
             startClock(gameState.currentPlayer);
        }

        /**
         * Parses move notation and generates a human-readable description,
         * including information about captures, declared hungry, and starvation.
         * @param {string} notation - The move notation (e.g., "1g4", "8xa1++", "7xf7x", "6a1xx").
         * @returns {string} A descriptive string explaining the move.
         */
        function generateMoveDescription(notation) {
            if (!notation || notation === '...') return ''; // Handle empty or placeholder notations

            // Regex to parse the notation:
            // Group 1: Rank ([1-8])
            // Group 2: Capture marker ('x', optional, *immediately after rank*)
            // Group 3: Destination ([a-g][1-9])
            // Group 4: Hungry markers ('+', zero or more, optional)
            // Group 5: Starvation markers ('x', zero or more, optional, *at the end*)
            const moveRegex = /^([1-8])(x)?([a-g][1-9])(\+*)(x*)$/;
            const match = notation.match(moveRegex);

            if (!match) {
                console.warn("Could not parse move notation for tooltip:", notation);
                return notation; // Return original notation if parsing fails
            }

            const rank = parseInt(match[1], 10);
            const pieceName = RANK_TO_NAME[rank] || `Rank ${rank}`;
            const wasCapture = match[2] === 'x'; // Capture is the 'x' right after the rank
            const destination = match[3];
            const hungryDeclared = match[4] && match[4].length > 0;
            const hungryCount = hungryDeclared ? match[4].length : 0;
            const starvedCount = match[5] ? match[5].length : 0; // Count trailing 'x's

            let description = `${pieceName} [${rank}]`;

            // Describe the primary action (move or capture)
            if (wasCapture) {
                description += ` captured on ${destination}`;
            } else {
                description += ` moved to ${destination}`;
            }

            // Add hungry declaration info
            if (hungryDeclared) {
                description += `, declaring ${hungryCount} hungry`;
            }

            // Add starvation info
            if (starvedCount > 0) {
                description += ` (${starvedCount} starved)`;
            }

            return description + "."; // Add a period at the end
        }

        // --- Board Creation and Setup ---

        /**
         * Creates the grid of cell elements and appends them to the board wrapper.
         * Assigns IDs, data attributes, classes for terrain, and event listeners.
         */
        function createBoard() { // Added handleFirstInteraction calls
            boardGridWrapper.innerHTML = '';
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const cell = document.createElement('div');
                    const coords = getCoords(r, c);
                    cell.id = getCellElementId(coords);
                    cell.classList.add('cell');
                    cell.dataset.coords = coords;
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    cell.setAttribute('role', 'gridcell');
                    cell.setAttribute('tabindex', '-1');

                    if (WATER_SQUARES.has(coords)) cell.classList.add('water');
                    if (TRAPS.orange.has(coords)) cell.classList.add('trap-yellow');
                    if (TRAPS.yellow.has(coords)) cell.classList.add('trap-orange');
                    if (DENS.orange === coords) cell.classList.add('den-orange');
                    if (DENS.yellow === coords) cell.classList.add('den-yellow');

                    boardGridWrapper.appendChild(cell);

                    cell.addEventListener('dragover', handleDragOver);
                    cell.addEventListener('dragenter', handleDragEnter);
                    cell.addEventListener('dragleave', handleDragLeave);
                    cell.addEventListener('drop', (e) => { handleFirstInteraction(); handleDrop(e); }); // Add interaction check
                    cell.addEventListener('click', (e) => { handleFirstInteraction(); handleCellClick(e); }); // Add interaction check
                    cell.addEventListener('focus', () => focusedCoords = coords);
                }
            }
        }

        /**
         * Creates a DOM element for a game piece.
         * @param {object} pieceData - The piece data ({ player, rank, ... }).
         * @param {string} coords - The algebraic coordinates where the piece is located.
         * @returns {HTMLElement} The created piece div element.
         */
        function createPieceElement(pieceData, coords) { // Added handleFirstInteraction calls
            const pieceElement = document.createElement('div');
            pieceElement.id = getPieceElementId(coords);
            pieceElement.classList.add('piece');
            pieceElement.dataset.rank = pieceData.rank;
            pieceElement.dataset.player = pieceData.player;
            pieceElement.dataset.coords = coords;
            pieceElement.setAttribute('role', 'button');
            pieceElement.setAttribute('aria-label', `${pieceData.player} ${RANK_TO_NAME[pieceData.rank]} at ${coords}`);
            pieceElement.setAttribute('tabindex', '-1');

            const pieceKey = `${pieceData.player === PLAYERS.ORANGE ? 'O' : 'Y'}_${pieceData.rank}`;
            const asset = pieceAssetContainer.querySelector(`[data-piece="${pieceKey}"]`);

            if (asset && asset.tagName === 'IMG') {
                const img = asset.cloneNode(true);
                pieceElement.appendChild(img);
            } else {
                console.warn("Image asset not found for:", pieceKey);
                pieceElement.textContent = `${pieceData.player === PLAYERS.ORANGE ? 'O' : 'Y'}${pieceData.rank}`;
                pieceElement.classList.add(pieceData.player);
            }

            // Add event listeners for interactions
            pieceElement.addEventListener('dragstart', (e) => { handleFirstInteraction(); handleDragStart(e); }); // Add interaction check
            pieceElement.addEventListener('dragend', handleDragEnd);
            pieceElement.addEventListener('touchstart', (e) => { handleFirstInteraction(); handleTouchStart(e); }, { passive: false }); // Add interaction check
            pieceElement.addEventListener('touchmove', handleTouchMove, { passive: false });
            pieceElement.addEventListener('touchend', handleTouchEnd);
            pieceElement.addEventListener('click', (e) => { handleFirstInteraction(); handlePieceClick(e); }); // Add interaction check
            pieceElement.addEventListener('mouseover', handlePieceMouseOver);
            pieceElement.addEventListener('mouseout', handlePieceMouseOut);
            pieceElement.addEventListener('focus', () => focusedCoords = coords);

            pieceElement.addEventListener('drop', handleDrop);
            pieceElement.addEventListener('dragover', handleDragOver);
            pieceElement.addEventListener('dragenter', handleDragEnterPiece);
            pieceElement.addEventListener('dragleave', handleDragLeavePiece);
            const indicatorSpan = document.createElement('span');
            indicatorSpan.classList.add('trap-rank-indicator');
            indicatorSpan.textContent = '(0)';
            pieceElement.appendChild(indicatorSpan);

            return pieceElement;
        }

        /**
         * Checks if the specified player has any move that wins immediately (reaches opponent's den).
         * Logs checks during non-simulation calls.
         * @param {object} boardState - The board state to check.
         * @param {string} player - The player whose winning moves to check.
         * @param {boolean} [isSimulation=false] - Flag to suppress logging. // NEW PARAMETER
         * @returns {object|null} The winning move ({ from, to }) or null if none found.
         */
        function findImmediateWinningMove(boardState, player, isSimulation = false) { // ADD isSimulation
            const opponentDen = player === PLAYERS.ORANGE ? DENS.yellow : DENS.orange;
            // Pass isSimulation flag down
            const moves = getAllValidMoves(boardState, player, isSimulation); // Use simulation flag
            if (!isSimulation) console.log(`[AI Win Check] Checking ${moves.length} moves for immediate win to ${opponentDen}`); // Log start

            for (const move of moves) {
                if (move.to === opponentDen) {
                    const movingPiece = boardState[move.from];
                    const isHungry = movingPiece?.isHungry || false; // Default to false if piece missing (shouldn't happen)

                    // Log the check result ONLY if not simulating
                    if (!isSimulation) {
                         if (isHungry) {
                             console.log(`[AI Win Check] Found potential win ${move.from} -> ${move.to}. DISCARDED (Piece is hungry).`);
                         } else {
                              console.log(`[AI Win Check] Found VALID win ${move.from} -> ${move.to}.`);
                         }
                    }

                    // Return the move ONLY if piece is NOT hungry
                    if (!isHungry) {
                        return move; // Found a valid winning move
                    }
                    // If hungry, continue loop to check other moves (unlikely but possible)
                }
            }
             if (!isSimulation) console.log(`[AI Win Check] No immediate winning move found.`); // Log end if no win found
            return null; // No non-hungry winning move found
        }

        /**
         * Checks if the opponent has any winning moves on their next turn.
         * @param {object} currentBoardState - The current board state.
         * @param {string} currentPlayer - The player whose turn it currently IS.
         * @returns {Array<object>} An array of the opponent's winning moves [{ from, to }, ...]. Empty if none.
         */
        function getOpponentWinningMoves(currentBoardState, currentPlayer) {
            const opponent = currentPlayer === PLAYERS.ORANGE ? PLAYERS.YELLOW : PLAYERS.ORANGE;
            const opponentWinningMoves = [];
            // Simulate opponent's perspective - opponent is 'player', current AI player's den is 'opponentDen'
            const winningDenForOpponent = opponent === PLAYERS.ORANGE ? DENS.yellow : DENS.orange;

            const opponentMoves = getAllValidMoves(currentBoardState, opponent, true); // Simulate check
            for (const move of opponentMoves) {
                if (move.to === winningDenForOpponent) {
                     // Ensure opponent piece isn't hungry
                     if (!currentBoardState[move.from]?.isHungry) {
                        opponentWinningMoves.push(move);
                    }
                }
            }
            return opponentWinningMoves;
        }

        /**
         * Finds all moves the AI can make that prevent *all* of the opponent's immediate winning moves.
         * @param {object} currentGameState - The current game state object.
         * @param {Array<object>} aiMoves - All valid moves the AI can make.
         * @param {Array<object>} opponentWins - The list of opponent's winning moves.
         * @returns {Array<object>} A filtered list of AI moves that counter all threats.
         */
        function findCounterMoves(currentGameState, aiMoves, opponentWins) {
            if (!opponentWins || opponentWins.length === 0) return aiMoves; // No threats to counter

            const counterMoves = [];
            for (const aiMove of aiMoves) {
                // Simulate the AI making this move
                const nextState = simulateMove(currentGameState, aiMove);
                // Check if the opponent *still* has any winning moves in the resulting state
                const opponentWinsAfterAIMove = getOpponentWinningMoves(nextState.board, nextState.currentPlayer); // Check opponent in the *new* state

                if (opponentWinsAfterAIMove.length === 0) {
                    // This AI move successfully prevents all opponent wins
                    counterMoves.push(aiMove);
                }
            }
            return counterMoves;
        }

        /**
         * Clears existing pieces from the board and places new ones based on the current game state.
         * Also applies initial hungry and trap indicator visuals.
         */
        function placePieces() {

            // Remove all existing piece elements from the board
            boardGridWrapper.querySelectorAll('.piece').forEach(p => p.remove());

            // Iterate through the board state and create/place pieces
            for (const coords in gameState.board) {
                if (gameState.board.hasOwnProperty(coords)) {
                    const pieceData = gameState.board[coords];
                    if (!pieceData) {
                        console.warn(`Attempted to place null piece at ${coords}`);
                        continue;
                    }
                    // Create the piece element
                    const pieceElement = createPieceElement(pieceData, coords);
                    // Position it correctly on the grid
                    positionElementOnBoard(pieceElement, coords);
                    // Add it to the board
                    boardGridWrapper.appendChild(pieceElement);
                    // Apply 'hungry' visual if needed
                    updateHungryVisual(coords, pieceData.isHungry || false, pieceElement);
                    // Set initial accessibility (draggable/focusable) - will be refined below
                    // updatePieceAccessibility(pieceElement); // Deferred to end of function

                    // Check and apply trap indicator visual
                    const isPieceOnTrap = isOnTrapSquare(coords);
                    updateTrapIndicatorVisual(coords, isPieceOnTrap, pieceElement);
                }
            }
             // Ensure accessibility is correctly set after all pieces are placed
             updateAllPieceAccessibility();
        }

        /**
         * Calculates and sets the absolute CSS position (left, top percentages) for a piece element
         * within the board grid wrapper, ensuring it's centered within its target cell.
         * Also ensures the piece maintains its aspect ratio.
         * @param {HTMLElement} element - The piece element to position.
         * @param {string} coords - The algebraic coordinates of the target cell.
         */
        function positionElementOnBoard(element, coords) {
             const rc = getRowCol(coords);
             if (!rc) {
                 console.error("Cannot position element, invalid coords:", coords);
                 return;
             }
             const { row, col } = rc;

             // Calculate cell dimensions as percentages of the grid wrapper
             const cellWidthPercent = 100 / COLS; // e.g., 100 / 7 â‰ˆ 14.28%
             const cellHeightPercent = 100 / ROWS; // e.g., 100 / 9 â‰ˆ 11.11%

             // Get the piece's width as a percentage of the wrapper (must match CSS)
             const pieceWidthPercent = parseFloat(element.style.width || '12.07'); // Use CSS value or default

             // Calculate piece height percentage to maintain 1:1 aspect ratio based on actual pixel dimensions
             const wrapperWidth = boardGridWrapper.offsetWidth;
             const wrapperHeight = boardGridWrapper.offsetHeight;
             let pieceHeightPercent = pieceWidthPercent * (wrapperWidth / wrapperHeight); // Initial calculation based on width %

             // If wrapper dimensions are available, refine the height percentage calculation
             if (wrapperHeight > 0 && wrapperWidth > 0) {
                 const pieceWidthPx = wrapperWidth * (pieceWidthPercent / 100);
                 // Calculate the height % needed to make pixel height equal to pixel width
                 pieceHeightPercent = (pieceWidthPx / wrapperHeight) * 100;
                 // Explicitly set height style to ensure consistency if calculated
                 element.style.height = `${pieceHeightPercent}%`;
             } else {
                // Fallback if dimensions aren't ready - rely on aspect-ratio CSS
                element.style.height = 'auto'; // Let CSS aspect-ratio handle height
             }
             // Ensure width is set (might have been auto initially)
             element.style.width = `${pieceWidthPercent}%`;


             // Calculate the top-left corner of the target cell (relative to the wrapper)
             const cellLeftPercent = col * cellWidthPercent;
             const cellTopPercent = row * cellHeightPercent;

             // Calculate the offset needed to center the piece within the cell
             const offsetXPercent = (cellWidthPercent - pieceWidthPercent) / 2;
             const offsetYPercent = (cellHeightPercent - pieceHeightPercent) / 2; // Use the calculated piece height %

             // Calculate the final top-left position for the piece element
             const finalLeftPercent = cellLeftPercent + offsetXPercent;
             const finalTopPercent = cellTopPercent + offsetYPercent;

             // Apply the calculated position
             element.style.left = `${finalLeftPercent}%`;
             element.style.top = `${finalTopPercent}%`;

             // Reset any transform applied during dragging/animations
             element.style.transform = '';
             // Update the element's coordinate data attribute
             element.dataset.coords = coords;
        }


        /**
         * Updates the tabindex, draggable attributes, AND cursor style (via .movable class)
         * of a piece element based on the current game state.
         * Pieces are only interactive (focusable, draggable, hand cursor) for the
         * player whose turn it currently is, regardless of game mode (PvP/PvE).
         * @param {HTMLElement} pieceElement - The piece element to update.
         */
        function updatePieceAccessibility(pieceElement) {
            if (!pieceElement) return;
            const piecePlayer = pieceElement.dataset.player;

            // Determine if the piece should be interactive:
            // It must belong to the current player AND the game must not be over.
            const shouldBeInteractive = !gameState.gameOver && (piecePlayer === gameState.currentPlayer);

            if (shouldBeInteractive) {
                pieceElement.setAttribute('tabindex', '0'); // Allow focus
                pieceElement.draggable = true; // Allow dragging
                pieceElement.classList.add('movable'); // Add class for hand cursor
            } else {
                pieceElement.setAttribute('tabindex', '-1'); // Disallow focus
                pieceElement.draggable = false; // Disallow dragging
                pieceElement.classList.remove('movable'); // Remove class for hand cursor
            }
        }

        /**
         * Updates accessibility attributes for all piece elements on the board.
         * Typically called after a turn change or game state load.
         */
        function updateAllPieceAccessibility() {
            boardGridWrapper.querySelectorAll('.piece').forEach(p => updatePieceAccessibility(p));
        }


        /**
         * Creates an efficient deep copy of the board object.
         * The board object contains piece data mapped by coordinates.
         * Piece data typically consists of primitives (player, rank, isHungry, etc.),
         * so a shallow copy of each piece object is sufficient for a deep board copy.
         *
         * @param {object} board - The board state object to clone (e.g., { 'a1': { player: 'orange', rank: 8, ... }, ... }).
         * @returns {object} A new object representing a deep copy of the board. Returns an empty object if the input is invalid.
         */
        function cloneBoard(board) {
            if (!board || typeof board !== 'object') {
                console.error("cloneBoard: Invalid input board object", board);
                return {};
            }
            const newBoard = {};
            // Iterate over the keys (coordinates) of the board object
            for (const coords in board) {
                // Use hasOwnProperty to ensure it's not a property from the prototype chain
                if (Object.prototype.hasOwnProperty.call(board, coords)) {
                    const pieceData = board[coords];
                    // If there's piece data (not null/undefined), create a shallow copy
                    // Since pieceData contains primitives, this effectively deep copies the board structure
                    if (pieceData) {
                        newBoard[coords] = { ...pieceData }; // Use spread syntax for a shallow copy of the piece object
                    } else {
                        newBoard[coords] = null; // Preserve null entries if any
                    }
                }
            }
            return newBoard;
        }

        /**
         * Creates an efficient deep copy of the essential parts of the game state
         * required for AI simulation purposes (minimax, move simulation).
         * This avoids copying large, unnecessary structures like moveHistory or boardStateHistory.
         * **Includes the Zobrist hash.**
         *
         * @param {object} gameState - The full gameState object, expected to have a zobristHash property.
         * @returns {object} A new object containing deep copies of the essential simulation state
         *                   (board, currentPlayer, gameOver, winner, zobristHash). Returns a default state object if input is invalid.
         * @property {object} board - A deep copy of the game board, created using `cloneBoard`.
         * @property {string} currentPlayer - The player whose turn it is.
         * @property {boolean} gameOver - Whether the game has ended.
         * @property {string|null} winner - The winning player ('orange', 'yellow') or null.
         * @property {bigint} zobristHash - The Zobrist hash of the game state.
         */
        function cloneGameState(gameState) {
            // Add check for zobristHash existence
            if (!gameState || typeof gameState !== 'object' || !gameState.board || !gameState.currentPlayer || typeof gameState.zobristHash !== 'bigint') {
                 console.error("cloneGameState: Invalid input gameState object or missing/invalid zobristHash", gameState);
                 // Return a minimal default state to prevent downstream errors
                 return {
                     board: {},
                     currentPlayer: PLAYERS.ORANGE,
                     gameOver: true,
                     winner: null,
                     zobristHash: 0n // Default hash
                 };
            }
            const newGameState = {
                board: cloneBoard(gameState.board),          // Use efficient board cloning
                currentPlayer: gameState.currentPlayer,      // String - direct copy
                gameOver: gameState.gameOver,              // Boolean - direct copy
                winner: gameState.winner,                  // String/null - direct copy
                zobristHash: gameState.zobristHash         // *** Copy the Zobrist hash ***
            };
            return newGameState;
        }

        /**
         * Initializes the Zobrist keys required for hashing game states.
         * Populates the global `zobristKeys` object with random BigInts for each
         * piece type at each square and a key for the current player's turn.
         * Ensures coordinate maps are ready. Must be called once at game start.
         */
        function initZobrist() {
            initializeCoordMaps(); // Ensure coordinate mapping is ready

            zobristKeys.pieceKeys = []; // [pieceTypeIndex][squareIndex]
            for (let i = 0; i < NUM_PIECE_TYPES; i++) {
                zobristKeys.pieceKeys[i] = [];
                for (let j = 0; j < SQUARES; j++) {
                    zobristKeys.pieceKeys[i][j] = generateRandomBigInt();
                }
            }

            zobristKeys.turnKey = generateRandomBigInt(); // Key to XOR when it's Yellow's turn

            console.log("Zobrist keys initialized.");
            // console.log("Sample Zobrist Key (O_1 @ a9):", zobristKeys.pieceKeys[getPieceTypeIndex(PLAYERS.ORANGE, 1)][getSquareIndex('a9')]);
            // console.log("Turn Key:", zobristKeys.turnKey);
        }

        /**
         * Computes the Zobrist hash for a given board state and current player from scratch.
         * Iterates through all pieces on the board and XORs their corresponding keys.
         * Also XORs the turn key if it's Yellow's turn.
         * @param {object} board - The board state object ({ coords: pieceData }).
         * @param {string} currentPlayer - The player whose turn it is ('orange' or 'yellow').
         * @returns {bigint} The computed Zobrist hash for the state. Returns 0n on error.
         */
        function computeZobristHash(board, currentPlayer) {
            let hash = 0n; // Start with BigInt zero

            if (!board || typeof board !== 'object') {
                console.error("computeZobristHash: Invalid board provided.");
                return hash;
            }
            if (!zobristKeys.pieceKeys || !zobristKeys.turnKey) {
                console.error("computeZobristHash: Zobrist keys not initialized!");
                return hash;
            }

            for (const coords in board) {
                if (Object.prototype.hasOwnProperty.call(board, coords)) {
                    const piece = board[coords];
                    if (piece) {
                        const pieceTypeIndex = getPieceTypeIndex(piece.player, piece.rank);
                        const squareIndex = getSquareIndex(coords);

                        if (pieceTypeIndex !== -1 && squareIndex !== -1) {
                            hash ^= zobristKeys.pieceKeys[pieceTypeIndex][squareIndex];
                        } else {
                            console.warn(`computeZobristHash: Invalid piece type (${pieceTypeIndex}) or square index (${squareIndex}) for piece at ${coords}`);
                        }
                    }
                }
            }

            // XOR with the turn key if it's Yellow's turn
            if (currentPlayer === PLAYERS.YELLOW) {
                hash ^= zobristKeys.turnKey;
            }

            return hash;
        }

        /**
         * Toggles (XORs) the Zobrist key for a specific piece at a given square
         * into or out of the provided hash value.
         * @param {bigint} currentHash - The current hash value.
         * @param {object} piece - The piece data object ({ player, rank }).
         * @param {string} coords - The algebraic coordinates of the square.
         * @returns {bigint} The updated hash value. Returns currentHash if piece/coords invalid.
         */
        function togglePieceKey(currentHash, piece, coords) {
            if (!piece || !coords) {
                console.warn("togglePieceKey: Invalid piece or coords provided", { piece, coords });
                return currentHash;
            }

            const pieceTypeIndex = getPieceTypeIndex(piece.player, piece.rank);
            const squareIndex = getSquareIndex(coords);

            if (pieceTypeIndex === -1 || squareIndex === -1) {
                console.warn(`togglePieceKey: Invalid piece index (${pieceTypeIndex}) or square index (${squareIndex}) at ${coords}`);
                return currentHash;
            }

            if (!zobristKeys.pieceKeys?.[pieceTypeIndex]?.[squareIndex]) {
                console.error(`togglePieceKey: Zobrist key missing for pieceType ${pieceTypeIndex}, square ${squareIndex}`);
                return currentHash; // Avoid XORing with undefined
            }

            return currentHash ^ zobristKeys.pieceKeys[pieceTypeIndex][squareIndex];
        }

        /**
         * Toggles (XORs) the Zobrist turn key into or out of the provided hash value.
         * @param {bigint} currentHash - The current hash value.
         * @returns {bigint} The updated hash value.
         */
        function toggleTurnKey(currentHash) {
             if (!zobristKeys.turnKey) {
                console.error("toggleTurnKey: Zobrist turn key not initialized!");
                return currentHash;
            }
            return currentHash ^ zobristKeys.turnKey;
        }


        // --- Game State Management ---

        /**
         * Creates a deep copy of the current game state (including Zobrist hash)
         * and pushes it onto the history stack for undo functionality.
         */
        function saveGameState() {
            const stateToSave = {
                // Use efficient clone for board, but keep JSON for history arrays etc.
                board: cloneBoard(gameState.board), // Efficient clone for board state is okay here
                currentPlayer: gameState.currentPlayer,
                turnNumber: gameState.turnNumber,
                moveHistory: JSON.parse(JSON.stringify(gameState.moveHistory)),
                // IMPORTANT: boardStateHistory is NOT saved/restored directly.
                // It reflects the state counts *up to* the point of saving.
                // Repetition checks rely on the hash *after* loading.
                // If you NEEDED to restore the exact counts (e.g., for debugging),
                // you would JSON stringify/parse it, but beware BigInt serialization.
                gameOver: gameState.gameOver,
                winner: gameState.winner,
                playerLastMoves: JSON.parse(JSON.stringify(playerLastMoves)),
                orangeTime: orangeTime,
                yellowTime: yellowTime,
                zobristHash: gameState.zobristHash // Save the hash
            };
            gameHistory.push(stateToSave);
            updateUndoButtonState();
            // console.log(`Game state saved (for undo). Hash: ${stateToSave.zobristHash}, History length: ${gameHistory.length}`);
        }

        /**
         * Restores the game state to a previous state from the history,
         * including the Zobrist hash.
         * @param {object} stateToLoad - The game state object retrieved from `gameHistory`.
         */
        function loadGameState(stateToLoad) {
            if (!stateToLoad) return;
            console.log("Loading game state (for Undo/Load)...");

            // --- Stop Clocks Before Loading ---
            pauseAllClocks(); // Stop any active timers

            // Restore state using efficient cloning where possible
            gameState.board = cloneBoard(stateToLoad.board); // Use efficient clone
            gameState.currentPlayer = stateToLoad.currentPlayer;
            gameState.turnNumber = stateToLoad.turnNumber;
            gameState.moveHistory = JSON.parse(JSON.stringify(stateToLoad.moveHistory)); // Keep full copy for log
            // Do NOT restore boardStateHistory - it's derived live
            gameState.boardStateHistory = {}; // Reset history counts on load
            // Recalculate history up to this point IF NEEDED (complex, usually not required for standard repetition)
            // For now, assume repetition check works going forward from loaded state.
            gameState.gameOver = stateToLoad.gameOver;
            gameState.winner = stateToLoad.winner;
            gameState.zobristHash = stateToLoad.zobristHash; // Restore the hash
            playerLastMoves = JSON.parse(JSON.stringify(stateToLoad.playerLastMoves)); // Keep full copy

            // --- Restore Clock Times ---
            orangeTime = stateToLoad.orangeTime ?? INITIAL_TIME_SECONDS; // Use default if missing
            yellowTime = stateToLoad.yellowTime ?? INITIAL_TIME_SECONDS; // Use default if missing
            // --- Update Clock Displays ---
            updateClockDisplay(PLAYERS.ORANGE, orangeTime);
            updateClockDisplay(PLAYERS.YELLOW, yellowTime);

            placePieces();
            rebuildMoveLog();
            highlightLastMoves();
            updateUI();
            logBoardState(true); // Log loaded state without incrementing count
            updateStatus(gameState.gameOver ? `Game Over: ${gameState.winner} wins!` : `${gameState.currentPlayer.toUpperCase()}'s turn.`);

            if (!gameState.gameOver) {
                // Interaction handled AFTER load by calling function (undoMove, initializeGame)
            } else {
                disablePlayerInteraction(); // Disable if game was over
                pauseAllClocks(); // Ensure clocks stay stopped if game over
            }

            updateUndoButtonState();
            clearHighlights(); // General selection highlights
            selectedPieceCoords = null;
            console.log(`Game state loaded. Hash: ${gameState.zobristHash}`);
            // Clocks are NOT started here; the function calling loadGameState (e.g., undoMove) will resume them.
        }

        /**
         * Clears and rebuilds the visual move log based on the `gameState.moveHistory`.
         * Necessary after loading a previous game state.
         */
        function rebuildMoveLog() {
            moveLogElement.innerHTML = ''; // Clear the current log display
            // Add each entry from the history back to the DOM
            gameState.moveHistory.forEach(entry => {
                addLogEntryToDOM(entry.turn, entry.orange, entry.yellow);
            });
            // Scroll to the bottom of the log
            moveLogElement.scrollTop = moveLogElement.scrollHeight;
        }

        /**
         * Handles the Undo button click. Reverts the game state using saved history.
         * Correctly restores the Zobrist hash. Clears the Transposition Table as history changes invalidate it.
         * - In PvP mode: Undoes the single last move made by either player.
         * - In PvE mode: Undoes the last full turn (AI's move + Player's preceding move).
         * Also handles restoring clocks and playing turn sound.
         */
        function undoMove() {
            if (!isPlayerVsPlayerMode && gameState.currentPlayer === PLAYERS.YELLOW && boardGridWrapper.style.pointerEvents === 'none') {
                console.log("Cannot undo while AI is thinking.");
                updateStatus("Cannot undo while AI is thinking.");
                playSound(errorSoundElement, "Error Sound");
                return;
            }

            const minHistoryLength = 1; // Need at least one state to undo to
            if (gameHistory.length < minHistoryLength) {
                console.log("Nothing to undo.");
                updateStatus("Nothing to undo.");
                 playSound(errorSoundElement, "Error Sound");
                return;
            }

            // --- Clear Transposition Table on Undo ---
            transpositionTable.clear();
            console.log("Transposition Table cleared due to undo.");
            // -----------------------------------------

            playSound(undoSoundElement, "Undo Sound"); // Play undo sound using helper

            pauseAllClocks(); // Stop clocks before state change
            let stateToRestore = null;

            const statesToPop = isPlayerVsPlayerMode ? 1 : 2;

            if (gameHistory.length >= statesToPop) {
                // console.log(`Undoing last ${statesToPop} move(s)...`);
                for (let i = 0; i < statesToPop; i++) {
                    stateToRestore = gameHistory.pop(); // The last one popped is the one we load
                }
            } else if (gameHistory.length > 0) {
                console.log("History shorter than expected, undoing only 1 move...");
                stateToRestore = gameHistory.pop();
            }

            if (!stateToRestore) {
                console.error("Undo Error: Could not retrieve a state to restore. History length:", gameHistory.length);
                initializeGame(); // Reset to initial state as a safe fallback
                updateStatus("Undo error or history empty. Game reset.");
                updateUndoButtonState();
                pauseAllClocks();
                return;
            }

            console.log("Loading restored state...");
            loadGameState(stateToRestore); // Loads state, including Zobrist hash

            updateStatus(`Undo successful. ${gameState.currentPlayer.toUpperCase()}'s turn.`);
            updateUndoButtonState();

            if (!gameState.gameOver) {
                enablePlayerInteraction();
                startClock(gameState.currentPlayer);
                playTurnSound();
            } else {
                pauseAllClocks();
                disablePlayerInteraction();
            }
            updateAllPieceAccessibility();

        } // End undoMove

        /**
         * Enables or disables the Undo button based on the game history length, game over state, and AI thinking state.
         */
        function updateUndoButtonState() {
            // Disable if history is empty OR game is over OR if it's AI's turn and interaction is disabled
            undoButton.disabled = gameHistory.length === 0 || gameState.gameOver ||
                                  (gameState.currentPlayer === PLAYERS.YELLOW && boardGridWrapper.style.pointerEvents === 'none');
        }


        // --- Game Initialization ---

        /**
         * Sets up the initial game state, creates the board, places pieces, initializes Zobrist hashing,
         * computes the initial hash, clears the Transposition Table, and updates the UI.
         * Accepts an optional custom board state object to load from.
         * @param {object|null} [customBoard=null] - A board object ({ coords: pieceData }) to load instead of INITIAL_SETUP.
         * @param {boolean} [isLoadingFromFile=false] - Flag to indicate if loading from a state string input.
         */
        function initializeGame(customBoard = null, isLoadingFromFile = false) {
             console.log("Initializing game..." + (customBoard ? " with custom state." : ""));

            // --- Clear Transposition Table ---
            transpositionTable.clear();
            console.log("Transposition Table cleared.");

            // --- Initialize Zobrist Keys FIRST ---
            initZobrist(); // Ensure keys are ready before computing hash

            // --- Initialize Clocks ---
            initializeClocks(); // Reset times and display, stop timers

            gameState = {
                board: customBoard ? cloneBoard(customBoard) : cloneBoard(INITIAL_SETUP), // Clone board efficiently
                currentPlayer: PLAYERS.ORANGE,
                turnNumber: 1,
                moveHistory: [],
                boardStateHistory: {}, // Use Zobrist hash (BigInt) as key
                gameOver: false,
                winner: null,
                zobristHash: 0n, // Initialize Zobrist hash property
            };
            // Reset PvP toggle state only if NOT loading from file
             if (!isLoadingFromFile) {
                isPlayerVsPlayerMode = false;
                const pvpToggle = document.getElementById('pvp-toggle');
                if (pvpToggle) pvpToggle.checked = false;
             } // Keep existing PvP state if loading from file

            if (aiMoveTimeoutId) { clearTimeout(aiMoveTimeoutId); aiMoveTimeoutId = null; }
            gameHistory = [];

            playerLastMoves = {
                [PLAYERS.ORANGE]: { from: null, to: null },
                [PLAYERS.YELLOW]: { from: null, to: null }
            };

            // --- Apply abilities/hungry status ---
            Object.values(gameState.board).forEach(piece => {
                if (piece) {
                    piece.isHungry = false; // Ensure hungry status is reset/initialized
                    const abilities = SPECIAL_ABILITIES[piece.rank];
                    if (abilities) {
                        piece.swims = piece.swims ?? abilities.swims ?? false;
                        piece.attacksElephant = piece.attacksElephant ?? abilities.attacksElephant ?? false;
                        piece.jumpH = piece.jumpH ?? abilities.jumpH ?? false;
                        piece.jumpV = piece.jumpV ?? abilities.jumpV ?? false;
                    } else {
                        piece.swims = false; piece.attacksElephant = false;
                        piece.jumpH = false; piece.jumpV = false;
                    }
                }
            });

            createBoard();
            placePieces();

            // --- Compute Initial Zobrist Hash ---
            gameState.zobristHash = computeZobristHash(gameState.board, gameState.currentPlayer);
            console.log(`Initial Zobrist Hash: ${gameState.zobristHash}`);

            moveLogElement.innerHTML = '';
            boardStateLogElement.textContent = ''; // Clear old string-based display
            updateStatus("Game Ready. Orange to move.");
            updateUI();
            clearHighlights();
            logBoardState(); // Log initial state using the new hash
            enablePlayerInteraction(); // Enable interaction for Orange
            updateUndoButtonState();
            selectedPieceCoords = null;

            clearPlayerLastMoveHighlight(PLAYERS.ORANGE);
            clearPlayerLastMoveHighlight(PLAYERS.YELLOW);
            highlightLastMoves();

             // --- Start Orange's Clock ---
             if (!gameState.gameOver) {
                startClock(PLAYERS.ORANGE); // Start the clock for the first player
             }

            console.log("Game Initialized. Orange starts.");
            playTurnSound();
        }


        // --- Input Handling (Drag & Drop, Touch, Click, Keyboard) ---

        /**
         * Handles the start of a drag operation on a piece.
         * Sets up data transfer, highlights valid moves, and applies dragging styles.
         * @param {DragEvent} e - The drag event object.
         */
        function handleDragStart(e) {
            const pieceDiv = e.target.closest('.piece');
            // Only allow dragging current player's pieces when game is active
            if (!pieceDiv || pieceDiv.dataset.player !== gameState.currentPlayer || gameState.gameOver) {
                e.preventDefault(); // Prevent drag if not allowed
                return;
            }
            isDragging = true;
            draggedPieceElement = pieceDiv; // Store reference to the dragged element
            sourceCoords = draggedPieceElement.dataset.coords; // Store starting position

            // Apply dragging style slightly after drag starts to avoid flicker
            setTimeout(() => {
                if (draggedPieceElement) draggedPieceElement.classList.add('dragging');
             }, 0);

            e.dataTransfer.effectAllowed = 'move'; // Indicate a move operation
            e.dataTransfer.setData('text/plain', sourceCoords); // Store source coords for drop handler

            highlightValidMoves(sourceCoords); // Show potential destinations
            draggedPieceElement.classList.add('selected'); // Visually mark the dragged piece
            selectedPieceCoords = sourceCoords; // Track selection
            console.log(`Drag Start: ${sourceCoords}`);
        }

        /**
         * Handles the end of a drag operation (whether successful drop or cancelled).
         * Cleans up dragging styles and resets related state variables.
         * @param {DragEvent} e - The drag event object.
         */
        function handleDragEnd(e) {
            isDragging = false;
            if (draggedPieceElement) {
                // Remove visual styles associated with dragging/selection
                draggedPieceElement.classList.remove('dragging', 'selected');
            }
            // Reset drag-related variables
            draggedPieceElement = null;
            sourceCoords = null;
            clearHighlights(); // Remove valid move highlights
            // Note: selectedPieceCoords is reset in handleDrop or if move fails
            console.log("Drag End");
        }

        /**
         * Handles the drag over event on potential drop targets (cells, pieces).
         * Prevents the default behavior to allow dropping.
         * @param {DragEvent} e - The drag event object.
         */
        function handleDragOver(e) {
            e.preventDefault(); // Necessary to allow dropping
            e.dataTransfer.dropEffect = 'move'; // Indicate that a move is possible
        }

        /**
         * Helper function to apply hover styling during drag based on the target element.
         * Adds 'valid-move' or 'valid-attack' class to the underlying cell if it's a valid target.
         * @param {HTMLElement} targetElement - The element being dragged over (cell or piece).
         */
        function handleDragEnterAny(targetElement) {
            if (!targetElement || !isDragging) return; // Only act if dragging
            const targetCoords = getCoordsFromElement(targetElement);
            const cellElement = targetCoords ? document.getElementById(getCellElementId(targetCoords)) : null;

            // Check if the underlying cell was highlighted as a potential move/attack
            if (cellElement && cellElement.classList.contains('valid-move-highlight')) {
                // Apply the appropriate hover style based on whether it's an attack or move square
                if (cellElement.classList.contains('valid-attack-highlight')) {
                    cellElement.classList.add('valid-attack'); // Red highlight
                } else {
                    cellElement.classList.add('valid-move'); // Green highlight
                }
            }
        }

        /**
         * Helper function to remove hover styling when the dragged piece leaves an element.
         * @param {HTMLElement} targetElement - The element being left.
         */
        function handleDragLeaveAny(targetElement) {
            if (!targetElement) return;
            const targetCoords = getCoordsFromElement(targetElement);
            const cellElement = targetCoords ? document.getElementById(getCellElementId(targetCoords)) : null;
            // Remove the temporary hover styles
            if (cellElement) {
                cellElement.classList.remove('valid-move', 'valid-attack');
            }
        }

        /**
         * Handles drag enter event specifically for cell elements.
         * @param {DragEvent} e - The drag event object.
         */
        function handleDragEnter(e) {
            e.preventDefault();
            const targetCell = e.target.closest('.cell');
            handleDragEnterAny(targetCell); // Use helper for styling
        }

        /**
         * Handles drag leave event specifically for cell elements.
         * @param {DragEvent} e - The drag event object.
         */
        function handleDragLeave(e) {
            const targetCell = e.target.closest('.cell');
            handleDragLeaveAny(targetCell); // Use helper for styling
        }

        /**
         * Handles drag enter event specifically for piece elements (potential capture targets).
         * @param {DragEvent} e - The drag event object.
         */
        function handleDragEnterPiece(e) {
            e.preventDefault();
            e.stopPropagation(); // Prevent event bubbling to the underlying cell
            const targetPiece = e.target.closest('.piece');
            handleDragEnterAny(targetPiece); // Use helper for styling
        }

        /**
         * Handles drag leave event specifically for piece elements.
         * @param {DragEvent} e - The drag event object.
         */
        function handleDragLeavePiece(e) {
            const targetPiece = e.target.closest('.piece');
            handleDragLeaveAny(targetPiece); // Use helper for styling
        }

        /**
         * Utility function to extract coordinates from a DOM element (cell or piece).
         * @param {HTMLElement} element - The DOM element.
         * @returns {string|null} The algebraic coordinates or null if not found.
         */
        function getCoordsFromElement(element) {
            if (!element) return null;
            // Check if the element itself is a piece or cell
            if (element.classList.contains('piece') || element.classList.contains('cell')) {
                return element.dataset.coords;
            }
            // Check if the element is inside a piece or cell
            const piece = element.closest('.piece');
            if (piece) return piece.dataset.coords;
            const cell = element.closest('.cell');
            if (cell) return cell.dataset.coords;
            return null; // Coordinates not found
        }

/**
         * Handles the drop event when a piece is released over a target.
         * Validates the move and calls performMove if valid. Plays error sound on invalid drop.
         * @param {DragEvent} e - The drop event object.
         */
        function handleDrop(e) { // Added error sound
            e.preventDefault();
            if (!draggedPieceElement) {
                clearHighlights();
                isDragging = false;
                return;
            }

            const targetElement = e.target;
            let targetCoords = null;
            let targetCell = null;

            const droppedOnPiece = targetElement.closest('.piece');
            if (droppedOnPiece && droppedOnPiece !== draggedPieceElement && droppedOnPiece.dataset.player !== gameState.currentPlayer) {
                targetCoords = droppedOnPiece.dataset.coords;
                targetCell = document.getElementById(getCellElementId(targetCoords));
            }
            else {
                targetCell = targetElement.closest('.cell');
                if (targetCell) {
                    targetCoords = targetCell.dataset.coords;
                }
                else if (targetElement === draggedPieceElement) {
                    targetCoords = draggedPieceElement.dataset.coords;
                    targetCell = document.getElementById(getCellElementId(targetCoords));
                }
            }

            const dragSourceCoords = draggedPieceElement.dataset.coords || sourceCoords || e.dataTransfer.getData('text/plain');
            clearHighlights();

            if (!targetCell || !targetCoords) {
                console.log("Drop outside valid target.");
                updateStatus("Invalid drop location.");
                playSound(errorSoundElement, "Error Sound"); // Play error sound
                selectedPieceCoords = null;
                isDragging = false;
                if(draggedPieceElement && dragSourceCoords) positionElementOnBoard(draggedPieceElement, dragSourceCoords);
                return;
            }

            const validationResult = isValidMove(dragSourceCoords, targetCoords, getPieceData(dragSourceCoords));

            if (!validationResult.valid) {
                console.log(`Drop on invalid target: ${targetCoords}. Reason: ${validationResult.reason}`);
                updateStatus(`Invalid move: ${validationResult.reason}`);
                playSound(errorSoundElement, "Error Sound"); // Play error sound
                selectedPieceCoords = null;
                if(draggedPieceElement && dragSourceCoords) positionElementOnBoard(draggedPieceElement, dragSourceCoords);
            } else {
                console.log(`Performing move via drop from ${dragSourceCoords} to ${targetCoords}`);
                performMove(dragSourceCoords, targetCoords);
                selectedPieceCoords = null;
            }
            isDragging = false;
        }


        // --- Touch Handlers ---
        let touchStartX, touchStartY; // Store initial touch coordinates

        /**
         * Handles the start of a touch interaction on a piece.
         * Initiates potential drag, stores start position, highlights moves.
         * @param {TouchEvent} e - The touch event object.
         */
        function handleTouchStart(e) {
            if (gameState.gameOver) return; // Ignore touches if game is over
            const pieceElement = e.target.closest('.piece');
            // Only handle touches on the current player's pieces
            if (!pieceElement || pieceElement.dataset.player !== gameState.currentPlayer) return;

            e.preventDefault(); // Prevent default touch behavior like scrolling
            draggedPieceElement = pieceElement; // Reference the touched piece
            sourceCoords = draggedPieceElement.dataset.coords; // Store start position
            selectedPieceCoords = sourceCoords; // Select the piece

            // Store initial touch coordinates for calculating movement delta
            const touch = e.changedTouches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;

            isDragging = false; // Not dragging yet, could be a tap
            // Temporarily disable smooth transition for direct manipulation
            draggedPieceElement.style.transition = 'none';
            draggedPieceElement.style.zIndex = '100'; // Bring to front

            highlightValidMoves(sourceCoords); // Show valid moves
            draggedPieceElement.classList.add('selected'); // Mark as selected
            console.log(`Touch Start: ${sourceCoords}`);
        }

        /**
         * Handles touch movement while holding a piece.
         * Updates the piece's position visually and detects if it's a drag vs. tap.
         * @param {TouchEvent} e - The touch event object.
         */
        function handleTouchMove(e) {
            if (!draggedPieceElement || !sourceCoords) return; // Only if a piece touch is active
            e.preventDefault(); // Prevent scrolling during piece drag

            const touch = e.changedTouches[0];
            const deltaX = touch.clientX - touchStartX; // Horizontal movement
            const deltaY = touch.clientY - touchStartY; // Vertical movement

            // Define a threshold to distinguish between a tap and a drag
            const touchDragThreshold = 10; // Pixels

            // If not already dragging, check if threshold is exceeded
            if (!isDragging && (Math.abs(deltaX) > touchDragThreshold || Math.abs(deltaY) > touchDragThreshold)) {
                isDragging = true; // It's now officially a drag
                draggedPieceElement.classList.add('dragging'); // Apply dragging style
                console.log("Touch drag initiated");
            }

            // If dragging, update the element's visual position using transform
            if (isDragging) {
                // Get the element currently under the touch point
                const elementUnderTouch = document.elementFromPoint(touch.clientX, touch.clientY);

                // Preserve scaling if already applied (e.g., dragging style)
                const currentTransform = draggedPieceElement.style.transform.match(/scale\(([^)]+)\)/);
                const currentScale = currentTransform ? parseFloat(currentTransform[1]) : 1;
                // Apply translation based on touch movement and maintain scale
                draggedPieceElement.style.transform = `translate(${deltaX}px, ${deltaY}px) scale(${currentScale})`;

                // Update cell highlighting based on where the finger is hovering
                // First, remove hover highlights from all cells
                document.querySelectorAll('.cell.valid-move, .cell.valid-attack').forEach(c => c.classList.remove('valid-move', 'valid-attack'));
                // Then, find the cell under the touch
                const targetCoords = getCoordsFromElement(elementUnderTouch);
                const cellUnderTouch = targetCoords ? document.getElementById(getCellElementId(targetCoords)) : null;
                // If over a valid move cell, apply the appropriate hover highlight
                if (cellUnderTouch && cellUnderTouch.classList.contains('valid-move-highlight')) {
                    if (cellUnderTouch.classList.contains('valid-attack-highlight')) {
                        cellUnderTouch.classList.add('valid-attack'); // Red highlight
                    } else {
                        cellUnderTouch.classList.add('valid-move'); // Green highlight
                    }
                }
            }
        }

        /**
         * Handles the end of a touch interaction (lifting the finger).
         * Determines if it was a tap (treated like click) or a drag (treated like drop).
         * Plays error sound on invalid drop.
         * @param {TouchEvent} e - The touch event object.
         */
        function handleTouchEnd(e) { // Added error sound
            if (!draggedPieceElement || !sourceCoords) return;
            e.preventDefault();

            const wasDragging = isDragging;
            isDragging = false;
            draggedPieceElement.classList.remove('dragging');
            draggedPieceElement.style.zIndex = '10';
            draggedPieceElement.style.transform = '';

            setTimeout(() => {
                if (draggedPieceElement) {
                    draggedPieceElement.style.transition = 'transform 0.3s ease-in-out, box-shadow 0.2s ease, outline 0.2s ease, left 0.3s ease-in-out, top 0.3s ease-in-out';
                }
             }, 0);

             if (!wasDragging) {
                 console.log("TouchEnd: Detected as tap/click. Handled by click listener.");
                  draggedPieceElement = null;
                  sourceCoords = null;
                 return;
             }

            const touch = e.changedTouches[0];
            const elementUnderTouch = document.elementFromPoint(touch.clientX, touch.clientY);
            let targetCoords = null;
            let targetCell = null;

            const droppedOnPiece = elementUnderTouch?.closest('.piece');
            if (droppedOnPiece && droppedOnPiece !== draggedPieceElement && droppedOnPiece.dataset.player !== gameState.currentPlayer) {
                targetCoords = droppedOnPiece.dataset.coords;
                targetCell = document.getElementById(getCellElementId(targetCoords));
            } else {
                targetCell = elementUnderTouch?.closest('.cell');
                if (targetCell) {
                    targetCoords = targetCell.dataset.coords;
                }
            }

            clearHighlights();

            if (targetCell && targetCoords) {
                const validationResult = isValidMove(sourceCoords, targetCoords, getPieceData(sourceCoords));
                if (validationResult.valid) {
                    console.log(`Performing move via touch from ${sourceCoords} to ${targetCoords}`);
                    performMove(sourceCoords, targetCoords);
                    selectedPieceCoords = null;
                } else {
                    console.log("Touch end on invalid target:", validationResult.reason);
                    updateStatus(`Invalid move: ${validationResult.reason}`);
                    playSound(errorSoundElement, "Error Sound"); // Play error sound
                    positionElementOnBoard(draggedPieceElement, sourceCoords);
                    selectedPieceCoords = null;
                }
            } else {
                console.log("Touch end outside valid target");
                playSound(errorSoundElement, "Error Sound"); // Play error sound (dropping outside)
                positionElementOnBoard(draggedPieceElement, sourceCoords);
                selectedPieceCoords = null;
            }

            draggedPieceElement = null;
            sourceCoords = null;
            console.log("Touch End (Drag)");
        }


        // --- Click Handlers ---

        /**
         * Handles clicking on a piece.
         * - Selects/deselects the player's own piece and highlights valid moves.
         * - If a player's piece is already selected, clicking an opponent's piece
         *   directly triggers a move validation and execution attempt (capture).
         * Plays error sound on invalid capture attempt.
         * @param {MouseEvent} e - The click event object.
         */
        function handlePieceClick(e) { // Added error sound
            if (isDragging) {
                console.log("Piece click ignored: Dragging.");
                return;
            }
            if (gameState.gameOver) {
                console.log("Piece click ignored: Game Over.");
                return;
            }

            const pieceElement = e.currentTarget;
            if (!pieceElement || !pieceElement.classList.contains('piece')) {
                 console.warn("handlePieceClick: currentTarget is not a valid piece element.", pieceElement);
                 return;
            }

            const clickedCoords = pieceElement.dataset.coords;
            const clickedPieceData = getPieceData(clickedCoords);

            if (selectedPieceCoords && selectedPieceCoords !== clickedCoords) {
                const selectedPieceData = getPieceData(selectedPieceCoords);

                if (!selectedPieceData) {
                    console.warn(`handlePieceClick: Data for selected piece ${selectedPieceCoords} not found. Deselecting.`);
                    deselectPiece();
                    return;
                }

                if (clickedPieceData && clickedPieceData.player !== selectedPieceData.player) {
                    console.log(`handlePieceClick: Attempting CAPTURE. Selected: ${selectedPieceCoords}, Clicked Opponent: ${clickedCoords}`);

                    const validationResult = isValidMove(selectedPieceCoords, clickedCoords, selectedPieceData);
                    console.log(`handlePieceClick (Capture): Validation Result =`, JSON.parse(JSON.stringify(validationResult)));

                    if (validationResult.valid) {
                        console.log(`--> handlePieceClick (Capture): Validation SUCCESS. Calling performMove(${selectedPieceCoords}, ${clickedCoords})`);
                        performMove(selectedPieceCoords, clickedCoords);
                    } else {
                        console.log(`--> handlePieceClick (Capture): Validation FAILED: ${validationResult.reason}`);
                        flashCell(clickedCoords, 'red', 300);
                        updateStatus(`Invalid move: ${validationResult.reason}`);
                        playSound(errorSoundElement, "Error Sound"); // Play error sound
                    }
                    return;
                }
                else if (clickedPieceData && clickedPieceData.player === selectedPieceData.player) {
                    console.log(`handlePieceClick: Switching selection from ${selectedPieceCoords} to ${clickedCoords}`);
                    selectPiece(clickedCoords);
                    return;
                }
                else {
                     console.log(`handlePieceClick: Clicked on something unexpected (${clickedCoords}) while ${selectedPieceCoords} was selected. Letting cell handler manage.`);
                     return;
                }
            }

            if (clickedPieceData && clickedPieceData.player === gameState.currentPlayer) {
                if (selectedPieceCoords === clickedCoords) {
                    console.log(`handlePieceClick: Deselecting piece ${clickedCoords}`);
                    deselectPiece();
                }
                else {
                    console.log(`handlePieceClick: Selecting piece ${clickedCoords}`);
                    selectPiece(clickedCoords);
                }
            } else if (!selectedPieceCoords) {
                console.log(`handlePieceClick: Clicked opponent piece ${clickedCoords} with no friendly piece selected. Doing nothing.`);
                clearHighlights();
            }

            console.log(`handlePieceClick: Action completed. Selected: ${selectedPieceCoords}`);
        }

        /**
         * Handles clicking on a cell. If a piece is selected, attempts to move it to the clicked cell.
         * Ignored if a drag operation is currently happening or no piece is selected.
         * Plays error sound on invalid move.
         * @param {MouseEvent} e - The click event object.
         */
        function handleCellClick(e) { // Added error sound
            console.log("--- handleCellClick triggered --- Target:", e.target, "CurrentTarget:", e.currentTarget);

            const targetCell = e.currentTarget;

            if (!targetCell || !targetCell.classList.contains('cell') || !targetCell.dataset.coords) {
                console.log("handleCellClick ignored: event.currentTarget is not a valid cell element or missing coords.", targetCell);
                return;
            }
             const targetCoords = targetCell.dataset.coords;
             console.log(`handleCellClick: Target Cell Coords = ${targetCoords}`);

            if (isDragging) {
                console.log("handleCellClick ignored: isDragging is true.");
                return;
            }
            if (gameState.gameOver) {
                console.log("handleCellClick ignored: game is over.");
                return;
            }

            if (!selectedPieceCoords) {
                console.log("handleCellClick ignored: No piece selected (selectedPieceCoords is null/undefined).");
                return;
            }
            console.log(`handleCellClick: Proceeding. Selected piece = ${selectedPieceCoords}`);

            const pieceToMove = getPieceData(selectedPieceCoords);

            if (!pieceToMove) {
                console.warn(`handleCellClick: Selected piece data unexpectedly not found for: ${selectedPieceCoords}. Deselecting.`);
                deselectPiece();
                clearHighlights();
                return;
            }
            console.log(`handleCellClick: Attempting move validation: ${selectedPieceCoords} (${RANK_TO_NAME[pieceToMove.rank]}) -> ${targetCoords}`);

            const validationResult = isValidMove(selectedPieceCoords, targetCoords, pieceToMove);
             console.log(`handleCellClick: Validation Result =`, JSON.parse(JSON.stringify(validationResult)));

            if (validationResult.valid) {
                console.log(`--> handleCellClick: Validation SUCCESS. Calling performMove(${selectedPieceCoords}, ${targetCoords})`);
                performMove(selectedPieceCoords, targetCoords);
            } else {
                console.log(`--> handleCellClick: Validation FAILED: ${validationResult.reason}`);
                flashCell(targetCoords, 'red', 300);
                updateStatus(`Invalid move: ${validationResult.reason}`);
                playSound(errorSoundElement, "Error Sound"); // Play error sound
            }
            console.log("--- /handleCellClick finished ---");
        }

        /**
         * Handles mouse entering a piece element. Shows potential moves if it's the player's piece
         * and no other piece is currently selected or being dragged. (Hover effect)
         * @param {MouseEvent} e - The mouse event object.
         */
        function handlePieceMouseOver(e) {
            const pieceElement = e.target.closest('.piece');
            // Ignore if game over, another piece is selected, dragging, or not a piece
            if (!pieceElement || gameState.gameOver || selectedPieceCoords || isDragging) return;

            const coords = pieceElement.dataset.coords;
            const pieceData = getPieceData(coords);

            // Only highlight moves on hover for the current player's pieces
            if (pieceData && pieceData.player === gameState.currentPlayer) {
                // Highlight moves but don't mark the piece as 'selected' (isSelection = false)
                highlightValidMoves(coords, false);
            }
        }

        /**
         * Handles mouse leaving a piece element. Clears temporary hover highlights
         * if no piece is actively selected or being dragged.
         * @param {MouseEvent} e - The mouse event object.
         */
        function handlePieceMouseOut(e) {
            // If no piece is selected and not dragging, clear any highlights shown on hover
            if (!selectedPieceCoords && !isDragging) {
                clearHighlights();
            }
        }


        // --- Keyboard Handlers ---

         /**
         * Handles keyboard navigation (arrow keys) and actions (Enter/Space, Escape)
         * for moving focus, selecting/deselecting pieces, and making moves.
         * Ignores input if the "Load State" input field is focused.
         * Plays error sound on invalid move attempt.
         * @param {KeyboardEvent} e - The keyboard event object.
         */
        function handleKeyDown(e) { // Added error sound
            if (isLoadStateInputFocused) {
                console.log(`Keydown (${e.key}) ignored: Load state input focused.`);
                return;
            }
            if (gameState.gameOver || (!isPlayerVsPlayerMode && gameState.currentPlayer === PLAYERS.YELLOW)) {
                 console.log(`KeyDown ignored: gameOver=${gameState.gameOver}, isPvP=${isPlayerVsPlayerMode}, currentPlayer=${gameState.currentPlayer}`);
                 return;
            }

            handleFirstInteraction(); // Register interaction

            const { key } = e;
            let newRow, newCol, targetCoords, currentElement;

            if (!focusedCoords) {
                const firstPiece = boardGridWrapper.querySelector(`.piece[data-player="${gameState.currentPlayer}"][tabindex="0"]`);
                if (firstPiece) {
                    focusedCoords = firstPiece.dataset.coords;
                    firstPiece.focus();
                } else {
                    boardElement.focus();
                    focusedCoords = getCoords(Math.floor(ROWS/2), Math.floor(COLS/2)) || 'd5';
                    focusOn(focusedCoords);
                }
                if (!focusedCoords) return;
            }

            const currentRC = getRowCol(focusedCoords);
            if (!currentRC) {
                console.warn("Keyboard nav: Invalid focusedCoords", focusedCoords);
                const firstPiece = boardGridWrapper.querySelector(`.piece[data-player="${gameState.currentPlayer}"][tabindex="0"]`);
                if (firstPiece) {
                    focusedCoords = firstPiece.dataset.coords;
                    firstPiece.focus();
                }
                return;
            }

            switch (key) {
                case 'ArrowUp': newRow = currentRC.row - 1; newCol = currentRC.col; break;
                case 'ArrowDown': newRow = currentRC.row + 1; newCol = currentRC.col; break;
                case 'ArrowLeft': newRow = currentRC.row; newCol = currentRC.col - 1; break;
                case 'ArrowRight': newRow = currentRC.row; newCol = currentRC.col + 1; break;
                case 'Enter':
                case ' ':
                    e.preventDefault();
                    currentElement = document.getElementById(getPieceElementId(focusedCoords)) || document.getElementById(getCellElementId(focusedCoords));
                    if (currentElement?.classList.contains('piece')) {
                        const pieceData = getPieceData(focusedCoords);
                        if (pieceData?.player === gameState.currentPlayer) {
                            if (selectedPieceCoords === focusedCoords) deselectPiece();
                            else selectPiece(focusedCoords);
                        } else {
                             playSound(errorSoundElement, "Error Sound"); // Cannot select opponent piece
                        }
                    } else if (currentElement?.classList.contains('cell') && selectedPieceCoords) {
                        const pieceToMove = getPieceData(selectedPieceCoords);
                        if (pieceToMove) {
                            const validationResult = isValidMove(selectedPieceCoords, focusedCoords, pieceToMove);
                            if (validationResult.valid) {
                                performMove(selectedPieceCoords, focusedCoords);
                            } else {
                                flashCell(focusedCoords, 'red', 300);
                                updateStatus(`Invalid move: ${validationResult.reason}`);
                                playSound(errorSoundElement, "Error Sound"); // Play error sound
                            }
                        }
                    } else if (currentElement?.classList.contains('cell') && !selectedPieceCoords) {
                         playSound(errorSoundElement, "Error Sound"); // Clicked cell with nothing selected
                    }
                    return;
                case 'Escape':
                    e.preventDefault();
                    if (selectedPieceCoords) {
                        deselectPiece();
                        clearHighlights();
                    }
                    return;
                default:
                    return;
            }

            targetCoords = getCoords(newRow, newCol);
            if (targetCoords) {
                e.preventDefault();
                focusOn(targetCoords);
            }
        }

        /**
         * Programmatically sets focus on a specific cell or piece element.
         * @param {string} coords - The algebraic coordinates of the target element.
         */
        function focusOn(coords) {
            if (!coords) return;
            // Find the target element (piece first, then cell)
            let targetElement = document.getElementById(getPieceElementId(coords)) || document.getElementById(getCellElementId(coords));
            if (targetElement) {
                targetElement.focus(); // Set browser focus
                // focusedCoords is updated by the 'focus' event listener on cells/pieces
            }
        }


        // --- Selection and Interaction State ---

        /**
         * Selects a piece at the given coordinates.
         * Updates the selectedPieceCoords state, applies visual selection style,
         * highlights valid moves, and sets focus.
         * @param {string} coords - The algebraic coordinates of the piece to select.
         */
        function selectPiece(coords) {
            deselectPiece(); // Ensure only one piece is selected at a time
            const pieceElement = document.getElementById(getPieceElementId(coords));
            // Only select if it's the current player's piece
            if (pieceElement?.dataset.player === gameState.currentPlayer) {
                selectedPieceCoords = coords; // Update state
                pieceElement.classList.add('selected'); // Apply visual style
                highlightValidMoves(coords); // Show valid moves for this piece
                focusOn(coords); // Move focus to the selected piece
                console.log(`Selected piece at ${coords}`);
            }
        }

        /**
         * Deselects the currently selected piece.
         * Clears the selectedPieceCoords state, removes visual selection style,
         * and clears move highlights.
         */
        function deselectPiece() {
            if (selectedPieceCoords) {
                const pieceElement = document.getElementById(getPieceElementId(selectedPieceCoords));
                if (pieceElement) {
                    pieceElement.classList.remove('selected'); // Remove visual style
                }
                console.log(`Deselected piece at ${selectedPieceCoords}`);
                selectedPieceCoords = null; // Clear state
                clearHighlights(); // Remove move highlights
            }
        }

        /**
         * Enables user interaction with the board (dragging, clicking, keyboard).
         * Sets pointer-events, adds keydown listener, and updates piece accessibility.
         */
        function enablePlayerInteraction() {
            boardGridWrapper.style.pointerEvents = 'auto'; // Allow clicks/drags on the grid
            document.addEventListener('keydown', handleKeyDown); // Enable keyboard controls
            updateAllPieceAccessibility(); // Make current player's pieces draggable/focusable
            console.log("Player interaction enabled.");
        }

        /**
         * Disables user interaction with the board.
         * Used during AI's turn or when the game is over.
         */
        function disablePlayerInteraction() {
            boardGridWrapper.style.pointerEvents = 'none'; // Prevent clicks/drags on the grid
            document.removeEventListener('keydown', handleKeyDown); // Disable keyboard controls
            updateAllPieceAccessibility(); // Make all pieces non-interactive
            console.log("Player interaction disabled.");
        }


        // --- Move Logic & Validation ---

        /**
         * Executes a validated move, updating the game state, Zobrist hash, moving the piece element,
         * handling captures, checking for win/loss conditions, managing hungry/starve rules (via checkAndApplyStarvation),
         * logging the move, checking for repetition/stalemate, switching the player,
         * potentially triggering the AI, and managing last move highlights and clocks.
         * Passes the correct turn number to logMove.
         * @param {string} fromCoords - The starting coordinates of the move.
         * @param {string} toCoords - The ending coordinates of the move.
         */
        function performMove(fromCoords, toCoords) {
            const piece = getPieceData(fromCoords); // Piece data *before* move
            if (!piece || piece.player !== gameState.currentPlayer || gameState.gameOver) {
                console.error("Invalid move attempt condition in performMove.");
                updateStatus("Cannot move now.");
                return;
            }
            const playerWhoMoved = gameState.currentPlayer;
            const opponent = playerWhoMoved === PLAYERS.ORANGE ? PLAYERS.YELLOW : PLAYERS.ORANGE;
            const turnNumberForLog = gameState.turnNumber; // *** CAPTURE turn number BEFORE potential increment ***

            clearPlayerLastMoveHighlight(playerWhoMoved);

            const validationResult = isValidMove(fromCoords, toCoords, { ...piece });
            if (!validationResult.valid) {
                console.log(`Invalid move attempt in performMove: ${validationResult.reason}`);
                updateStatus(`Invalid move: ${validationResult.reason}`);
                flashCell(toCoords, 'red');
                playSound(errorSoundElement, "Error Sound");
                highlightLastMoves();
                return;
            }

            saveGameState();
            clearHighlights();
            deselectPiece();

            const targetPiece = getPieceData(toCoords);
            const isAttack = !!targetPiece;
            let notation = `${RANK_TO_CODE[piece.rank]}`;
            let statusAction = "";

            const starvedPiecesCoords = checkAndApplyStarvation(fromCoords, isAttack);
            let nextHash = gameState.zobristHash;

            if (starvedPiecesCoords.length > 0) {
                playSound(captureSoundElement, "Capture Sound (Starvation)");
                statusAction += ` (${starvedPiecesCoords.length} animal${starvedPiecesCoords.length > 1 ? 's' : ''} starved)`;
            }

            nextHash = togglePieceKey(nextHash, piece, fromCoords);
            nextHash = togglePieceKey(nextHash, piece, toCoords);
            if (isAttack && targetPiece) {
                nextHash = togglePieceKey(nextHash, targetPiece, toCoords);
                notation += 'x';
                if (!statusAction.includes("captures")) {
                    statusAction = ` captures ${RANK_TO_NAME[targetPiece.rank]} at ${toCoords}`;
                }
                playSound(captureSoundElement, "Capture Sound");
                const capturedElement = document.getElementById(getPieceElementId(toCoords));
                if (capturedElement) {
                    const capturedIndicator = capturedElement.querySelector('.trap-rank-indicator.visible');
                    if (capturedIndicator) capturedIndicator.classList.remove('visible');
                    capturedElement.classList.add('captured');
                    setTimeout(() => { capturedElement.remove(); }, 400);
                }
            }
            nextHash = toggleTurnKey(nextHash);

            const pieceDataToMove = { ...gameState.board[fromCoords] };
            if (!pieceDataToMove && !starvedPiecesCoords.includes(fromCoords)) { // Check if piece data missing unexpectedly
                 console.error(`CRITICAL: Piece data missing at ${fromCoords} after starvation check.`);
                 // Attempt recovery or handle error state appropriately
            }
            if (pieceDataToMove) { // Only place if data exists
                gameState.board[toCoords] = pieceDataToMove;
            }
            delete gameState.board[fromCoords];


            const pieceElement = document.getElementById(getPieceElementId(fromCoords));
            if (pieceElement) {
                pieceElement.id = getPieceElementId(toCoords);
                pieceElement.setAttribute('aria-label', `${playerWhoMoved} ${RANK_TO_NAME[piece.rank]} at ${toCoords}`);
                positionElementOnBoard(pieceElement, toCoords);
                const movedPieceData = gameState.board[toCoords];
                if (movedPieceData) {
                    const isNowOnTrap = isOnTrapSquare(toCoords);
                    updateTrapIndicatorVisual(toCoords, isNowOnTrap, pieceElement);
                    movedPieceData.isHungry = false;
                    updateHungryVisual(toCoords, false, pieceElement);
                } else {
                     console.warn(`performMove: Piece data missing at destination ${toCoords}, cannot update visuals.`);
                     updateTrapIndicatorVisual(toCoords, false, pieceElement);
                     updateHungryVisual(toCoords, false, pieceElement);
                }
            } else if (!starvedPiecesCoords.includes(fromCoords)) {
                console.error(`!!! Piece element not found for move ${fromCoords} -> ${toCoords} and it wasn't starved! Re-placing all pieces.`);
                placePieces();
            }

            notation += toCoords;

            const { hungryCount, hungryPiecesMap } = declareHungryAnimals(opponent);
            Object.keys(gameState.board).forEach(coords => {
                const p = gameState.board[coords];
                if (p?.player === opponent) {
                    const isNowHungry = !!hungryPiecesMap[coords];
                    p.isHungry = isNowHungry;
                    updateHungryVisual(coords, isNowHungry);
                }
            });
            if (hungryCount > 0) {
                notation += '+'.repeat(hungryCount);
                playSound(hungryWarningSoundElement, "Hungry Warning Sound");
            }
            if (starvedPiecesCoords.length > 0) {
                notation += 'x'.repeat(starvedPiecesCoords.length);
            }

            gameState.zobristHash = nextHash;
            gameState.currentPlayer = opponent;
            // *** INCREMENT turnNumber AFTER logging and AFTER setting next player ***
            if (playerWhoMoved === PLAYERS.YELLOW) {
                gameState.turnNumber++;
            }

            const opponentDen = playerWhoMoved === PLAYERS.ORANGE ? DENS.yellow : DENS.orange;
            if (toCoords === opponentDen) {
                gameState.winner = playerWhoMoved; gameState.gameOver = true;
                updateStatus(`${playerWhoMoved.toUpperCase()} wins by reaching the den!${statusAction}`);
                logMove(notation, playerWhoMoved, turnNumberForLog); // *** Pass correct turn number ***
                logBoardState(); updateUI(); disablePlayerInteraction(); pauseAllClocks(); updateUndoButtonState();
                playSound(winSoundElement, "Win Sound"); return;
            }
            let opponentPieceCount = 0;
            for (const coords in gameState.board) { if (gameState.board[coords]?.player === opponent) { opponentPieceCount++; break; } }
            if (opponentPieceCount === 0) {
                gameState.winner = playerWhoMoved; gameState.gameOver = true;
                updateStatus(`${playerWhoMoved.toUpperCase()} wins by eliminating all opponent pieces!${statusAction}`);
                logMove(notation, playerWhoMoved, turnNumberForLog); // *** Pass correct turn number ***
                logBoardState(); updateUI(); disablePlayerInteraction(); pauseAllClocks(); updateUndoButtonState();
                playSound(winSoundElement, "Win Sound"); return;
            }
            if (checkForStalemate(opponent)) {
                gameState.winner = playerWhoMoved; gameState.gameOver = true;
                updateStatus(`Stalemate! ${opponent.toUpperCase()} has no valid moves. ${playerWhoMoved.toUpperCase()} wins!`);
                logMove(notation, playerWhoMoved, turnNumberForLog); // *** Pass correct turn number ***
                logBoardState(); updateUI(); disablePlayerInteraction(); pauseAllClocks(); updateUndoButtonState();
                playSound(winSoundElement, "Win Sound"); return;
            }

            // --- Log Move & Board State ---
            logMove(notation, playerWhoMoved, turnNumberForLog); // *** Pass correct turn number ***
            logBoardState();

            playerLastMoves[playerWhoMoved] = { from: fromCoords, to: toCoords };
            highlightLastMoves();
            switchClocks(playerWhoMoved);

            updateStatus(`${gameState.currentPlayer.toUpperCase()}'s turn.${statusAction}`);
            updateUI();
            updateUndoButtonState();

            if (!gameState.gameOver) { playTurnSound(); }

            if (!isPlayerVsPlayerMode && gameState.currentPlayer === PLAYERS.YELLOW && !gameState.gameOver) {
                disablePlayerInteraction(); undoButton.disabled = true;
                if (aiMoveTimeoutId) clearTimeout(aiMoveTimeoutId);
                aiMoveTimeoutId = setTimeout(triggerAIMove, 500);
            } else if (!gameState.gameOver) {
                enablePlayerInteraction();
            } else {
                 pauseAllClocks();
            }
        }

        /**
         * Checks if the specified player has any valid moves available in the current board state.
         * @param {string} playerToCheck - The player ('orange' or 'yellow') to check for stalemate.
         * @returns {boolean} True if the player has no valid moves (stalemate), false otherwise.
         */
        function checkForStalemate(playerToCheck) {
            // Iterate through all pieces belonging to the player
            for (const fromCoords in gameState.board) {
                const piece = gameState.board[fromCoords];
                if (piece?.player === playerToCheck) {
                    // Get all potential destination squares for this piece
                    const destinations = getPotentialMoveDestinations(fromCoords, piece);
                    // Check if *any* of these potential destinations result in a valid move
                    for (const toCoords of destinations) {
                        if (isValidMove(fromCoords, toCoords, piece).valid) {
                            // Found at least one valid move, so it's not stalemate
                            console.log(`Stalemate check: Found valid move for ${playerToCheck}: ${fromCoords} to ${toCoords}`);
                            return false;
                        }
                    }
                }
            }
            // If the loop completes without finding any valid moves, it's stalemate
            console.log(`Stalemate check: No valid moves found for ${playerToCheck}.`);
            return true;
        }

        /**
         * Determines if a move from `fromCoords` to `toCoords` is legal according to game rules.
         * Checks terrain, piece abilities, capture rules (including traps), jump paths,
         * AND the repetition rule for the leading player using Zobrist Hashing.
         * Returns additional reasonCode for specific failure types.
         * @param {string} fromCoords - Starting algebraic coordinates.
         * @param {string} toCoords - Ending algebraic coordinates.
         * @param {object} piece - The data object of the piece attempting the move (the ATTACKER).
         * @param {object} [currentBoardState=gameState.board] - Optional board state for simulation. Defaults to the main game state board.
         * @param {boolean} [isSimulation=false] - Flag to suppress detailed logging during AI simulation.
         * @returns {{valid: boolean, reason: string, reasonCode?: string}} An object indicating validity and reason.
         */
        function isValidMove(fromCoords, toCoords, piece, currentBoardState = gameState.board, isSimulation = false) {
            // --- Basic Checks ---
            if (!piece) return { valid: false, reason: "No piece selected." };
            if (fromCoords === toCoords) return { valid: false, reason: "Cannot move to the same square." };
            const fromRC = getRowCol(fromCoords);
            const toRC = getRowCol(toCoords);
            if (!fromRC || !toRC) return { valid: false, reason: "Invalid coordinates." };
            const targetPieceData = currentBoardState[toCoords] || null; // Piece at destination
            const pieceRank = piece.rank;
            const pieceAbilities = SPECIAL_ABILITIES[pieceRank] || {};

            // --- Rule Checks ---
            if (targetPieceData?.player === piece.player) return { valid: false, reason: "Cannot capture your own piece." };
            const ownDen = piece.player === PLAYERS.ORANGE ? DENS.orange : DENS.yellow;
            if (toCoords === ownDen) return { valid: false, reason: "Cannot enter your own den." };
            if (piece.isHungry) {
                const opponentDen = piece.player === PLAYERS.ORANGE ? DENS.yellow : DENS.orange;
                if (toCoords === opponentDen) return { valid: false, reason: "Hungry animal cannot enter the den to win." };
            }

            // --- Movement Type Checks (Water, Jump) ---
            const isOrthogonal = (Math.abs(fromRC.row - toRC.row) === 1 && fromRC.col === toRC.col) || (Math.abs(fromRC.col - toRC.col) === 1 && fromRC.row === toRC.row);
            const isMovingToWater = WATER_SQUARES.has(toCoords);
            const isMovingFromWater = WATER_SQUARES.has(fromCoords);
            if (isMovingToWater && !pieceAbilities.swims) return { valid: false, reason: "This animal cannot enter water." };
            if (isMovingFromWater && isMovingToWater && targetPieceData && !pieceAbilities.swims) return { valid: false, reason: "Cannot attack into water (unless Rat/Dog)." };
            if (pieceRank === 1 && targetPieceData?.rank === 8 && isMovingFromWater) return { valid: false, reason: "Rat cannot attack Elephant from water."};
            if (isMovingFromWater && !isMovingToWater && targetPieceData && !pieceAbilities.swims) return { valid: false, reason: "Only Rat/Dog can attack land from water." };
            let isJumpValid = false;
             if (!isMovingFromWater && !isMovingToWater) {
                 const isVerticalJump = toRC.col === fromRC.col && Math.abs(toRC.row - fromRC.row) === 4 && (fromRC.col === 1 || fromRC.col === 2 || fromRC.col === 4 || fromRC.col === 5);
                 const isHorizontalJump = toRC.row === fromRC.row && Math.abs(toRC.col - fromRC.col) === 3 && (fromRC.row >= 3 && fromRC.row <= 5);
                 if (isVerticalJump || isHorizontalJump) {
                     if ((isVerticalJump && !pieceAbilities.jumpV) || (isHorizontalJump && !pieceAbilities.jumpH)) return { valid: false, reason: "This animal cannot jump that way." };
                     if (!checkJumpPathClear(fromRC, toRC, piece.player, currentBoardState, isSimulation)) return { valid: false, reason: "Jump path blocked by opponent in water." };
                     isJumpValid = true;
                 }
             }
            if (!isOrthogonal && !isJumpValid) return { valid: false, reason: "Invalid move distance or type (not 1 square orthogonal or valid jump)." };

            // --- Capture Rules ---
            if (targetPieceData) {
                let attackerRank = pieceRank;
                let defenderOriginalRank = targetPieceData.rank;
                let defenderEffectiveRank = defenderOriginalRank;
                let defenderIsTrapped = false;
                if (isOnTrapSquare(toCoords)) {
                    defenderEffectiveRank = 0;
                    defenderIsTrapped = true;
                    if (!isSimulation) { /* console.log(...) */ }
                }
                const isRatAttackElephant = pieceRank === 1 && defenderOriginalRank === 8;
                if (isRatAttackElephant && !isMovingFromWater) { /* Valid special case */ }
                else if (attackerRank < defenderEffectiveRank) {
                    const reasonMsg = `Cannot attack higher-ranked animal (${attackerRank} vs ${defenderOriginalRank}${defenderIsTrapped ? ' [Trap->0]' : ''}).`;
                    return { valid: false, reason: reasonMsg, reasonCode: 'RANK_TOO_LOW' };
                }
            }

            // --- START: Repetition Rule Check using Zobrist Hash ---
            const restrictedPlayer = getRestrictedPlayer(currentBoardState);

            // Check only if the moving player is the one restricted
            if (piece.player === restrictedPlayer) {
                // Calculate the *hypothetical* hash of the state *after* this move
                let potentialNextHash = gameState.zobristHash; // Start with current hash

                // Simulate XOR operations for the move:
                // 1. XOR out moving piece from origin
                potentialNextHash = togglePieceKey(potentialNextHash, piece, fromCoords);
                // 2. XOR in moving piece at destination
                potentialNextHash = togglePieceKey(potentialNextHash, piece, toCoords);
                // 3. XOR out captured piece if any
                if (targetPieceData) {
                    potentialNextHash = togglePieceKey(potentialNextHash, targetPieceData, toCoords);
                }
                // 4. XOR the turn key (player will change)
                potentialNextHash = toggleTurnKey(potentialNextHash);

                // Check the count for this potential hash in the history
                const repetitionCount = gameState.boardStateHistory[potentialNextHash.toString()] || 0;

                // If this state has occurred 2 or more times already, this move is invalid
                if (repetitionCount >= 2) {
                     if (!isSimulation) {
                        console.log(`isValidMove: Repetition rule block for ${piece.player}. Move ${fromCoords}->${toCoords} leads to hash ${potentialNextHash} (Count: ${repetitionCount + 1})`);
                     }
                    return { valid: false, reason: "Move creates 3rd repetition.", reasonCode: 'REPETITION_RULE' };
                }
            }
            // --- END: Repetition Rule Check ---

            return { valid: true }; // If all checks passed
        }


        /**
         * Checks if the path for a Lion/Tiger jump over water is clear of opponent swimming pieces (Rat/Dog).
         * @param {{row: number, col: number}} fromRC - Start row/col indices.
         * @param {{row: number, col: number}} toRC - End row/col indices.
         * @param {string} attackerPlayer - The player making the jump ('orange' or 'yellow').
         * @param {object} currentBoardState - The board state to check against.
         * @param {boolean} [isSimulation=false] - Flag to suppress detailed logging. // NEW PARAMETER
         * @returns {boolean} True if the path is clear, false otherwise.
         */
        function checkJumpPathClear(fromRC, toRC, attackerPlayer, currentBoardState, isSimulation = false) { // ADD isSimulation PARAMETER & currentBoardState
            const opponent = attackerPlayer === PLAYERS.ORANGE ? PLAYERS.YELLOW : PLAYERS.ORANGE;
            const startRow = Math.min(fromRC.row, toRC.row);
            const endRow = Math.max(fromRC.row, toRC.row);
            const startCol = Math.min(fromRC.col, toRC.col);
            const endCol = Math.max(fromRC.col, toRC.col);

            // Vertical Jump Check (column is the same)
            if (fromRC.col === toRC.col) {
                for (let r = startRow + 1; r < endRow; r++) {
                    const coords = getCoords(r, fromRC.col);
                    if (!WATER_SQUARES.has(coords)) {
                         // --- LOGGING WRAPPED ---
                         if (!isSimulation) console.warn(`Jump path check anomaly: ${coords} in vertical jump path is not water.`);
                         // --- END WRAP ---
                        return false;
                    }
                    // Use the provided board state
                    const blockingPiece = currentBoardState[coords]; // Check the simulated board
                    if (blockingPiece?.player === opponent) {
                         // --- LOGGING WRAPPED ---
                         if (!isSimulation) console.log(`Jump blocked by opponent ${RANK_TO_NAME[blockingPiece.rank]} at ${coords}`);
                         // --- END WRAP ---
                        return false;
                    }
                }
            }
            // Horizontal Jump Check (row is the same)
            else if (fromRC.row === toRC.row) {
                for (let c = startCol + 1; c < endCol; c++) {
                    const coords = getCoords(fromRC.row, c);
                    if (!WATER_SQUARES.has(coords)) {
                         // --- LOGGING WRAPPED ---
                         if (!isSimulation) console.warn(`Jump path check anomaly: ${coords} in horizontal jump path is not water.`);
                         // --- END WRAP ---
                        return false;
                    }
                    const blockingPiece = currentBoardState[coords]; // Check the simulated board
                    if (blockingPiece?.player === opponent) {
                         // --- LOGGING WRAPPED ---
                         if (!isSimulation) console.log(`Jump blocked by opponent ${RANK_TO_NAME[blockingPiece.rank]} at ${coords}`);
                         // --- END WRAP ---
                        return false;
                    }
                }
            } else {
                 // --- LOGGING WRAPPED ---
                 if (!isSimulation) console.error("checkJumpPathClear called with non-orthogonal jump coordinates.");
                 // --- END WRAP ---
                return false;
            }

            return true;
        }


        // --- Hungry/Starve Logic ---

         /**
         * Identifies all pieces for the specified player that are currently "hungry"
         * (i.e., have a valid capturing move available against an opponent piece).
         * Considers original ranks for triggering hunger, even if the target is trapped.
         * @param {string} playerToDeclareFor - The player ('orange' or 'yellow') whose pieces should be checked.
         * @param {object} [currentBoardState=gameState.board] - The board state to check against. // NEW PARAMETER
         * @param {boolean} [isSimulation=false] - Flag to suppress detailed logging. // NEW PARAMETER
         * @returns {{hungryCount: number, hungryPiecesMap: object}} An object containing the count of hungry pieces
         *          and a map `{ coords: true }` for each hungry piece.
         */
        function declareHungryAnimals(playerToDeclareFor, currentBoardState = gameState.board, isSimulation = false) { // ADD isSimulation PARAMETER & currentBoardState
            let hungryCount = 0;
            const hungryPiecesMap = {};
            const opponent = playerToDeclareFor === PLAYERS.ORANGE ? PLAYERS.YELLOW : PLAYERS.ORANGE;

            for (const coords in currentBoardState) { // Iterate over the passed board state
                const piece = currentBoardState[coords];
                if (piece?.player === playerToDeclareFor) {
                    const destinations = getPotentialMoveDestinations(coords, piece);
                    let pieceDeclaredHungry = false;

                    for (const targetCoords of destinations) {
                         if (pieceDeclaredHungry) break;

                        const targetPiece = currentBoardState[targetCoords]; // Check the simulated board

                        if (targetPiece?.player === opponent) {
                            // Pass isSimulation down to isValidMove
                            const validationResult = isValidMove(coords, targetCoords, piece, currentBoardState, isSimulation);

                            if (validationResult.valid) {
                                // --- LOGGING WRAPPED ---
                                if (!isSimulation) {
                                    console.log(`DeclareHungry: ${piece.player} ${RANK_TO_NAME[piece.rank]}@${coords} is hungry (can capture ${targetPiece.player} ${RANK_TO_NAME[targetPiece.rank]}@${targetCoords} - trap included).`);
                                }
                                // --- END WRAP ---
                                hungryPiecesMap[coords] = true;
                                hungryCount++;
                                pieceDeclaredHungry = true;
                            } else if (validationResult.reasonCode === 'RANK_TOO_LOW') {
                                // --- LOGGING WRAPPED ---
                                if (!isSimulation) {
                                    console.log(`DeclareHungry: ${piece.player} ${RANK_TO_NAME[piece.rank]}@${coords} vs ${targetPiece.player} ${RANK_TO_NAME[targetPiece.rank]}@${targetCoords} - Failed isValidMove due to rank. Checking original ranks...`);
                                }
                                // --- END WRAP ---

                                const attackerRank = piece.rank;
                                const defenderOriginalRank = targetPiece.rank;
                                let canCaptureIgnoringTrap = false;
                                const isRatVsElephant = attackerRank === 1 && defenderOriginalRank === 8;
                                const isMovingFromWater = WATER_SQUARES.has(coords);

                                if (isRatVsElephant && !isMovingFromWater) {
                                    canCaptureIgnoringTrap = true;
                                } else if (attackerRank >= defenderOriginalRank) {
                                    if (!(attackerRank === 8 && defenderOriginalRank === 1)) {
                                        canCaptureIgnoringTrap = true;
                                    }
                                }

                                if (canCaptureIgnoringTrap) {
                                    // --- LOGGING WRAPPED ---
                                    if (!isSimulation) {
                                        console.log(`DeclareHungry: ---> YES, ${piece.player} ${RANK_TO_NAME[piece.rank]}@${coords} becomes hungry (can capture ${targetPiece.player} ${RANK_TO_NAME[targetPiece.rank]}@${targetCoords} based on ORIGINAL ranks).`);
                                    }
                                    // --- END WRAP ---
                                    hungryPiecesMap[coords] = true;
                                    hungryCount++;
                                    pieceDeclaredHungry = true;
                                } else {
                                    // --- LOGGING WRAPPED ---
                                    if (!isSimulation) {
                                         console.log(`DeclareHungry: ---> NO, rank check failed even with original ranks.`);
                                    }
                                    // --- END WRAP ---
                                }
                            }
                        }
                    }
                }
            }

            // --- LOGGING WRAPPED ---
            if (hungryCount > 0 && !isSimulation) {
                console.log(`${playerToDeclareFor.toUpperCase()} has ${hungryCount} hungry animal(s) final map: ${Object.keys(hungryPiecesMap).join(', ')}`);
            }
            // --- END WRAP ---
            return { hungryCount, hungryPiecesMap };
        }


        /**
         * Checks if any hungry pieces of the current player failed to make a capture
         * during the move that just occurred. Removes starved pieces from the board state and DOM.
         * **Crucially, updates the global `gameState.zobristHash` by XORing out starved pieces.**
         * Called *before* the main piece movement in `performMove`.
         * @param {string} movedPieceCoords - The starting coordinates of the piece that is *about* to be moved.
         * @param {boolean} wasAttack - Indicates if the move being performed *is* a capture.
         * @returns {string[]} An array of coordinates of the pieces that starved.
         */
        function checkAndApplyStarvation(movedPieceCoords, wasAttack) {
            const currentPlayer = gameState.currentPlayer; // Player whose turn it *was*
            const starvedPiecesCoords = []; // Store coords of pieces to remove
            let currentHash = gameState.zobristHash; // Get current hash before modifications

            // Iterate through all pieces on the board
            for (const coords in gameState.board) {
                if (!Object.prototype.hasOwnProperty.call(gameState.board, coords)) continue;

                const piece = gameState.board[coords];
                // Check if it's the current player's piece AND it was marked as hungry *before* this move started
                if (piece?.player === currentPlayer && piece.isHungry) {
                    // Did *this specific piece* make the capturing move?
                    const didThisPieceAttack = (coords === movedPieceCoords) && wasAttack;

                    if (!didThisPieceAttack) {
                        // If this hungry piece did NOT make a capturing move, it starves
                        console.log(`STARVE: ${currentPlayer} ${RANK_TO_NAME[piece.rank]}@${coords} was hungry but did not attack. Starved.`);
                        starvedPiecesCoords.push(coords);

                        // --- Update Zobrist Hash IMMEDIATELY for the starved piece ---
                        currentHash = togglePieceKey(currentHash, piece, coords);
                        console.log(` -> Zobrist hash updated (removed ${RANK_TO_NAME[piece.rank]}@${coords}): ${currentHash}`);
                        // -----------------------------------------------------------

                    } else {
                        // If this hungry piece *did* make the attack, it's saved
                        // console.log(`SAVED: ${currentPlayer} ${RANK_TO_NAME[piece.rank]}@${coords} attacked and is no longer hungry (for now).`);
                        // No hash change needed here, the subsequent move update will handle it.
                    }
                }
            }

            // Apply the accumulated hash changes from starvation
            gameState.zobristHash = currentHash;

            // Remove starved pieces from the board state and DOM AFTER hash updates
            starvedPiecesCoords.forEach(coords => {
                const starvedElement = document.getElementById(getPieceElementId(coords));
                const pieceData = gameState.board[coords]; // Get data before deleting
                if (pieceData) { // Ensure piece still exists (should always be true here)
                    // console.log(`Removing starved piece ${RANK_TO_NAME[pieceData.rank]}@${coords}`);
                    delete gameState.board[coords]; // Remove from board state
                    // Animate and remove DOM element
                    if (starvedElement) {
                        starvedElement.classList.add('captured'); // Use capture animation for removal
                        setTimeout(() => starvedElement.remove(), 400);
                    }
                }
            });

            return starvedPiecesCoords; // Return list of starved piece coordinates for logging/notation
        }


        /**
         * Gets all geometrically possible destination squares for a piece, considering orthogonal moves and jumps.
         * Does not validate the move legality (terrain, captures), only potential squares.
         * @param {string} fromCoords - The starting coordinates.
         * @param {object} piece - The piece data object.
         * @returns {string[]} An array of potential destination coordinate strings.
         */
        function getPotentialMoveDestinations(fromCoords, piece) {
            const destinations = new Set(); // Use a Set to avoid duplicate coordinates
            const rc = getRowCol(fromCoords);
            if (!rc || !piece) return [];

            const { row, col } = rc;
            const abilities = SPECIAL_ABILITIES[piece.rank] || {};

            // 1. Orthogonal Moves (adjacent squares)
            const orthMoves = [
                getCoords(row + 1, col), // Down
                getCoords(row - 1, col), // Up
                getCoords(row, col + 1), // Right
                getCoords(row, col - 1)  // Left
            ];
            orthMoves.forEach(c => {
                if (c) destinations.add(c); // Add if valid coords
            });

            // 2. Jump Moves (Lion/Tiger/Leopard)
            // Vertical jumps (over cols 1, 2, 4, 5 river sections)
            if (abilities.jumpV && (col === 1 || col === 2 || col === 4 || col === 5)) {
                // Check jump up (possible from rows 3 to 8)
                if (row >= 3) { // Need 3 rows of water + 1 landing row above
                    const destUp = getCoords(row - 4, col); // 4 rows difference
                    if (destUp) destinations.add(destUp);
                }
                // Check jump down (possible from rows 0 to 5)
                if (row <= 5) { // Need 3 rows of water + 1 landing row below
                    const destDown = getCoords(row + 4, col);
                    if (destDown) destinations.add(destDown);
                }
            }
            // Horizontal jumps (over rows 3, 4, 5 river sections)
            if (abilities.jumpH && (row >= 3 && row <= 5)) { // Must be in a river row
                // Check jump left (possible from cols 3 to 6)
                if (col >= 3) { // Need 2 cols of water + 1 landing col left
                    const destLeft = getCoords(row, col - 3); // 3 cols difference
                    if (destLeft) destinations.add(destLeft);
                }
                 // Check jump right (possible from cols 0 to 3)
                if (col <= 3) { // Need 2 cols of water + 1 landing col right
                    const destRight = getCoords(row, col + 3);
                    if (destRight) destinations.add(destRight);
                }
            }

            return [...destinations]; // Convert Set back to an array
        }


        // --- AI Logic (Minimax) ---

        /**
         * Initializes or resets the state variables used during an AI search,
         * including node count, cancellation flag, start time, killer moves table,
         * and the history heuristic table.
         * Should be called before starting a new search (e.g., in triggerAIMove).
         */
        function initializeAISearchState() {
            nodeCount = 0;
            searchStartTime = performance.now();
            searchCancelled = false;

            // Initialize killer moves table
            const maxPly = (MAX_SEARCH_DEPTH || MINIMAX_DEPTH || 6) + (MAX_QUIESCENCE_DEPTH || 4) + 5;
            killerMoves = Array(maxPly).fill(null).map(() => [null, null]);

            // Initialize history heuristic table (NUM_PIECE_TYPES x SQUARES)
            historyHeuristic = Array(NUM_PIECE_TYPES).fill(null).map(() => Array(SQUARES).fill(0));

            console.log("AI search state initialized (killers, history reset).");
        }

        /**
         * Adds a move to the killer moves table for a given ply depth.
         * Stores up to two killer moves per ply. If adding a new killer and
         * both slots are full, the second slot move is discarded, the first slot move
         * shifts to the second slot, and the new move takes the first slot.
         * Avoids adding duplicates.
         *
         * @param {number} ply - The search depth (ply) at which the cutoff occurred.
         * @param {object} move - The move object { from, to } that caused the cutoff.
         */
        function addKillerMove(ply, move) {
            if (!move || ply < 0 || ply >= killerMoves.length) {
                // console.warn(`addKillerMove: Invalid ply (${ply}) or move.`, move);
                return;
            }

            // Avoid adding the same move twice to the killer slots for this ply
            if ((killerMoves[ply][0]?.from === move.from && killerMoves[ply][0]?.to === move.to)) {
                return; // Move already in first slot
            }
            if ((killerMoves[ply][1]?.from === move.from && killerMoves[ply][1]?.to === move.to)) {
                // If it's in the second slot, promote it to the first slot
                killerMoves[ply][1] = killerMoves[ply][0]; // Shift old [0] to [1]
                killerMoves[ply][0] = move;                // Put new move in [0]
                return;
            }

            // Shift the current killer move(s) and add the new one
            killerMoves[ply][1] = killerMoves[ply][0]; // Old slot 0 moves to slot 1 (might be null)
            killerMoves[ply][0] = move;                // New move goes into slot 0
            // console.log(`[Killer Added] Ply ${ply}: ${move.from}->${move.to}`);
        }

        /**
         * Updates the history heuristic score for a given piece moving to a specific square.
         * Increases the score based on the bonus (typically related to search depth),
         * capping it at AI_HISTORY_MAX.
         *
         * @param {object} piece - The piece object { player, rank } that moved.
         * @param {string} toCoords - The destination coordinates of the move.
         * @param {number} depthBonus - The bonus value to add (e.g., depth * depth).
         */
        function updateHistoryScore(piece, toCoords, depthBonus) {
            if (!piece || !toCoords || depthBonus <= 0) return;

            const pieceTypeIndex = getPieceTypeIndex(piece.player, piece.rank);
            const toSquareIndex = getSquareIndex(toCoords);

            if (pieceTypeIndex === -1 || toSquareIndex === -1) {
                // console.warn("updateHistoryScore: Invalid piece or square index.");
                return;
            }

            // Ensure the array structure exists (should be guaranteed by init)
            if (!historyHeuristic[pieceTypeIndex]) {
                 console.error("History Heuristic array missing for piece type:", pieceTypeIndex);
                 historyHeuristic[pieceTypeIndex] = Array(SQUARES).fill(0); // Attempt recovery
            }

            let currentScore = historyHeuristic[pieceTypeIndex][toSquareIndex] || 0;
            currentScore += depthBonus;

            // Cap the score to prevent it from growing indefinitely
            historyHeuristic[pieceTypeIndex][toSquareIndex] = Math.min(currentScore, AI_HISTORY_MAX);

            // console.log(`[History Update] ${piece.player[0]}${piece.rank}@${toCoords}: +${depthBonus} -> ${historyHeuristic[pieceTypeIndex][toSquareIndex]}`);
        }

        /**
         * Controls the AI's move selection using Iterative Deepening (ID) with time management.
         * Initializes search state, calculates time limits, runs the search iteratively,
         * dynamically adjusts depth based on piece count (with a specific cap for the opening),
         * uses a pre-emptive time check, handles results, manages the AI clock, and performs the chosen move.
         */
        function triggerAIMove() {
            console.log("AI (Yellow) is thinking...");
            const player = PLAYERS.YELLOW;
            const aiPlayerClockTime = yellowTime;

            // --- Initialize Search State ---
            initializeAISearchState();

            // --- Calculate Time Limit ---
            let allocatedTime = Math.max(MIN_TIME_PER_MOVE, aiPlayerClockTime * 1000 * TIME_USAGE_FACTOR);
            allocatedTime = Math.min(allocatedTime, aiPlayerClockTime * 1000 * 0.8);
            allocatedTime = Math.max(allocatedTime, 500);
            timeLimit = allocatedTime;
            searchStartTime = performance.now();

            console.log(`AI Time Control: Clock=${aiPlayerClockTime.toFixed(1)}s, Allocating=${(timeLimit / 1000).toFixed(2)}s`);

            // --- Calculate Dynamic Depth (with opening cap) ---
            const totalPieces = Object.keys(gameState.board).length;
            let calculatedDepth;
            // *** CORRECTED DYNAMIC DEPTH LOGIC ***
            if (totalPieces > 12) calculatedDepth = 4;     // Early game (13-16 pieces, capped later if 16)
            else if (totalPieces > 8) calculatedDepth = 5; // Mid game (9-12 pieces) <-- Increased from 4
            else if (totalPieces > 6) calculatedDepth = 6; // Late Mid game (7-8 pieces)
            else calculatedDepth = 10;                      // Endgame (<= 6 pieces)

            // Apply specific depth cap for opening (16 pieces)
            const OPENING_DEPTH_CAP = 4;
            if (totalPieces === 16) {
                calculatedDepth = Math.min(calculatedDepth, OPENING_DEPTH_CAP);
                console.log(` -> Applying opening depth cap of ${OPENING_DEPTH_CAP}`);
            }

            // Ensure calculated depth doesn't exceed the global max
            const maxDepthForThisSearch = Math.min(calculatedDepth, MAX_SEARCH_DEPTH);
            console.log(`AI using max search depth: ${maxDepthForThisSearch} (Pieces: ${totalPieces}, Calc: ${calculatedDepth}, Capped: ${calculatedDepth !== maxDepthForThisSearch}, GlobalMax: ${MAX_SEARCH_DEPTH})`);


            // --- Iterative Deepening Loop ---
            let bestMoveOverall = null;
            let bestScoreOverall = -Infinity;
            let lastCompletedDepth = 0;
            const rootState = cloneGameState(gameState);

            for (let currentDepth = 1; currentDepth <= maxDepthForThisSearch; currentDepth++) {
                let bestMoveThisDepth = null;
                let bestScoreThisDepth = -Infinity;

                try {
                    // Pre-emptive Time Check
                    const elapsedTimeMs = performance.now() - searchStartTime;
                    if (currentDepth > 1 && timeLimit > 0 && elapsedTimeMs > timeLimit * TIME_PREDICTION_FACTOR) {
                         console.log(`ID Pre-emptive Stop: Elapsed time (${(elapsedTimeMs/1000).toFixed(2)}s) exceeds prediction factor before depth ${currentDepth}.`);
                         searchCancelled = true;
                         break;
                    }

                    const result = findBestMoveMinimax(currentDepth, rootState, player);

                    if (searchCancelled) {
                        console.log(`Search cancelled during depth ${currentDepth}. Using results from depth ${lastCompletedDepth}.`);
                        break;
                    }

                    if (result && result.move) {
                        bestMoveThisDepth = result.move;
                        bestScoreThisDepth = result.score;
                        bestMoveOverall = bestMoveThisDepth;
                        bestScoreOverall = bestScoreThisDepth;
                        lastCompletedDepth = currentDepth;

                        const currentElapsedTime = (performance.now() - searchStartTime) / 1000;
                        console.log(`ID Depth ${currentDepth}: Best=${bestMoveOverall.from}->${bestMoveOverall.to}, Score=${bestScoreOverall.toFixed(2)}, Nodes=${nodeCount}, Time=${currentElapsedTime.toFixed(2)}s`);

                        // Check stopping conditions
                        if (Math.abs(bestScoreOverall) > MATE_SCORE_THRESHOLD) {
                             console.log(`ID Stop: Mate score detected at depth ${currentDepth}.`);
                             break;
                        }
                        if (timeLimit > 0 && performance.now() - searchStartTime >= timeLimit) {
                             console.log(`ID Stop: Actual time limit reached after depth ${currentDepth}.`);
                             searchCancelled = true;
                             break;
                         }

                    } else {
                        console.warn(`ID Warning: No valid move returned from search at depth ${currentDepth}. Using previous depth's result.`);
                        break;
                    }

                } catch (e) {
                    console.error(`ID Error during search at depth ${currentDepth}:`, e);
                    searchCancelled = true;
                    break;
                }
            } // End Iterative Deepening Loop


            // --- Post-Search ---
            const aiEndTime = performance.now();
            const totalTime = (aiEndTime - searchStartTime);
            const totalTimeSec = (totalTime / 1000).toFixed(2);
            console.log(`AI Search Complete. Depth ${lastCompletedDepth}. Nodes: ${nodeCount}, Total Time: ${totalTimeSec}s`);

            // --- Deduct AI Thinking Time ---
            const elapsedSeconds = Math.max(0, Math.round(totalTime / 1000));
            console.log(`Deducting ${elapsedSeconds}s from Yellow's clock.`);
            yellowTime -= elapsedSeconds;
            if (yellowTime < 0) yellowTime = 0;
            updateClockDisplay(PLAYERS.YELLOW, yellowTime);
            if (yellowTime <= 0) { console.log("Yellow time ran out AFTER move calculation."); }

            // --- Perform Move ---
            if (bestMoveOverall && bestMoveOverall.from && bestMoveOverall.to) {
                console.log(`AI Performing Move: ${bestMoveOverall.from}->${bestMoveOverall.to} (from depth ${lastCompletedDepth})`);
                performMove(bestMoveOverall.from, bestMoveOverall.to);
            } else {
                 console.error(`AI ERROR: No best move found after Iterative Deepening! Choosing first available move.`);
                 let fallbackMove = null;
                 try {
                    const currentValidMoves = getAllValidMoves(gameState.board, player, false).filter(m => m);
                     if (currentValidMoves.length > 0) {
                         fallbackMove = currentValidMoves[0];
                     }
                 } catch (e) { console.error("AI Fallback Error: Could not get valid moves.", e); }

                 if (fallbackMove) {
                      console.log(`AI Fallback: Performing move ${fallbackMove.from} -> ${fallbackMove.to}`);
                      performMove(fallbackMove.from, fallbackMove.to);
                 } else {
                     console.error("AI CRITICAL ERROR: No moves available even for fallback!");
                     if (!gameState.gameOver) { /* Handle game over */ }
                 }
            }
        }

        /**
         * Finds the best move for the AI at the root of the search tree.
         * Uses the Negamax search function internally.
         * Incorporates Transposition Table results for move ordering.
         * Includes enhanced error logging.
         *
         * @param {number} depth - The maximum search depth.
         * @param {object} currentGameState - The current state of the game (must include zobristHash).
         * @param {string} playerForMax - The player the AI is playing as (usually YELLOW).
         * @returns {{move: object, score: number}|null} The best move found ({from, to}) and its score (relative to playerForMax), or null if no moves.
         */
        function findBestMoveMinimax(depth, currentGameState, playerForMax) {
            let bestScore = -Infinity; // Score relative to the AI player (playerForMax)
            let bestMove = null;
            let alpha = -Infinity;
            let beta = Infinity;

            if (!currentGameState || !currentGameState.board || typeof currentGameState.zobristHash !== 'bigint') {
                console.error("findBestMoveMinimax Error: Invalid currentGameState provided.");
                return null;
            }
            if (currentGameState.currentPlayer !== playerForMax) {
                 console.error(`findBestMoveMinimax Error: Root game state player (${currentGameState.currentPlayer}) does not match playerForMax (${playerForMax})`);
                 return null;
            }

            let possibleMoves = [];
            try {
                possibleMoves = getAllValidMoves(currentGameState.board, currentGameState.currentPlayer, true);
            } catch(e) {
                console.error("findBestMoveMinimax Error getting possible moves:", e);
                return null;
            }

            const opponentDen = playerForMax === PLAYERS.ORANGE ? DENS.yellow : DENS.orange;

            if (possibleMoves.length === 0) {
                console.log("AI findBestMove: No possible moves found.");
                return null;
            }

            // --- Immediate Win Check ---
            for (const move of possibleMoves) {
                if (!move || !move.from || !move.to) continue;
                if (move.to === opponentDen) {
                    const movingPiece = currentGameState.board[move.from];
                    if (movingPiece && !movingPiece.isHungry) {
                        console.log("AI Found immediate winning move to Den:", move);
                        return { move: move, score: AI_WIN_SCORE };
                    }
                }
            }

            // --- Handle Hungry Pieces Obligation ---
            let movesToConsider = possibleMoves;
            try {
                const hungryMoves = possibleMoves.filter(move => move && currentGameState.board[move.from]?.isHungry);
                if (hungryMoves.length > 0) {
                    const attackingHungryMoves = hungryMoves.filter(move => move && !!currentGameState.board[move.to]);
                    if (attackingHungryMoves.length > 0) movesToConsider = attackingHungryMoves;
                    else movesToConsider = hungryMoves;
                }
            } catch (e) {
                console.error("findBestMoveMinimax Error during hungry check:", e);
                movesToConsider = possibleMoves;
            }

            // --- Move Ordering Heuristic (TT Move First) ---
            let ttBestMoveCoords = null;
            const rootHash = currentGameState.zobristHash;
            const rootTTEntry = transpositionTable.get(rootHash);
            if (rootTTEntry?.bestMove) {
                ttBestMoveCoords = rootTTEntry.bestMove;
                const ttMoveIndex = movesToConsider.findIndex(m => m?.from === ttBestMoveCoords.from && m?.to === ttBestMoveCoords.to);
                if (ttMoveIndex > 0) {
                    movesToConsider.unshift(movesToConsider.splice(ttMoveIndex, 1)[0]);
                }
            }

            // --- Evaluate Moves using Negamax Search ---
            for (const move of movesToConsider) {
                if (!move || !move.from || !move.to) {
                    console.warn("[findBestMoveMinimax] Skipping invalid move in movesToConsider:", move);
                    continue;
                };

                let score = -Infinity;
                let simResult = null;

                try {
                    const stateForSim = cloneGameState(currentGameState);
                    simResult = simulateMove(stateForSim, move);

                    if (!simResult || !simResult.nextState || !simResult.nextState.board) {
                        console.error(`[findBestMoveMinimax] Simulation failed for move ${move.from}->${move.to}`);
                        continue;
                    }
                    const { nextState } = simResult;

                    // Call search for the child node (opponent's turn)
                    score = -search(depth - 1, nextState, -beta, -alpha, playerForMax, 1);

                } catch (e) {
                    // *** Enhanced Error Logging ***
                    console.error(`[findBestMoveMinimax] Error during simulation or search call for move ${move.from}->${move.to}:`);
                    console.error("Caught Error Object:", e);
                    if (e instanceof Error) {
                        console.error("Error Message:", e.message);
                        console.error("Error Stack:", e.stack);
                    }
                    // *** End Enhanced Logging ***
                    continue; // Skip this move on error
                }

                // --- Update Best Move (Root Level) ---
                if (score > bestScore) {
                    bestScore = score;
                    bestMove = move;
                }

                // --- Alpha Update (Root Level) ---
                alpha = Math.max(alpha, score);

            } // End loop through movesToConsider


            if (bestMove) {
                 return { move: bestMove, score: bestScore };
            }

             console.warn("Search root didn't find ANY viable best move. Picking first valid move as fallback.");
             const fallbackMove = movesToConsider.find(m => m);
             if (fallbackMove) {
                 return { move: fallbackMove, score: -Infinity };
             } else {
                  console.error("AI findBestMove: No valid moves left even for fallback!");
                  return null;
             }
        }

        /**
         * Quiescence Search: Extends the search depth to evaluate "noisy" positions
         * (captures, den threats) until a stable (quiet) position is reached or max depth hit.
         * Includes time limit checks based on the global `timeLimit`.
         *
         * @param {object} nodeGameState - The game state at the current node (must include zobristHash).
         * @param {number} alpha - The lower bound for the current player.
         * @param {number} beta - The upper bound for the current player.
         * @param {number} ply - The current total search depth (main search + quiescence).
         * @returns {number} The evaluated score for the stable position, relative to the player whose turn it is in nodeGameState.
         */
        function qsearch(nodeGameState, alpha, beta, ply) {
            nodeCount++;

            // --- Frequent Time Limit Check ---
            // Use the global 'timeLimit' variable calculated in triggerAIMove
            // Check every N nodes (e.g., 1023 = 1024-1)
            // REMOVED check for `TIME_LIMIT_MS > 0`
            if (searchCancelled || ((nodeCount & 1023) === 0 && timeLimit > 0 && performance.now() - searchStartTime > timeLimit)) {
                if (!searchCancelled) searchCancelled = true;
                return 0; // Return neutral score if time is up
            }

            // --- Max Depth Check ---
            if (ply >= MAX_SEARCH_DEPTH + MAX_QUIESCENCE_DEPTH) {
                return evaluateBoard(nodeGameState.board, nodeGameState.currentPlayer);
            }

            // --- Repetition Check (Optional) ---
            const currentHash = nodeGameState.zobristHash;
            const repetitionCount = gameState.boardStateHistory[currentHash.toString()] || 0;
            if (repetitionCount >= 2 && ply > 0) {
                return 0; // Draw score
            }

            // --- Stand-Pat Score ---
            const standPatScore = evaluateBoard(nodeGameState.board, nodeGameState.currentPlayer);

            // --- Stand-Pat Pruning ---
            if (standPatScore >= beta) return beta;
            if (standPatScore > alpha) alpha = standPatScore;

            // --- Generate & Order Noisy Moves ---
            let noisyMoves = [];
            try {
                const allMoves = getAllValidMoves(nodeGameState.board, nodeGameState.currentPlayer, true);
                const opponentDen = nodeGameState.currentPlayer === PLAYERS.ORANGE ? DENS.yellow : DENS.orange;
                const adjacentToOppDen = getAdjacentCoords(opponentDen);
                const tempScoredMoves = [];
                for(const move of allMoves) {
                    if (!move || !move.to) continue;
                    let score = 0;
                    let isNoisy = false;
                    if (nodeGameState.board[move.to]) { // Capture
                        score = getMvvLvaScore(move, nodeGameState.board);
                        isNoisy = true;
                    } else if (move.to === opponentDen && !nodeGameState.board[move.from]?.isHungry) { // Den move
                         score = 9000;
                         isNoisy = true;
                    } else if (adjacentToOppDen.includes(move.to)) { // Adjacent to den
                         score = 8000;
                         isNoisy = true;
                    }
                    if (isNoisy) tempScoredMoves.push({ move: move, score: score });
                }
                tempScoredMoves.sort((a, b) => b.score - a.score);
                noisyMoves = tempScoredMoves.map(item => item.move);
            } catch (e) {
                console.error(`[QSearch Error] Error getting/filtering moves at ply ${ply}:`, e);
                return standPatScore;
            }

            // --- Base Case: No Noisy Moves ---
            if (noisyMoves.length === 0) {
                return standPatScore;
            }

            // --- Explore Noisy Moves ---
            let bestScore = standPatScore;
            for (const move of noisyMoves) {
                if (!move || !move.from || !move.to) continue;
                const stateForSim = cloneGameState(nodeGameState);
                const simResult = simulateMove(stateForSim, move);
                if (!simResult || !simResult.nextState) continue;
                const { nextState } = simResult;
                const score = -qsearch(nextState, -beta, -alpha, ply + 1);
                if (searchCancelled) return 0; // Check immediately
                bestScore = Math.max(bestScore, score);
                alpha = Math.max(alpha, bestScore);
                if (alpha >= beta) break; // Beta cutoff
            }
            return bestScore;
        }


        /**
         * Calculates the Most Valuable Victim - Least Valuable Attacker (MVV-LVA) score.
         * Used for prioritizing capture moves during move ordering.
         * Higher score means capturing a more valuable piece with a less valuable attacker.
         * Adds a large base score to ensure captures are prioritized over quiet moves.
         *
         * @param {object} move - The move object { from, to }.
         * @param {object} board - The board state object.
         * @returns {number} The MVV-LVA score for the capture, or 0 if it's not a capture.
         */
        function getMvvLvaScore(move, board) {
            const victim = board[move.to];
            if (!victim) return 0; // Not a capture

            const attacker = board[move.from];
            if (!attacker) return 0; // Should not happen if move is valid

            const victimValue = AI_PIECE_VALUES[victim.rank] || 10; // Default value if rank somehow invalid
            const attackerValue = AI_PIECE_VALUES[attacker.rank] || 100; // Default high value if rank invalid

            // Base score ensures captures are generally higher than quiet moves
            // Victim value scaled up, attacker value subtracted
            const MVV_LVA_BASE_SCORE = 10000; // Base score for any capture
            const VICTIM_MULTIPLIER = 10; // How much to weigh the victim's value

            return MVV_LVA_BASE_SCORE + (victimValue * VICTIM_MULTIPLIER) - attackerValue;
        }

        /**
         * Generates and orders valid moves for the current node in the search.
         * Prioritizes moves based on: TT Hint > Captures (MVV-LVA) > Killers > Den Threats > History Heuristic > Other Quiet Moves.
         *
         * @param {object} nodeGameState - The game state at the current node (must include board, currentPlayer).
         * @param {object | null} ttBestMove - The best move suggested by the Transposition Table { from, to } or null.
         * @param {number} ply - The current search depth, used to index killer moves.
         * @param {Array<object>} movesToConsider - The list of moves already filtered (e.g., for hunger rules) that should be ordered.
         * @returns {Array<object>} A new array containing the move objects, sorted by priority.
         */
        function getOrderedMoves(nodeGameState, ttBestMove, ply, movesToConsider) {
            if (!movesToConsider || movesToConsider.length === 0) {
                return [];
            }

            const board = nodeGameState.board;
            const currentPlayer = nodeGameState.currentPlayer;
            const opponentDen = currentPlayer === PLAYERS.ORANGE ? DENS.yellow : DENS.orange;
            const adjacentToOppDen = getAdjacentCoords(opponentDen);

            // Score Definitions (higher is better)
            const SCORE_TT_MOVE = 100000;
            // MVV_LVA scores start around 10000+
            const SCORE_KILLER_1 = AI_KILLER_MOVE_BONUS;      // e.g., 7500
            const SCORE_KILLER_2 = AI_KILLER_MOVE_BONUS - 5; // e.g., 7495
            const SCORE_DEN_ATTACK = 7000; // Lower than killers now
            const SCORE_DEN_ADJACENT = 6500;
            // History Heuristic scores range from 0 up to AI_HISTORY_MAX (e.g., 10000),
            // but we'll give them a base below killers/den threats for sorting.
            const SCORE_HISTORY_BASE = 0; // Base score, actual history value added
            const SCORE_QUIET = 0; // Default for unclassified quiet moves

            const scoredMoves = [];
            const killer1 = killerMoves[ply]?.[0];
            const killer2 = killerMoves[ply]?.[1];

            for (const move of movesToConsider) {
                if (!move || !move.from || !move.to) continue;

                let score = SCORE_QUIET;
                const piece = board[move.from]; // Get piece data for history lookup
                const isCapture = !!board[move.to];

                // 1. TT Hint Move
                if (ttBestMove && move.from === ttBestMove.from && move.to === ttBestMove.to) {
                    score = SCORE_TT_MOVE;
                } else {
                    // 2. Captures (MVV-LVA)
                    if (isCapture) {
                        score = getMvvLvaScore(move, board);
                    } else {
                        // --- Quiet Moves ---
                        let isKiller = false;
                        let isDenThreat = false;

                        // 3. Killer Moves
                        if (killer1 && move.from === killer1.from && move.to === killer1.to) {
                            score = SCORE_KILLER_1;
                            isKiller = true;
                        } else if (killer2 && move.from === killer2.from && move.to === killer2.to) {
                            score = SCORE_KILLER_2;
                            isKiller = true;
                        }

                        // 4. Den Threats (if not Killer)
                        if (!isKiller) {
                            if (move.to === opponentDen) {
                                if (!piece?.isHungry) { score = SCORE_DEN_ATTACK; isDenThreat = true; }
                                else if (adjacentToOppDen.includes(move.to)) { score = SCORE_DEN_ADJACENT; isDenThreat = true; }
                            } else if (adjacentToOppDen.includes(move.to)) {
                                score = SCORE_DEN_ADJACENT;
                                isDenThreat = true;
                            }
                        }

                        // 5. History Heuristic (if not Killer or Den Threat)
                        if (!isKiller && !isDenThreat && piece) {
                            const pieceTypeIndex = getPieceTypeIndex(piece.player, piece.rank);
                            const toSquareIndex = getSquareIndex(move.to);
                            if (pieceTypeIndex !== -1 && toSquareIndex !== -1) {
                                // History score adds to a base, ensuring it's below killers/den threats
                                // but allows sorting among other quiet moves.
                                score = SCORE_HISTORY_BASE + (historyHeuristic[pieceTypeIndex]?.[toSquareIndex] || 0);
                            }
                        }
                        // --- End Quiet Moves ---
                    }
                }
                scoredMoves.push({ move: move, score: score });
            }

            scoredMoves.sort((a, b) => b.score - a.score);

            return scoredMoves.map(item => item.move);
        }

        /**
         * Negamax search function with Alpha-Beta Pruning, TT integration, Killers, History.
         * Uses getOrderedMoves for efficiency. Calls Quiescence Search (`qsearch`) at depth limit.
         * Includes frequent time checks based on the global `timeLimit`.
         *
         * @param {number} depth - Remaining depth to search.
         * @param {object} nodeGameState - Game state at current node (must have zobristHash).
         * @param {number} alpha - Lower bound for current player.
         * @param {number} beta - Upper bound for current player.
         * @param {string} playerForMax - The AI player (needed for eval context).
         * @param {number} ply - Current depth from the root (0 at root).
         * @returns {number} Evaluated score relative to the player at nodeGameState.
         */
        function search(depth, nodeGameState, alpha, beta, playerForMax, ply) {
            nodeCount++;

            // --- Frequent Time Limit Check ---
            // Use the global 'timeLimit' variable calculated in triggerAIMove
            // Check every N nodes (e.g., 2047 = 2048-1) and if ply > 1
            // REMOVED check for `TIME_LIMIT_MS > 0`
            if (searchCancelled || (ply > 1 && timeLimit > 0 && (nodeCount & 2047) === 0 && performance.now() - searchStartTime > timeLimit)) {
                if (!searchCancelled) searchCancelled = true;
                return 0; // Return neutral score if cancelled
            }

            // --- Repetition Check ---
            const currentHash = nodeGameState.zobristHash;
            if (ply > 0) {
                const repetitionCount = gameState.boardStateHistory[currentHash.toString()] || 0;
                if (repetitionCount >= 2) return 0;
            }

            // --- Base Cases ---
            if (nodeGameState.gameOver) {
                if (nodeGameState.winner === nodeGameState.currentPlayer) return MATE_SCORE_THRESHOLD - ply;
                if (nodeGameState.winner === null) return 0;
                return MATED_SCORE_THRESHOLD + ply;
            }
            if (depth <= 0) {
                try {
                     return qsearch(nodeGameState, alpha, beta, ply);
                } catch (qError) {
                     console.error(`[Search] Error during qsearch call at ply ${ply}:`);
                     console.error("QSearch Caught Error Object:", qError);
                     if (qError instanceof Error) { console.error("QSearch Error Stack:", qError.stack); }
                     searchCancelled = true;
                     return 0;
                }
            }

            // --- Transposition Table Lookup ---
            let ttBestMove = null;
            const ttEntry = transpositionTable.get(currentHash);
            if (ttEntry && ttEntry.depth >= depth) {
                let ttScore = ttEntry.score;
                if (ttScore > MATE_SCORE_THRESHOLD) ttScore -= ply;
                else if (ttScore < MATED_SCORE_THRESHOLD) ttScore += ply;
                if (ttEntry.type === TT_ENTRY_TYPE.EXACT) return ttScore;
                if (ttEntry.type === TT_ENTRY_TYPE.LOWER_BOUND) alpha = Math.max(alpha, ttScore);
                if (ttEntry.type === TT_ENTRY_TYPE.UPPER_BOUND) beta = Math.min(beta, ttScore);
                if (alpha >= beta) return ttScore;
                if (ttEntry.bestMove) ttBestMove = ttEntry.bestMove;
            }

            // --- Move Generation & Ordering ---
            let movesToConsider = [];
            let initialPossibleMoves = [];
            try {
                initialPossibleMoves = getAllValidMoves(nodeGameState.board, nodeGameState.currentPlayer, true);
                if (initialPossibleMoves.length === 0) return MATED_SCORE_THRESHOLD + ply;

                movesToConsider = initialPossibleMoves;
                const hungryMoves = initialPossibleMoves.filter(move => move && nodeGameState.board[move.from]?.isHungry);
                if (hungryMoves.length > 0) {
                    const attackingHungryMoves = hungryMoves.filter(move => move && !!nodeGameState.board[move.to]);
                    if (attackingHungryMoves.length > 0) movesToConsider = attackingHungryMoves;
                    else movesToConsider = hungryMoves;
                }
                movesToConsider = getOrderedMoves(nodeGameState, ttBestMove, ply, movesToConsider);

            } catch(e) {
                console.error("[Search Error] Error getting/ordering moves at depth", depth, "ply", ply, e);
                return MATED_SCORE_THRESHOLD + ply;
            }

            // --- Recursive Exploration ---
            let bestScore = -Infinity;
            let bestMoveFound = null;
            let originalAlpha = alpha;

            for (const move of movesToConsider) {
                if (!move || !move.from || !move.to) continue;

                const stateForSim = cloneGameState(nodeGameState);
                const simResult = simulateMove(stateForSim, move);
                if (!simResult || !simResult.nextState) continue;
                const { nextState } = simResult;

                const score = -search(depth - 1, nextState, -beta, -alpha, playerForMax, ply + 1);

                if (searchCancelled) return 0; // Check immediately after recursive call

                if (score > bestScore) {
                    bestScore = score;
                    bestMoveFound = { from: move.from, to: move.to };
                }
                alpha = Math.max(alpha, bestScore);

                const isCapture = !!nodeGameState.board[move.to];

                if (alpha >= beta) { // Beta Cutoff
                    if (!isCapture) {
                        addKillerMove(ply, move);
                        const piece = nodeGameState.board[move.from];
                        updateHistoryScore(piece, move.to, depth * depth);
                    }
                    break;
                } else if (score > originalAlpha) { // Alpha Improved
                     if (!isCapture) {
                         const piece = nodeGameState.board[move.from];
                         updateHistoryScore(piece, move.to, depth * depth);
                     }
                }
            }
             if (searchCancelled) return 0;

            // --- Transposition Table Store ---
            let finalScoreForStorage = bestScore;
            if (finalScoreForStorage > MATE_SCORE_THRESHOLD) finalScoreForStorage += ply;
            else if (finalScoreForStorage < MATED_SCORE_THRESHOLD) finalScoreForStorage -= ply;

            let entryType;
            if (bestScore <= originalAlpha) entryType = TT_ENTRY_TYPE.UPPER_BOUND;
            else if (alpha >= beta) entryType = TT_ENTRY_TYPE.LOWER_BOUND;
            else entryType = TT_ENTRY_TYPE.EXACT;

            const existingEntry = transpositionTable.get(currentHash);
            if (!existingEntry || depth >= existingEntry.depth) {
                transpositionTable.set(currentHash, {
                    depth: depth, score: finalScoreForStorage, type: entryType, bestMove: bestMoveFound
                });
            }

            return bestScore;
        }

        /**
         * Generates a list of all valid moves for a given player in a specific board state.
         * @param {object} boardState - The board state object ({ coords: pieceData }).
         * @param {string} player - The player ('orange' or 'yellow') whose moves to find.
         * @param {boolean} [isSimulation=false] - Flag to pass down to isValidMove. // NEW PARAMETER
         * @returns {Array<object>} An array of valid move objects [{ from, to }, ...].
         */
        function getAllValidMoves(boardState, player, isSimulation = false) { // ADD isSimulation
            const validMoves = [];
            if (!boardState) return []; // Safety check

            // Iterate through all squares on the board
            for (const fromCoords in boardState) {
                const piece = boardState[fromCoords];
                // Check if the piece belongs to the specified player
                if (piece?.player === player) {
                    // Get potential destinations (geometric moves)
                    const destinations = getPotentialMoveDestinations(fromCoords, piece);
                    // Validate each potential destination
                    for (const toCoords of destinations) {
                        // Use isValidMove with a copy of piece data and pass isSimulation flag
                        if (isValidMove(fromCoords, toCoords, { ...piece }, boardState, isSimulation).valid) { // Pass isSimulation
                            validMoves.push({ from: fromCoords, to: toCoords });
                        }
                    }
                }
            }
            return validMoves;
        }

        /**
         * Creates a new game state object representing the result of making a specific move.
         * Updates hungry status for the *next* player. Does not handle full starvation rules.
         * Returns the *next* state and info about the move made. Uses efficient board cloning.
         * Calculates and includes the Zobrist hash for the resulting state. Adds debugging check.
         * @param {object} currentGameState - The game state *before* the move. Expected to have zobristHash.
         * @param {object} move - The move object { from, to }.
         * @returns {{nextState: object, moveInfo: object}|null} An object containing the new game state and move details. Returns null on critical error.
         */
        function simulateMove(currentGameState, move) {
            // --- Safety Check: Basic validation of inputs ---
            if (!currentGameState || !currentGameState.board || typeof currentGameState.zobristHash !== 'bigint' || !move || !move.from || !move.to) {
                console.error("SimulateMove Error: Invalid input or missing hash.", { currentGameState, move });
                return null; // Indicate critical failure
            }
            // --- End Safety Check ---

            // Create the next state structure, cloning the board efficiently
            const nextState = {
                board: cloneBoard(currentGameState.board),
                currentPlayer: currentGameState.currentPlayer, // Will be updated
                gameOver: currentGameState.gameOver,
                winner: currentGameState.winner,
                // Intentionally leave zobristHash uninitialized for now
            };

            const moveInfo = { // Store info about the move being simulated
                from: move.from,
                to: move.to,
                pieceRank: null,
                wasCapture: false,
                wasHungry: false
            };

            // Get the piece data *from the newly cloned board*
            const piece = nextState.board[move.from];

            // Error handling: If piece doesn't exist at source in the cloned board
            if (!piece) {
                console.error("SimulateMove Error: Piece not found at source", move.from, "in CLONED board:", nextState.board);
                nextState.gameOver = true;
                nextState.winner = currentGameState.currentPlayer === PLAYERS.ORANGE ? PLAYERS.YELLOW : PLAYERS.ORANGE;
                nextState.zobristHash = 0n; // Assign default hash on error
                return { nextState, moveInfo };
            }

            moveInfo.pieceRank = piece.rank;
            moveInfo.wasHungry = piece.isHungry || false;

            // --- Calculate Hash ---
            // Start hash calculation from PARENT state's hash
            let nextHash = currentGameState.zobristHash;
            // Use original board to get target piece data for hash calculation
            const targetPiece = currentGameState.board[move.to];

            // Simulate hash updates based on PARENT state and the move
            nextHash = togglePieceKey(nextHash, piece, move.from); // XOR out moving piece from origin
            nextHash = togglePieceKey(nextHash, piece, move.to);   // XOR in moving piece at destination
            if (targetPiece) {                                     // If capture
                moveInfo.wasCapture = true;
                nextHash = togglePieceKey(nextHash, targetPiece, move.to); // XOR out captured piece
            }
            nextHash = toggleTurnKey(nextHash);                    // XOR turn key
            // --- Hash update calculation complete ---


            // --- Apply Board State Changes (on the cloned board) ---
            if (targetPiece) { // Check if capture happened based on original board
                delete nextState.board[move.to]; // Remove captured piece from cloned board
            }
            // Need a fresh copy of piece data if we were modifying in place, but here `piece` is already from the cloned board
            nextState.board[move.to] = piece; // Place piece at destination in cloned board
            delete nextState.board[move.from]; // Remove from origin in cloned board
            if (nextState.board[move.to]) {
                nextState.board[move.to].isHungry = false; // Reset hungry status
            } else {
                console.error("SimulateMove Error: Piece missing at destination after board update!", move.to);
            }

            // --- Simplified Win Condition Checks ---
            const opponent = piece.player === PLAYERS.ORANGE ? PLAYERS.YELLOW : PLAYERS.ORANGE;
            const opponentDen = piece.player === PLAYERS.ORANGE ? DENS.yellow : DENS.orange;
            if (move.to === opponentDen && !piece.isHungry) { // Hungry pieces can't win by den entry
                nextState.gameOver = true;
                nextState.winner = piece.player;
            } else {
                let opponentPieceCount = 0;
                for (const coords in nextState.board) {
                    if (Object.prototype.hasOwnProperty.call(nextState.board, coords) && nextState.board[coords]?.player === opponent) {
                        opponentPieceCount++; break;
                    }
                }
                if (opponentPieceCount === 0) {
                    nextState.gameOver = true;
                    nextState.winner = piece.player;
                }
            }

            // --- Switch Player and Update Hungry Status ---
            nextState.currentPlayer = opponent; // Update current player
            if (!nextState.gameOver) {
                try {
                    const { hungryPiecesMap } = declareHungryAnimals(nextState.currentPlayer, nextState.board, true);
                    for (const coords in nextState.board) {
                         if (Object.prototype.hasOwnProperty.call(nextState.board, coords)) {
                             const p = nextState.board[coords];
                             if (p) p.isHungry = !!hungryPiecesMap[coords];
                         }
                    }
                } catch (e) {
                    console.error("SimulateMove Error: Failed during declareHungryAnimals:", e, "State:", nextState);
                    nextState.gameOver = true;
                    nextState.winner = piece.player; // Assign win to player who initiated move?
                }
            }

            // *** Assign the calculated hash to the nextState object ***
            nextState.zobristHash = nextHash;

            // *** ADDED DEBUG CHECK ***
            if (typeof nextState.zobristHash !== 'bigint') {
                console.error(`!!! SIMULATEMOVE ERROR: nextState.zobristHash is NOT a BigInt before returning!`, {
                    move: move,
                    type: typeof nextState.zobristHash,
                    value: nextState.zobristHash,
                    calculated_nextHash: nextHash,
                    parent_hash: currentGameState.zobristHash,
                    returned_state: nextState
                });
                // Force a valid hash to prevent downstream errors, though this indicates a problem
                nextState.zobristHash = 0n;
            }
            // *** END DEBUG CHECK ***

            return { nextState, moveInfo };
        }

        /**
         * Evaluates the static board state from the perspective of the AI player (playerForMax).
         * Incorporates material, mobility, positional factors (advancement, river, center),
         * den proximity/threats, trap safety/danger, piece safety/threats, and hunger penalties.
         * Includes specific logic for Clesto rules like water movement and traps.
         * Returns a numerical score indicating the board state's favorability for playerForMax.
         * Higher score is better for playerForMax.
         *
         * @param {object} boardState - The board state object ({ coords: pieceData }).
         * @param {string} playerForMax - The player considered "maximizing" (AI, usually Yellow).
         * @param {object|null} [originalPieceIfMove=null] - Deprecated/Unused parameter, kept for signature consistency if needed elsewhere initially.
         * @returns {number} A numerical score representing the board state's favorability.
         */
        function evaluateBoard(boardState, playerForMax, originalPieceIfMove = null) { // Keep original signature for now
            let score = 0;
            if (!boardState || typeof boardState !== 'object') {
                console.error("[Eval Error - Initial] Invalid boardState provided:", boardState);
                return playerForMax === PLAYERS.YELLOW ? AI_LOSE_SCORE : AI_WIN_SCORE; // Assign loss on error
            }

            const opponent = playerForMax === PLAYERS.ORANGE ? PLAYERS.YELLOW : PLAYERS.ORANGE;
            const maxDen = playerForMax === PLAYERS.ORANGE ? DENS.orange : DENS.yellow; // AI's own den
            const minDen = playerForMax === PLAYERS.ORANGE ? DENS.yellow : DENS.orange; // Opponent's den
            const maxTraps = playerForMax === PLAYERS.ORANGE ? TRAPS.yellow : TRAPS.orange; // Traps near AI's den (affect AI)
            const minTraps = playerForMax === PLAYERS.ORANGE ? TRAPS.orange : TRAPS.yellow; // Traps near Opp's den (affect Opp)

            let maxMaterial = 0; let minMaterial = 0;
            let maxMoves = 0; let minMoves = 0;
            let maxHungryCount = 0; let minHungryCount = 0;
            let maxPieceCount = 0; let minPieceCount = 0;
            const piecesData = { [playerForMax]: [], [opponent]: [] }; // Store piece data for easier access later

            // --- 1. Mobility Calculation ---
            try {
                maxMoves = getAllValidMoves(boardState, playerForMax, true).length;
                minMoves = getAllValidMoves(boardState, opponent, true).length;
                score += maxMoves * AI_MOBILITY_BONUS;
                score -= minMoves * AI_OPP_MOBILITY_PENALTY;
            } catch (e) {
                console.error("[Eval Error - Mobility] Error getting valid moves:", e);
                // Optionally return a neutral score or penalty if mobility calc fails
            }

            // --- 2. Iterate through Pieces for Material, Position, Threats, etc. ---
            for (const coords in boardState) {
                if (!Object.prototype.hasOwnProperty.call(boardState, coords)) continue;

                const piece = boardState[coords];
                if (!piece) continue;

                const rc = getRowCol(coords);
                if (!rc) { console.warn(`[Eval Warn] Skipping piece at invalid coords: ${coords}`); continue; }

                const pieceValue = AI_PIECE_VALUES[piece.rank] || 0;
                const abilities = SPECIAL_ABILITIES[piece.rank] || {};
                const isOnWater = WATER_SQUARES.has(coords);
                const isOnMaxTrap = maxTraps.has(coords); // Is AI piece on a trap dangerous to it
                const isOnMinTrap = minTraps.has(coords); // Is Opponent piece on a trap dangerous to it

                // Store data for later checks (e.g., win threats)
                piecesData[piece.player].push({ ...piece, coords: coords, rc: rc });

                if (piece.player === playerForMax) {
                    // --- AI Player's Piece ---
                    maxPieceCount++;
                    maxMaterial += pieceValue;
                    if (piece.isHungry) maxHungryCount++;

                    // A) Positional Bonuses
                    const rowsAdvanced = playerForMax === PLAYERS.ORANGE ? (ROWS - 1 - rc.row) : rc.row;
                    score += rowsAdvanced * AI_ADVANCE_ROW_BONUS;

                    const isPastRiver = (playerForMax === PLAYERS.ORANGE && rc.row < 3) || (playerForMax === PLAYERS.YELLOW && rc.row > 5);
                    if (isPastRiver) score += AI_RIVER_CROSS_BONUS;

                    const isCenterCol = rc.col >= 2 && rc.col <= 4;
                    if (isCenterCol) {
                        score += AI_CENTER_COL_BONUS;
                        if (isPastRiver) score += AI_CENTER_CONTROL_BONUS;
                    }

                    // B) Den Proximity (Opponent's Den)
                    const distToMinDen = Math.abs(rc.row - getRowCol(minDen).row) + Math.abs(rc.col - getRowCol(minDen).col);
                    if (distToMinDen === 1) {
                        score += AI_DEN_PROXIMITY_BONUS_1;
                        // Check if can actually enter (not hungry, valid move)
                        if (!piece.isHungry && isValidMove(coords, minDen, piece, boardState, true).valid) {
                            score += AI_WIN_ADJACENT_BONUS;
                        }
                    } else if (distToMinDen === 2) {
                        score += AI_DEN_PROXIMITY_BONUS_2;
                    }

                    // C) Trap Danger (AI piece on a trap near its own den)
                    if (isOnMaxTrap) {
                        let penalty = AI_TRAP_DANGER_PENALTY;
                        // Check if trap is guarded
                        const adjacentCoords = getAdjacentCoords(coords);
                        for (const adj of adjacentCoords) {
                            const adjPiece = boardState[adj];
                            // If opponent piece can attack AI piece ON the trap
                            if (adjPiece?.player === opponent && isValidMove(adj, coords, adjPiece, boardState, true).valid) {
                                penalty *= AI_GUARDED_TRAP_MULT;
                                break; // Apply multiplied penalty once
                            }
                        }
                        score += penalty;
                    }

                    // D) Near Opponent Traps (Offensive pressure)
                    const adjacentToCoords = getAdjacentCoords(coords);
                    if (adjacentToCoords.some(adj => minTraps.has(adj))) {
                        score += AI_NEAR_OPP_TRAP_BONUS;
                    }

                    // E) Water Control
                    if (isOnWater && (abilities.swims)) { // Rank 1 (Rat) or 3 (Dog)
                        score += AI_WATER_CONTROL_BONUS;
                    }

                    // F) Wolf/Cat Specifics
                    const isWolfOrCat = piece.rank === 4 || piece.rank === 2;
                    const totalPieces = Object.keys(boardState).length; // Recalculate or pass in? For now, recalc.
                    const isEarlyOrMidGame = totalPieces > 8;
                    if (isWolfOrCat) {
                        const isInDefensiveZone = (playerForMax === PLAYERS.ORANGE && rc.row >= 6) || (playerForMax === PLAYERS.YELLOW && rc.row <= 2);
                        score += rowsAdvanced * AI_WOLF_CAT_ADVANCE_PENALTY;
                        if (isEarlyOrMidGame && isInDefensiveZone) {
                            score += AI_WOLF_CAT_DEFENSE_BONUS;
                        }
                        // Blocking penalty - check if on river bank in jump cols
                        const isOnRiverBank = (playerForMax === PLAYERS.ORANGE && rc.row === 5) || (playerForMax === PLAYERS.YELLOW && rc.row === 3);
                        const isJumpCol = rc.col === 1 || rc.col === 2 || rc.col === 4 || rc.col === 5;
                        if(isOnRiverBank && isJumpCol) {
                            // Simple check: is there a friendly jumper further back? More complex checks needed for real accuracy.
                            // For now, apply a small penalty regardless if own jumper exists? Let's apply if ANY friendly jumper exists.
                            const friendlyJumperExists = piecesData[playerForMax].some(p => p.rank === 6 || p.rank === 7 || p.rank === 5);
                            if (friendlyJumperExists) {
                                score += AI_BLOCKING_JUMPER_PENALTY;
                            }
                        }
                    }

                } else {
                    // --- Opponent's Piece ---
                    minPieceCount++;
                    minMaterial += pieceValue;
                    if (piece.isHungry) minHungryCount++;

                    // A) Den Proximity (AI's Den)
                    const distToMaxDen = Math.abs(rc.row - getRowCol(maxDen).row) + Math.abs(rc.col - getRowCol(maxDen).col);
                    if (distToMaxDen <= 2) { // Penalty if opponent is close
                        score += AI_OWN_DEN_NEAR_PENALTY * (3 - distToMaxDen); // Higher penalty if closer
                        // Check immediate threat
                        if (distToMaxDen === 1 && !piece.isHungry && isValidMove(coords, maxDen, piece, boardState, true).valid) {
                            score += AI_IMMEDIATE_WIN_THREAT_PENALTY;
                        }
                    }

                     // B) Opponent on Trap (Beneficial for AI) - Simplified bonus
                     if (isOnMinTrap) {
                         score -= AI_TRAP_DANGER_PENALTY / 2; // Give AI points if opponent is trapped
                     }
                }
            }

            // --- 3. Post-Iteration Calculations & Checks ---

            // Material Score
            score += (maxMaterial - minMaterial) * AI_MATERIAL_MULT;

            // Hunger Penalty
            score += maxHungryCount * AI_HUNGER_PENALTY;
            // Optional: Bonus for opponent being hungry?
            // score -= minHungryCount * AI_HUNGER_PENALTY / 2; // Example: half penalty value as bonus

            // Piece Safety / Threats (Simple check after iterating all pieces)
            let maxThreatenedValue = 0;
            let minThreatenedValue = 0;
            let maxThreateningScore = 0;
            let minThreateningScore = 0;

            for (const pieceData of piecesData[playerForMax]) {
                 const adjacent = getAdjacentCoords(pieceData.coords);
                 let isThreatened = false;
                 for (const adj of adjacent) {
                     const adjPiece = boardState[adj];
                     if (adjPiece?.player === opponent && isValidMove(adj, pieceData.coords, adjPiece, boardState, true).valid) {
                         isThreatened = true; break;
                     }
                 }
                 if (isThreatened) {
                     // score += AI_PIECE_THREATENED_PENALTY; // Apply flat penalty
                     maxThreatenedValue += AI_PIECE_VALUES[pieceData.rank] || 10; // Sum value of threatened pieces
                 }

                 // Check if this piece threatens opponent
                 for(const move of getAllValidMoves(boardState, playerForMax, true).filter(m => m.from === pieceData.coords)) {
                     if(boardState[move.to]?.player === opponent) {
                         maxThreateningScore += AI_THREATENING_BONUS;
                         break; // Add bonus once per threatening piece
                     }
                 }
            }
             for (const pieceData of piecesData[opponent]) {
                 const adjacent = getAdjacentCoords(pieceData.coords);
                 let isThreatened = false;
                 for (const adj of adjacent) {
                     const adjPiece = boardState[adj];
                     if (adjPiece?.player === playerForMax && isValidMove(adj, pieceData.coords, adjPiece, boardState, true).valid) {
                         isThreatened = true; break;
                     }
                 }
                 if (isThreatened) {
                     minThreatenedValue += AI_PIECE_VALUES[pieceData.rank] || 10;
                 }
                  // Check if this piece threatens AI
                 for(const move of getAllValidMoves(boardState, opponent, true).filter(m => m.from === pieceData.coords)) {
                     if(boardState[move.to]?.player === playerForMax) {
                         minThreateningScore += AI_THREATENING_BONUS; // Use same constant, subtract later
                         break;
                     }
                 }
            }
            // Apply aggregated threat scores
            score -= maxThreatenedValue * 0.5; // Penalty based on value of threatened AI pieces
            score += minThreatenedValue * 0.4; // Bonus based on value of threatened Opp pieces
            score += maxThreateningScore;      // Bonus for AI pieces threatening Opp
            score -= minThreateningScore;      // Penalty for Opp pieces threatening AI


            // --- 4. Check Game End States ---
            if (maxPieceCount === 0) return AI_LOSE_SCORE; // AI has no pieces
            if (minPieceCount === 0) return AI_WIN_SCORE;  // Opponent has no pieces
            // Den occupation checks already happened implicitly via proximity/win checks


            // Add small random jitter to break ties? (Optional)
            // if (score < (AI_WIN_SCORE / 1.1) && score > (AI_LOSE_SCORE / 1.1)) {
            //     score += (Math.random() - 0.5) * 0.1;
            // }

            return score;
        }


        // --- UI Update & Logging ---

        /**
         * Updates the main UI elements (turn indicator, button states) based on the current game state.
         */
        function updateUI() {
            if (gameState.gameOver) {
                // Display Game Over message and winner
                turnIndicator.textContent = `Game Over - ${gameState.winner ? gameState.winner.toUpperCase() : 'DRAW'} Wins!`;
                turnIndicator.className = 'game-over'; // Apply game over style
            } else {
                // Display current player's turn
                turnIndicator.textContent = gameState.currentPlayer.toUpperCase();
                turnIndicator.className = gameState.currentPlayer; // Apply player color style
            }
            updateUndoButtonState(); // Enable/disable undo button
            updateAllPieceAccessibility(); // Update piece interactivity based on current player/game state
        }

        /**
         * Updates the status message display area and logs the message to the console.
         * @param {string} message - The message to display.
         */
        function updateStatus(message) {
            statusMessage.textContent = message; // Update the DOM element
            console.log("Status:", message); // Also log to console (and potentially debug panel)
        }

        /**
         * Creates and appends a log entry element to the visual move log panel.
         * Adds data-tooltip attribute for hover/focus interaction handled by global listeners.
         * @param {number} turn - The turn number.
         * @param {string|null} orangeMove - The notation for Orange's move this turn, or null.
         * @param {string|null} yellowMove - The notation for Yellow's move this turn, or null.
         */
        function addLogEntryToDOM(turn, orangeMove, yellowMove) { // Task 25 Change (JS Tooltip)
            const logEntryDiv = document.createElement('div');
            logEntryDiv.classList.add('log-entry');
            logEntryDiv.dataset.turn = turn;

            // Turn Number Span
            const turnSpan = document.createElement('span');
            turnSpan.classList.add('turn-number');
            turnSpan.textContent = `${turn}.\u00A0`; // Use Unicode non-breaking space
            logEntryDiv.appendChild(turnSpan);

            // Helper function to create and configure the move span
            const createMoveSpan = (moveNotation, playerClass) => {
                const span = document.createElement('span');
                span.classList.add(playerClass); // Add class regardless

                if (moveNotation && moveNotation !== '...') { // Check for actual notation
                    const description = generateMoveDescription(moveNotation);
                    span.textContent = moveNotation;
                    if (description) { // Only add tooltip attributes if description exists
                        span.setAttribute('data-tooltip', description);
                        span.setAttribute('tabindex', '0'); // Make focusable
                        // Set aria attributes for accessibility
                        span.setAttribute('role', 'button'); // Treat as interactive element
                        span.setAttribute('aria-describedby', 'move-log-tooltip'); // Point to the shared tooltip ID
                        span.setAttribute('aria-label', `Move: ${description}`); // Provide context
                    } else {
                         span.style.cursor = 'default';
                    }
                } else {
                    // Display placeholder if no move yet
                    span.textContent = '...';
                    span.classList.add('placeholder'); // Add placeholder class
                    span.style.cursor = 'default';
                }
                return span;
            };

            // Create and append Orange Move Span (always needed)
            const orangeSpan = createMoveSpan(orangeMove, 'log-orange'); // Uses the local helper

            // *** FIX: Add TRAILING NON-BREAKING space to orange span's text content ***
            // Check if it's actual content and not the placeholder
            if (orangeSpan.textContent && orangeSpan.textContent !== '...') {
               // Append the Unicode Non-Breaking Space character
               orangeSpan.textContent = orangeSpan.textContent + '\u00A0';
            }

            // Append the potentially modified orange span
            logEntryDiv.appendChild(orangeSpan);

            // Create and append Yellow Move Span ONLY if yellowMove has a value
            if (yellowMove) {
                 const yellowSpan = createMoveSpan(yellowMove, 'log-yellow');
                 logEntryDiv.appendChild(yellowSpan);
            }
            // If yellowMove is null, no yellow span is added yet. Orange move + padding handles the space.

            moveLogElement.appendChild(logEntryDiv);

            // Scroll only if the log isn't actively being hovered
            if (!moveLogElement.matches(':hover')) {
                moveLogElement.scrollTop = moveLogElement.scrollHeight;
            }
        }

        /**
         * Logs a move to the `gameState.moveHistory` array and updates the visual move log panel.
         * Handles creating new turn entries or updating existing ones by replacing the DOM element for the turn.
         * Uses the explicitly provided turn number.
         * @param {string} notation - The algebraic notation of the move (e.g., "8xg7++s").
         * @param {string} playerWhoMoved - The player who made the move ('orange' or 'yellow').
         * @param {number} turnNum - The actual turn number this move belongs to.
         */
        function logMove(notation, playerWhoMoved, turnNum) { // *** Added turnNum parameter ***
            // Find if an entry for this turn already exists in the history
            let currentTurnEntry = gameState.moveHistory.find(entry => entry.turn === turnNum);
            // Find if a DOM element for this turn already exists
            let existingLogDiv = moveLogElement.querySelector(`div.log-entry[data-turn="${turnNum}"]`);

            if (playerWhoMoved === PLAYERS.ORANGE) {
                // --- Orange's Move ---
                if (!currentTurnEntry) {
                    currentTurnEntry = { turn: turnNum, orange: notation, yellow: null };
                    gameState.moveHistory.push(currentTurnEntry);
                    if (existingLogDiv) existingLogDiv.remove();
                    addLogEntryToDOM(turnNum, notation, null);
                } else {
                    console.warn("Updating Orange's move in existing turn entry:", turnNum);
                    currentTurnEntry.orange = notation;
                    currentTurnEntry.yellow = null;
                    if (existingLogDiv) existingLogDiv.remove();
                    addLogEntryToDOM(turnNum, currentTurnEntry.orange, currentTurnEntry.yellow);
                }
            } else {
                // --- Yellow's Move ---
                if (currentTurnEntry) {
                    currentTurnEntry.yellow = notation;
                    if (existingLogDiv) {
                        existingLogDiv.remove();
                    } else {
                         console.warn(`Log div missing for turn ${turnNum} when Yellow moved. It should have existed.`);
                    }
                    addLogEntryToDOM(turnNum, currentTurnEntry.orange, currentTurnEntry.yellow);
                } else {
                    // This block should ideally NOT be reached if the turn number logic is correct.
                    console.error(`Logic Error Recovery: Yellow moved (${notation}) but no history entry found for provided turn ${turnNum}. Creating entry.`);
                    currentTurnEntry = { turn: turnNum, orange: '?', yellow: notation }; // Indicate missing Orange move
                    gameState.moveHistory.push(currentTurnEntry);
                    if (existingLogDiv) existingLogDiv.remove();
                    addLogEntryToDOM(turnNum, '?', notation);
                }
            }
            // Ensure log scrolls to bottom (with hover check)
            if (!moveLogElement.matches(':hover')) {
                 moveLogElement.scrollTop = moveLogElement.scrollHeight;
            }
        }


        /**
         * Generates a unique string representation of the current board state.
         * Used for detecting repetitions. Format: "RankCoordsUpper/Lower,RankCoordsUpper/Lower,..." sorted alphabetically.
         * Example: "1a7,1g3,2b2,..." (Upper = Orange, Lower = Yellow)
         * @param {object} [board=gameState.board] - The board state to stringify. Defaults to current game state.
         * @returns {string} The sorted comma-separated string representation.
         */
        function getBoardStateString(board = gameState.board) {
            const pieces = [];
            // Get coordinates and sort them alphabetically/numerically for consistency
            const coordsList = Object.keys(board).sort((a, b) => {
                // Sort primarily by column, then by row number descending
                const colA = a.charCodeAt(0);
                const colB = b.charCodeAt(0);
                if (colA !== colB) return colA - colB;
                const rowA = parseInt(a.substring(1));
                const rowB = parseInt(b.substring(1));
                return rowB - rowA; // Higher row number (e.g., 9) comes first
            });

            for (const coords of coordsList) {
                const piece = board[coords];
                if (piece) {
                    // Format: Rank followed by Coords. Uppercase coords for Orange, lowercase for Yellow.
                    const stateOutput = piece.player === PLAYERS.ORANGE ?
                        `${piece.rank}${coords.toUpperCase()}` : // e.g., 8A3
                        `${piece.rank}${coords.toLowerCase()}`; // e.g., 7a9
                    pieces.push(stateOutput);
                }
            }
            // Final sort of the generated piece strings ensures the overall string is unique per state
            // pieces.sort(); // This secondary sort might be redundant if coordsList is sorted robustly
            return pieces.join(','); // Join with commas
        }

        /**
         * Parses a board state string into a board object suitable for gameState.board.
         * String format: "RankCoordsUpper/Lower,RankCoordsUpper/Lower,..." (e.g., "8A3,7G1,1a7")
         * Uppercase coords = Orange, Lowercase = Yellow.
         * @param {string} stateString - The board state string to parse.
         * @returns {object|null} A board object { coords: pieceData } or null if parsing fails.
         */
        function parseBoardStateString(stateString) {
            if (!stateString || typeof stateString !== 'string') {
                console.error("Parse Error: Invalid input string.");
                return null;
            }

            const parsedBoard = {};
            const pieceStrings = stateString.trim().split(',');
            const pieceRegex = /^([1-8])([a-gA-G][1-9])$/; // Matches Rank (1-8) and Coords (e.g., a1, G9)

            for (const pieceStr of pieceStrings) {
                if (!pieceStr) continue; // Skip empty parts if trailing comma etc.
                const match = pieceStr.match(pieceRegex);

                if (!match) {
                    console.error(`Parse Error: Invalid piece format "${pieceStr}" in state string.`);
                    return null; // Invalid format for a piece
                }

                const rank = parseInt(match[1], 10);
                const coordsRaw = match[2];
                const coordsLower = coordsRaw.toLowerCase(); // Key for the board object is always lowercase

                // Validate coordinates range after converting to lowercase
                const rc = getRowCol(coordsLower);
                if (!rc) {
                    console.error(`Parse Error: Invalid coordinates "${coordsRaw}" in state string.`);
                    return null;
                }

                // Determine player based on original case
                const player = (coordsRaw === coordsRaw.toUpperCase()) ? PLAYERS.ORANGE : PLAYERS.YELLOW;

                // Create piece data object
                const pieceData = {
                    player: player,
                    rank: rank,
                    isHungry: false // Pieces always start not hungry when loading state
                };

                // Add special abilities based on rank
                const abilities = SPECIAL_ABILITIES[rank];
                if (abilities) {
                    pieceData.swims = abilities.swims || false;
                    pieceData.attacksElephant = abilities.attacksElephant || false;
                    pieceData.jumpH = abilities.jumpH || false;
                    pieceData.jumpV = abilities.jumpV || false;
                } else {
                    pieceData.swims = false; pieceData.attacksElephant = false;
                    pieceData.jumpH = false; pieceData.jumpV = false;
                }

                // Check for duplicate piece placement
                if (parsedBoard[coordsLower]) {
                     console.error(`Parse Error: Duplicate piece placement at "${coordsLower}" in state string.`);
                     return null;
                }

                parsedBoard[coordsLower] = pieceData;
            }

            // Basic sanity check: ensure at least one piece exists? (Optional)
            if (Object.keys(parsedBoard).length === 0 && stateString.length > 0) {
                 console.error("Parse Error: String provided but no valid pieces parsed.");
                 return null;
            }


            console.log("Successfully parsed board state:", parsedBoard);
            return parsedBoard;
        }

        /**
         * Logs the current board state. Displays the human-readable string representation
         * in the UI, but uses the Zobrist hash internally to track repetition counts
         * in `gameState.boardStateHistory`.
         * Increments the count for the current hash unless restoring.
         *
         * @param {boolean} [isRestoring=false] - If true, logs the state but doesn't increment the history count for the hash (used during undo/load).
         * @returns {string} The human-readable board state string.
         */
        function logBoardState(isRestoring = false) {
            // 1. Get the human-readable string for display/copy
            const stateString = getBoardStateString(gameState.board);
            // 2. Get the current Zobrist hash for internal history tracking
            const currentHash = gameState.zobristHash;

            // 3. Update the UI element with the human-readable string
            boardStateLogElement.textContent = stateString;

            // 4. Update the internal boardStateHistory using the Zobrist hash
            if (!isRestoring) {
                // Increment the count for this hash in the history object
                const hashKey = currentHash.toString(); // Use hash string as key
                gameState.boardStateHistory[hashKey] = (gameState.boardStateHistory[hashKey] || 0) + 1;
                console.log(`Board State: ${stateString} (Hash: ${currentHash}, Count: ${gameState.boardStateHistory[hashKey]})`);
            } else {
                console.log(`Restored Board State: ${stateString} (Hash: ${currentHash})`);
                // When restoring, initialize the count for this specific hash state
                const hashKey = currentHash.toString();
                // Only set to 1 if it doesn't exist; otherwise, keep existing count if re-loading same state?
                // For simplicity, let's just set it to 1 on load/undo, assuming we won't loop back immediately.
                gameState.boardStateHistory[hashKey] = 1;
            }

            // Return the human-readable string, as that's most likely useful for external callers now.
            return stateString;
        }

        /**
         * Shows or hides the "(0)" trap rank indicator on a piece's DOM element.
         * Can accept coordinates OR a direct element reference for robustness.
         * @param {string} coords - The coordinates of the piece.
         * @param {boolean} isTrapped - Whether the piece should show the trapped indicator.
         * @param {HTMLElement|null} [element=null] - Optional: Direct reference to the piece element.
         */
        function updateTrapIndicatorVisual(coords, isTrapped, element = null) {
            // Prioritize the passed element reference if available
            const pieceElement = element || document.getElementById(getPieceElementId(coords));
            if (!pieceElement) {
                 // Element might legitimately not exist if piece was captured/starved before update could happen.
                return;
            }

            // Find the indicator span within the piece element
            const indicatorSpan = pieceElement.querySelector('.trap-rank-indicator');
            if (!indicatorSpan) {
                console.warn("Trap indicator span not found for piece at", coords);
                return;
            }

            // Add or remove the 'visible' class based on the isTrapped flag
            if (isTrapped) {
                if (!indicatorSpan.classList.contains('visible')) { // Check before adding
                    indicatorSpan.classList.add('visible');
                }
            } else {
                if (indicatorSpan.classList.contains('visible')) { // Check before removing
                    indicatorSpan.classList.remove('visible');
                }
            }
        }

        /**
         * Adds or removes the 'hungry' class from a piece's DOM element.
         * Can accept coordinates OR a direct element reference.
         * @param {string} coords - The coordinates of the piece (used if element is not provided).
         * @param {boolean} isHungry - Whether the piece should be marked as hungry.
         * @param {HTMLElement|null} [element=null] - Optional: Direct reference to the piece element.
         */
        function updateHungryVisual(coords, isHungry, element = null) { // Added element parameter
            // Prioritize the passed element reference if available
            const pieceElement = element || document.getElementById(getPieceElementId(coords));

            if (pieceElement) {
                if (isHungry) {
                    pieceElement.classList.add('hungry'); // Add red glow
                } else {
                    try {
                         pieceElement.classList.remove('hungry'); // Remove red glow
                    } catch (e) {
                        console.error(`Error removing hungry class from element for ${coords}:`, e, pieceElement);
                    }
                }
            } else {
                 console.warn(`updateHungryVisual: Element not found for ${coords} (even with potential direct reference).`);
            }
        }


        // --- Highlighting & Visual Feedback ---

        /**
         * Highlights valid move and attack squares for a given piece.
         * Adds temporary highlight classes ('valid-move-highlight', 'valid-attack-highlight')
         * and, if `isSelection` is true, applies persistent visual styles ('valid-move', 'valid-attack').
         * Moves blocked by the repetition rule are styled red.
         * @param {string} fromCoords - The coordinates of the piece whose moves to highlight.
         * @param {boolean} [isSelection=true] - If true, apply persistent styles (for click/drag selection).
         *                                      If false, only add highlight classes (for hover).
         */
        function highlightValidMoves(fromCoords, isSelection = true) {
            clearHighlights(); // Clear previous highlights first
            const piece = gameState.board[fromCoords];

             // Don't highlight if no piece or (if selecting) it's not current player's piece
            if (!piece || (isSelection && piece.player !== gameState.currentPlayer)) return;

            // Get all potential destinations (geometrically possible)
            const destinations = getPotentialMoveDestinations(fromCoords, piece);

            destinations.forEach(toCoords => {
                const cell = document.getElementById(getCellElementId(toCoords));
                if (!cell) return; // Skip if cell not found

                // Validate the move legally, including the NEW repetition check
                // Pass a copy of piece data to avoid potential side effects during validation
                const validation = isValidMove(fromCoords, toCoords, { ...piece });

                // --- START: Updated Highlighting Logic ---
                if (validation.valid) {
                    // Standard valid move highlighting (Green)
                    cell.classList.add('valid-move-highlight');
                    if (gameState.board[toCoords]) { // Attack move
                        cell.classList.add('valid-attack-highlight');
                        if (isSelection) cell.classList.add('valid-attack'); // Red for attack target
                    } else { // Non-attack move
                        if (isSelection) cell.classList.add('valid-move'); // Green for empty square
                    }
                     // Make valid destination cells focusable via keyboard nav
                     cell.setAttribute('tabindex', '0');
                } else if (validation.reasonCode === 'REPETITION_RULE') {
                    // Highlight as blocked by repetition (Red)
                     console.log(`Highlighting: ${toCoords} blocked by repetition rule for ${piece.player}.`);
                    cell.classList.add('valid-attack-highlight'); // Use attack class for red border effect
                    if (isSelection) {
                        cell.classList.add('valid-attack'); // Use attack class for red background fill
                    }
                     // Keep blocked cells non-focusable via keyboard
                     cell.setAttribute('tabindex', '-1');
                }
                // --- END: Updated Highlighting Logic ---
            });

            // If this is a selection (not just hover), mark the source piece as selected
            if (isSelection) {
                const pieceEl = document.getElementById(getPieceElementId(fromCoords));
                if (pieceEl) pieceEl.classList.add('selected');
            }
        }

        /**
         * Removes all move/attack highlights and selection styles from cells and pieces.
         * Resets cell tabindex attributes.
         */
        function clearHighlights() {
            // Remove highlight classes from all cells
            boardGridWrapper.querySelectorAll('.cell').forEach(cell => {
                cell.classList.remove('valid-move', 'valid-attack', 'valid-move-highlight', 'valid-attack-highlight');
                 // Reset tabindex for cells (only valid moves should be tabbable temporarily)
                cell.setAttribute('tabindex', '-1');
            });

            // If no piece is currently selected, remove selection style from any piece that might have it
            if (!selectedPieceCoords) {
                boardGridWrapper.querySelectorAll('.piece.selected').forEach(p => p.classList.remove('selected'));
            }
            // Ensure pieces' tabindex is correctly set (only current player's pieces should be 0)
             updateAllPieceAccessibility();

             // Restore tabindex=0 for the currently focused element if focus wasn't lost
            if (focusedCoords) {
                let focusedEl = document.getElementById(getCellElementId(focusedCoords)) || document.getElementById(getPieceElementId(focusedCoords));
                 // Check if the focused element should indeed be focusable
                 const shouldBeFocusable = focusedEl?.classList.contains('piece') && focusedEl?.dataset.player === gameState.currentPlayer && !gameState.gameOver;
                if (focusedEl && shouldBeFocusable) {
                    focusedEl.setAttribute('tabindex', '0');
                } else if (focusedEl && !focusedEl.classList.contains('piece')) {
                     // Cells generally aren't focusable unless a valid move target
                     focusedEl.setAttribute('tabindex', '-1');
                }
            }
        }


        /**
         * Briefly flashes the background color of a cell for visual feedback.
         * @param {string} coords - The coordinates of the cell to flash.
         * @param {string} [color='red'] - The color to flash ('red' or 'green').
         * @param {number} [duration=300] - The total duration of the flash in milliseconds.
         */
        function flashCell(coords, color = 'red', duration = 300) {
            const cell = document.getElementById(getCellElementId(coords));
            if (cell) {
                const originalTransition = cell.style.transition; // Store original transition
                // Apply flash color quickly
                cell.style.transition = `background-color ${duration / 2}ms ease-out`;
                cell.style.backgroundColor = color === 'red' ? 'rgba(255,0,0,0.5)' : 'rgba(0,255,0,0.5)';
                // After half the duration, start fading back to original
                setTimeout(() => {
                    cell.style.backgroundColor = ''; // Remove inline style, revert to CSS background
                    // After fade out, restore original transition property
                    setTimeout(() => {
                        cell.style.transition = originalTransition;
                     }, 50); // Small delay to ensure background removal registers before transition change
                }, duration / 2);
            }
        }

        /**
         * Removes the visual highlighting from the last move squares for a specific player.
         * @param {string} player - The player ('orange' or 'yellow') whose highlights to clear.
         */
        function clearPlayerLastMoveHighlight(player) {
            if (!player || !playerLastMoves[player]) return; // Ensure valid player

            const lastMove = playerLastMoves[player];
            // console.log(`Clearing highlights for ${player}:`, lastMove); // Debug log

            // Function to remove classes from a cell if it exists
            const removeClasses = (coords) => {
                if (!coords) return;
                const cell = document.getElementById(getCellElementId(coords));
                if (cell) {
                    cell.classList.remove('last-move-from', 'last-move-to', `${player}-last-move`);
                }
            };

            removeClasses(lastMove.from);
            removeClasses(lastMove.to);
        }

        /**
         * Highlights the starting and ending squares of the last known moves for both players.
         */
        function highlightLastMoves() {
            // console.log("Highlighting last moves:", playerLastMoves); // Debug log

            // Clear ALL existing highlights first to prevent conflicts
             boardGridWrapper.querySelectorAll('.cell.last-move-from, .cell.last-move-to, .cell.orange-last-move, .cell.yellow-last-move').forEach(cell => {
                 cell.classList.remove('last-move-from', 'last-move-to', 'orange-last-move', 'yellow-last-move');
             });


            // Apply highlights for each player
            for (const player in playerLastMoves) {
                const move = playerLastMoves[player];
                if (move.from && move.to) {
                    const fromCell = document.getElementById(getCellElementId(move.from));
                    const toCell = document.getElementById(getCellElementId(move.to));

                    if (fromCell) {
                        fromCell.classList.add('last-move-from');
                        fromCell.classList.add(`${player}-last-move`); // Add player class
                    }
                    if (toCell) {
                        toCell.classList.add('last-move-to');
                        toCell.classList.add(`${player}-last-move`); // Add player class
                    }
                }
            }
        }


        // --- Shared Tooltip Logic (Task 25) ---
        let tooltipHideTimeout = null; // Timeout to delay hiding

        /**
         * Shows the shared tooltip positioned near the target element.
         * @param {HTMLElement} targetElement - The element triggering the tooltip (e.g., the move span).
         */
        function showSharedTooltip(targetElement) {
            if (!targetElement || !sharedMoveTooltip) return;
            const tooltipText = targetElement.dataset.tooltip;

            if (!tooltipText) {
                hideSharedTooltip(); // Hide if target has no tooltip data
                return;
            }

            // Clear any pending hide timeout
            if (tooltipHideTimeout) {
                clearTimeout(tooltipHideTimeout);
                tooltipHideTimeout = null;
            }

            // Set text and calculate position
            sharedMoveTooltip.textContent = tooltipText;
            sharedMoveTooltip.style.visibility = 'hidden'; // Keep hidden while calculating size
            sharedMoveTooltip.style.opacity = '0';
            // We need to temporarily make it visible (but off-screen) to measure it accurately
            sharedMoveTooltip.style.top = '-9999px';
            sharedMoveTooltip.style.left = '-9999px';
            sharedMoveTooltip.style.visibility = 'visible'; // Briefly visible for measurement

            const targetRect = targetElement.getBoundingClientRect();
            const tooltipRect = sharedMoveTooltip.getBoundingClientRect(); // Get size *after* setting text

            // Calculate position (prefer above, centered)
            let top = targetRect.top - tooltipRect.height - 8; // Position above target + margin
            let left = targetRect.left + (targetRect.width / 2) - (tooltipRect.width / 2); // Center horizontally

            // Adjust if tooltip goes off-screen top
            if (top < 5) { // Use a small buffer (5px) from the top edge
                top = targetRect.bottom + 8; // Position below instead
            }

            // Adjust if tooltip goes off-screen left/right
            if (left < 5) { // Small buffer from left edge
                left = 5;
            } else if (left + tooltipRect.width > window.innerWidth - 5) { // Small buffer from right edge
                left = window.innerWidth - tooltipRect.width - 5;
            }

            // Apply position and make visible with transition
            sharedMoveTooltip.style.top = `${top}px`;
            sharedMoveTooltip.style.left = `${left}px`;
            // sharedMoveTooltip.style.visibility = 'visible'; // Already set for measurement
            sharedMoveTooltip.style.opacity = '1';
            sharedMoveTooltip.setAttribute('aria-hidden', 'false');
        }

        /**
         * Hides the shared tooltip, potentially with a delay.
         */
        function hideSharedTooltip() {
            // Use a small timeout to prevent flickering when moving mouse
             if (tooltipHideTimeout) clearTimeout(tooltipHideTimeout); // Clear existing timeout

             tooltipHideTimeout = setTimeout(() => {
                 if (sharedMoveTooltip) {
                    sharedMoveTooltip.style.visibility = 'hidden';
                    sharedMoveTooltip.style.opacity = '0';
                    sharedMoveTooltip.setAttribute('aria-hidden', 'true');
                    // Reset position off-screen to prevent interfering with other elements
                    sharedMoveTooltip.style.top = '-9999px';
                    sharedMoveTooltip.style.left = '-9999px';
                 }
                  tooltipHideTimeout = null;
             }, 100); // 100ms delay
        }

        // Add delegated event listeners to the move log container
        if (moveLogElement) {
            // Show on mouseover or focusin
            moveLogElement.addEventListener('mouseover', (event) => {
                const target = event.target.closest('.log-orange[data-tooltip], .log-yellow[data-tooltip]');
                if (target) {
                    showSharedTooltip(target);
                }
            });
            moveLogElement.addEventListener('focusin', (event) => {
                 const target = event.target.closest('.log-orange[data-tooltip], .log-yellow[data-tooltip]');
                if (target) {
                    showSharedTooltip(target);
                }
            });

            // Hide on mouseout or focusout
            moveLogElement.addEventListener('mouseout', (event) => {
                 const target = event.target.closest('.log-orange[data-tooltip], .log-yellow[data-tooltip]');
                 // Hide if mouse moves off the target element, let the delay handle flicker
                 if (target) {
                     hideSharedTooltip();
                 }
            });
            moveLogElement.addEventListener('focusout', (event) => {
                 const target = event.target.closest('.log-orange[data-tooltip], .log-yellow[data-tooltip]');
                 // Hide if focus moves away from a tooltip trigger element
                 if (target) {
                      hideSharedTooltip();
                 }
            });
        }
        // --- End Shared Tooltip Logic ---


        // --- Event Listeners Setup ---
        resetButton.addEventListener('click', () => { handleFirstInteraction(); initializeGame(); }); // Add interaction check
        undoButton.addEventListener('click', () => { handleFirstInteraction(); undoMove(); }); // Add interaction check

// Add Load State listeners (and interaction check)
        const loadStateButton = document.getElementById('load-state-button');
        const boardStateInput = document.getElementById('board-state-input');
        const loadStatusMessage = document.getElementById('load-status-message');
        if (loadStateButton && boardStateInput && loadStatusMessage) {
            loadStateButton.addEventListener('click', () => {
                handleFirstInteraction(); // Register interaction
                // --- START: Restore Load State Logic ---
                const rawStateString = boardStateInput.value;

                if (!rawStateString || rawStateString.trim() === '') {
                    loadStatusMessage.textContent = "Please paste a state string first.";
                    loadStatusMessage.style.color = 'red';
                    return;
                }

                const cleanedStateString = rawStateString
                    .split(',')
                    .map(piece => piece.trim())
                    .filter(piece => piece !== '')
                    .join(',');

                console.log("Raw input:", rawStateString);
                console.log("Cleaned input for parsing:", cleanedStateString);

                const parsedBoard = parseBoardStateString(cleanedStateString);

                if (parsedBoard) {
                    initializeGame(parsedBoard, true); // Pass true for isLoadingFromFile
                    loadStatusMessage.textContent = "Board state loaded successfully!";
                    loadStatusMessage.style.color = '#28a745';
                    boardStateInput.value = '';
                } else {
                    loadStatusMessage.textContent = "Invalid state string format. Please check console for details.";
                    loadStatusMessage.style.color = 'red';
                    boardStateInput.style.borderColor = 'red';
                    setTimeout(() => { boardStateInput.style.borderColor = 'var(--medium-gray)'; }, 2000);
                }
                // --- END: Restore Load State Logic ---
            });
            boardStateInput.addEventListener('focus', () => { isLoadStateInputFocused = true; console.log("Load state input focused, game keyboard shortcuts disabled."); }); // Keep focus handlers
            boardStateInput.addEventListener('blur', () => { isLoadStateInputFocused = false; console.log("Load state input blurred, game keyboard shortcuts enabled."); }); // Keep focus handlers
        } else {
             console.error("Could not find Load State button, input field, or status message element.");
        }

        // Add Accordion listeners (and interaction check)
        const rulesButton = document.getElementById('rules-toggle-button');
        const rulesContent = document.getElementById('rules-content');
        if (rulesButton && rulesContent) {
            rulesButton.addEventListener('click', () => {
                 handleFirstInteraction(); // Register interaction
                 // --- START: Restore Accordion Logic ---
                 const isExpanded = rulesButton.getAttribute('aria-expanded') === 'true';

                 rulesButton.setAttribute('aria-expanded', !isExpanded);
                 rulesContent.setAttribute('aria-hidden', isExpanded);

                 rulesButton.classList.toggle('active');
                 rulesContent.classList.toggle('expanded');

                 if (!isExpanded) {
                     rulesContent.style.maxHeight = rulesContent.scrollHeight + 'px';
                     const buttonTextSpan = rulesButton.querySelector('.rules-button-text');
                     if(buttonTextSpan) buttonTextSpan.textContent = 'Hide Game Rules';
                 } else {
                     rulesContent.style.maxHeight = null;
                     const buttonTextSpan = rulesButton.querySelector('.rules-button-text');
                     if(buttonTextSpan) buttonTextSpan.textContent = 'Show Game Rules';
                 }
                 // --- END: Restore Accordion Logic ---
            });
        } else {
            console.warn("Rules accordion button or content not found.");
        }

        // Add PvP toggle listener (and interaction check)
        const pvpToggleButton = document.getElementById('pvp-toggle');
        if (pvpToggleButton) {
            pvpToggleButton.addEventListener('change', (event) => {
                handleFirstInteraction(); // Register interaction
                // --- START: Restore PvP Toggle Logic ---
                isPlayerVsPlayerMode = event.target.checked;
                console.log(`Player vs Player mode ${isPlayerVsPlayerMode ? 'ENABLED' : 'DISABLED'}`);
                if (aiMoveTimeoutId) { clearTimeout(aiMoveTimeoutId); aiMoveTimeoutId = null; }

                pauseAllClocks(); // Pause during switch

                if (isPlayerVsPlayerMode) {
                    console.log("PvP Mode ACTIVE: Ensuring player interaction is enabled.");
                    enablePlayerInteraction();
                    updateStatus(`${gameState.currentPlayer.toUpperCase()}'s turn (PvP Mode)`);
                    resumeClockForCurrentPlayer();
                    playTurnSound();
                } else {
                    // Switching TO PvE
                    if (gameState.currentPlayer === PLAYERS.YELLOW && !gameState.gameOver) {
                        console.log("PvE Mode ACTIVE and Yellow's turn: Disabling interaction, scheduling AI move.");
                        disablePlayerInteraction();
                        undoButton.disabled = true;
                        startClock(PLAYERS.YELLOW);
                        playTurnSound();
                        aiMoveTimeoutId = setTimeout(triggerAIMove, 100); // Using 0.1 sec delay for UI to update
                    } else {
                        console.log("PvE Mode ACTIVE and Orange's turn: Ensuring player interaction is enabled.");
                        enablePlayerInteraction();
                        resumeClockForCurrentPlayer();
                        playTurnSound();
                    }
                }

                updateAllPieceAccessibility();
                updateUndoButtonState();
                 // --- END: Restore PvP Toggle Logic ---
            });
        } else {
            console.warn("PvP toggle button not found.");
        }


        // --- START: Add Audio Control Event Listeners ---
        // Function to load settings from localStorage
        function loadAudioSettings() {
            // Load Music Volume (Slider position 0-1)
            const savedSliderPosition = localStorage.getItem('clestoMusicVolume');
            // *** CHANGE DEFAULT SLIDER POSITION HERE ***
            // Default slider position to 50% (0.5) if nothing is saved
            const initialSliderPosition = (savedSliderPosition !== null) ? parseFloat(savedSliderPosition) : 0.5; // Changed default to 0.5

            if (musicVolumeSlider && backgroundMusicElement) {
                // Set the slider's visual position
                musicVolumeSlider.value = initialSliderPosition;

                // *** CHANGE ACTUAL VOLUME SCALING HERE ***
                // Calculate and set the *actual* audio volume (scaled down to max 10%)
                const actualVolume = initialSliderPosition * 0.1; // Scale slider value by 10%
                backgroundMusicElement.volume = actualVolume;

                 // Update display based on the *slider's* position (0-100%)
                 if (musicVolumeDisplay) {
                     musicVolumeDisplay.textContent = `${Math.round(initialSliderPosition * 100)}%`;
                 }
                console.log(`Music volume slider initialized to ${initialSliderPosition * 100}%, actual audio volume set to ${actualVolume}`);
            }

            // Load SFX Toggle State (remains the same)
            const savedSfxState = localStorage.getItem('clestoSfxEnabled');
            soundEffectsEnabled = (savedSfxState !== null) ? (savedSfxState === 'true') : true;
            if (sfxToggleCheckbox) {
                sfxToggleCheckbox.checked = soundEffectsEnabled;
                console.log(`Sound effects initialized to ${soundEffectsEnabled ? 'ENABLED' : 'DISABLED'}`);
            }
        }

        // Music Volume Slider Listener
        if (musicVolumeSlider && backgroundMusicElement) {
            musicVolumeSlider.addEventListener('input', (event) => {
                // Get the slider's current position (0 to 1)
                const sliderPosition = parseFloat(event.target.value);

                // *** CHANGE ACTUAL VOLUME SCALING HERE ***
                // Calculate the actual volume to apply (max 10%)
                const actualVolume = sliderPosition * 0.1; // Scale slider value by 10%
                backgroundMusicElement.volume = actualVolume;

                // Save the *slider's* position (0-1) to localStorage
                localStorage.setItem('clestoMusicVolume', sliderPosition.toString());

                 // Update display based on the *slider's* position (0-100%)
                 if (musicVolumeDisplay) {
                     musicVolumeDisplay.textContent = `${Math.round(sliderPosition * 100)}%`;
                 }
                // console.log(`Slider at ${sliderPosition * 100}%, actual audio volume ${actualVolume}`);
                 handleFirstInteraction(); // Ensure music attempts to play if user adjusts volume first
            });
        } else {
             console.warn("Music volume slider or background music element not found.");
        }

        // SFX Toggle Listener
        if (sfxToggleCheckbox) {
            sfxToggleCheckbox.addEventListener('change', (event) => {
                soundEffectsEnabled = event.target.checked;
                localStorage.setItem('clestoSfxEnabled', soundEffectsEnabled.toString()); // Save preference
                console.log(`Sound effects toggled to ${soundEffectsEnabled ? 'ENABLED' : 'DISABLED'}`);
                handleFirstInteraction(); // Register interaction
            });
        } else {
             console.warn("SFX toggle checkbox not found.");
        }
        // --- END: Add Audio Control Event Listeners ---


        // --- Initial Game Setup ---
        console.log("Initializing Clesto Game...");
        loadAudioSettings(); // Load audio settings BEFORE initializing game
        initializeGame();
        console.log("Game setup complete. Board and UI ready.");

        // Note: Background music attempts to start after first user interaction via handleFirstInteraction()

    }); // End window.load event listener
    </script>

</body>

</html>