<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Play Clesto, the Jungle Chess game online. A strategy board game with unique animal movements and rules.">
    <title>CLESTO: The Jungle Chess Game</title>

    <!-- Preload key visual assets -->
    <link rel="preload" as="image" href="https://staticjw.com/clesto/board.png">
    <link rel="preload" as="image" href="https://staticjw.com/clesto/animals/elephant-orange.png">
    <link rel="preload" as="image" href="https://staticjw.com/clesto/animals/lion-orange.png">
    <link rel="preload" as="image" href="https://staticjw.com/clesto/animals/elephant-yellow.png">
    <link rel="preload" as="image" href="https://staticjw.com/clesto/animals/lion-yellow.png">

    <style>
        /* --- Global Variables & Basic Setup --- */
        :root {
            /* Player Colors */
            --orange-color: #E67E22;
            --yellow-color: #F1C40F;
            --dark-orange: #D35400;
            --dark-yellow: #F39C12;

            /* UI Colors */
            --light-gray: #f8f9fa;
            --medium-gray: #dee2e6;
            --dark-gray: #343a40;

            /* Highlight & Feedback Colors */
            --cell-highlight-move: rgba(0, 255, 0, 0.7);
            /* Green for valid move */
            --cell-highlight-attack: rgba(255, 0, 0, 0.7);
            /* Red for valid attack */
            --cell-highlight-repetition: rgba(255, 165, 0, 0.7); /* Orange for repetition block */
            --piece-select-glow: rgba(0, 191, 255, 0.9);
            /* Blue glow for selected piece */
            --hungry-outline: rgba(255, 0, 0, 0.8);
            /* Dashed red outline for hungry pieces */
            --last-move-from-bg: rgba(0, 0, 255, 0.15);
            /* Light blue for last move start */
            --last-move-to-bg: rgba(0, 0, 255, 0.3);
            /* Darker blue for last move end */
            --focus-outline: 2px solid #007bff;
            /* Standard focus indicator */

            /* Layout Dimensions */
            --board-max-width: 490px;
            --ui-max-width: 300px;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: var(--light-gray);
            color: var(--dark-gray);
            padding: 10px;
            margin: 0;
            box-sizing: border-box;
            width: 100%;
            min-height: 100vh;
        }

        h1 {
            margin-top: 10px;
            margin-bottom: 15px;
            color: var(--dark-gray);
            font-weight: 300;
            border-bottom: 1px solid var(--medium-gray);
            padding-bottom: 10px;
            font-size: 1.8em;
            text-align: center;
            width: 100%;
            max-width: calc(var(--board-max-width) + var(--ui-max-width) + 40px);
        }

        main {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            margin-top: 10px;
            width: 100%;
            max-width: calc(var(--board-max-width) + var(--ui-max-width) + 40px);
            box-sizing: border-box;
        }

        /* --- Board Styling --- */
        #board {
            width: var(--board-max-width);
            max-width: 100%;
            aspect-ratio: 7 / 9;
            height: auto;
            border: none;
            position: relative;
            background-image: url('https://staticjw.com/clesto/board.png');
            background-size: cover;
            background-position: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
            border-radius: 5px;
            outline: none;
            box-sizing: border-box;
            padding: 21px 17px;
            overflow: hidden;
        }

        #board-grid-wrapper {
            width: 100%;
            height: 100%;
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            grid-template-rows: repeat(9, 1fr);
            position: relative;
            outline: none;
        }

        #board:focus {
            box-shadow: 0 0 0 3px var(--focus-outline);
        }

        .cell {
            width: 100%;
            height: 100%;
            border: none;
            box-sizing: border-box;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.6em;
            color: rgba(0, 0, 0, 0.3);
            user-select: none;
            background-clip: padding-box;
            transition: background-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            outline: none;
        }

        .cell:focus {
            box-shadow: inset 0 0 0 3px var(--focus-outline);
            z-index: 5;
        }

        .cell::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            box-sizing: border-box;
            border-radius: inherit;
            opacity: 0.8;
        }

        /* Specific terrain styles using the ::before pseudo-element */
        .water::before {
            background-color: rgba(100, 150, 255, 0.3);
        }

        .trap-orange::before {} /* Traps near Orange Den */
        .trap-yellow::before {} /* Traps near Yellow Den */
        .den-orange::before {}
        .den-yellow::before {}

        /* Highlighting for last move */
        .last-move-from {
            background-color: var(--last-move-from-bg) !important;
        }

        .last-move-to {
            background-color: var(--last-move-to-bg) !important;
        }

        /* --- Piece Styling --- */
        .piece {
            width: 12.07%;
            aspect-ratio: 1 / 1;
            height: auto;
            position: absolute;
            left: 0;
            top: 0;
            cursor: grab;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.25);
            z-index: 10;
            transition: transform 0.3s ease-in-out, box-shadow 0.2s ease, outline 0.2s ease, left 0.3s ease-in-out, top 0.3s ease-in-out;
            user-select: none;
            overflow: visible;
            background: none;
            border: none;
            border-radius: 50%;
            outline: none;
            touch-action: none;
        }

        .piece img {
            width: 100%;
            height: 100%;
            display: block;
            object-fit: contain;
            pointer-events: none;
            border-radius: 50%;
        }

        .piece:focus {
            outline: 3px solid var(--focus-outline);
            outline-offset: 1px;
            z-index: 15;
        }

        .piece.dragging {
            opacity: 0.6;
            cursor: grabbing;
            z-index: 100;
            transform: scale(1.1);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            transition: transform 0.15s ease-out, box-shadow 0.2s ease, outline 0.2s ease;
        }

        .piece.captured {
            animation: capture-animation 0.4s ease-out forwards;
        }

        /* --- Trap Rank Indicator Styling --- */
        .trap-rank-indicator {
            position: absolute;
            top: -2px;
            left: 0;
            width: 100%;
            text-align: center;
            font-size: 0.75em;
            font-weight: bold;
            color: white;
            background-color: rgba(200, 0, 0, 0.75);
            border-radius: 3px;
            padding: 0 2px;
            z-index: 1;
            pointer-events: none;
            display: none;
            box-sizing: border-box;
            user-select: none;
        }

        .trap-rank-indicator.visible {
            display: block;
        }

        @keyframes capture-animation {
            0% { transform: scale(1); opacity: 1; }
            100% { transform: scale(0.5); opacity: 0; }
        }

        /* --- Visual Feedback --- */
        .valid-move {
            box-shadow: inset 0 0 0 3px var(--cell-highlight-move);
            background-color: rgba(0, 255, 0, 0.1);
        }

        .valid-attack {
            box-shadow: inset 0 0 0 3px var(--cell-highlight-attack);
            background-color: rgba(255, 0, 0, 0.1);
        }

        /* New style for repetition blocked moves */
        .repetition-blocked {
            box-shadow: inset 0 0 0 3px var(--cell-highlight-repetition); /* Orange outline */
            background-color: rgba(255, 165, 0, 0.1); /* Light orange background */
            cursor: not-allowed; /* Indicate move is forbidden */
        }


        .selected {
            outline: 3px solid var(--piece-select-glow);
            outline-offset: 1px;
            z-index: 16;
        }

        .hungry {
            box-shadow: 0 0 0 3px var(--hungry-outline);
        }

        @keyframes hungry-pulse {
            0% { box-shadow: 0 0 0 3px var(--hungry-outline); }
            50% { box-shadow: 0 0 0 5px rgba(255, 0, 0, 0.5); }
            100% { box-shadow: 0 0 0 3px var(--hungry-outline); }
        }

        /* --- UI Info Panel Styling --- */
        #ui-info-section {
            width: var(--ui-max-width);
            max-width: 100%;
            border: none;
            padding: 20px;
            background-color: #ffffff;
            height: fit-content;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
        }

        #ui-info-section h2,
        #ui-info-section h3 {
            margin-top: 0;
            margin-bottom: 15px;
            border-bottom: 1px solid var(--medium-gray);
            padding-bottom: 8px;
            font-weight: 400;
            color: var(--dark-gray);
        }

        #ui-info-section h3 {
            margin-top: 15px;
        }

        #ui-info-section p {
            margin: 10px 0;
            line-height: 1.5;
        }

        #turn-indicator {
            font-weight: 600;
            padding: 3px 6px;
            border-radius: 4px;
            color: white;
        }

        #turn-indicator.orange { background-color: var(--orange-color); }
        #turn-indicator.yellow { background-color: var(--yellow-color); color: var(--dark-gray); }
        #turn-indicator.game-over { background-color: #dc3545; }

        #status-message { min-height: 1.5em; }

        /* --- Buttons --- */
        .button-container {
            padding-top: 10px;
            margin-bottom: 15px;
            display: flex;
            gap: 10px;
            justify-content: space-around;
            flex-wrap: wrap;
        }

        .game-button {
            padding: 10px 18px;
            cursor: pointer;
            border-radius: 5px;
            border: none;
            font-size: 0.95em;
            transition: background-color 0.2s ease, box-shadow 0.2s ease;
            background-color: #6c757d;
            color: white;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            outline: none;
            margin-bottom: 5px;
        }

        .game-button:hover { box-shadow: 0 3px 6px rgba(0, 0, 0, 0.15); }
        .game-button:focus-visible { box-shadow: 0 0 0 3px var(--focus-outline); }

        #reset-button { background-color: #007bff; }
        #reset-button:hover { background-color: #0056b3; }
        #undo-button { background-color: #ffc107; color: var(--dark-gray); }
        #undo-button:hover { background-color: #e0a800; }
        #undo-button:disabled { background-color: #adb5bd; cursor: not-allowed; box-shadow: none; }

        /* --- PvP Toggle Switch Styling --- */
        .pvp-toggle-container {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-top: 8px;
            margin-bottom: 8px;
            padding: 5px 0;
        }
        .pvp-label { margin-right: 10px; font-weight: 500; font-size: 0.95em; }
        .switch { position: relative; display: inline-block; width: 50px; height: 24px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; }
        .slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px; background-color: white; transition: .4s; }
        input:checked + .slider { background-color: var(--orange-color); }
        input:focus + .slider { box-shadow: 0 0 1px var(--orange-color); }
        input:focus-visible + .slider { outline: 2px solid var(--focus-outline); outline-offset: 1px; }
        input:checked + .slider:before { transform: translateX(26px); }
        .slider.round { border-radius: 24px; }
        .slider.round:before { border-radius: 50%; }

        /* --- Logs --- */
        #move-log {
            height: 220px;
            overflow-y: auto;
            border: 1px solid var(--medium-gray);
            border-radius: 5px;
            padding: 8px 10px;
            margin-top: 10px;
            font-size: 0.9em;
            background-color: #ffffff;
            line-height: 1.6;
        }
        .log-entry { padding: 3px 0; border-bottom: 1px dashed var(--medium-gray); }
        .log-entry:last-child { border-bottom: none; }
        .log-entry .turn-number { display: inline-block; width: 25px; font-weight: bold; color: #6c757d; margin-right: 5px; }
        .log-entry .log-orange, .log-entry .log-yellow { display: inline-block; min-width: 60px; padding: 2px 5px; border-radius: 3px; margin: 0 3px; text-align: center; }
        .log-entry .log-orange { background-color: rgba(230, 126, 34, 0.15); color: var(--dark-orange); border: 1px solid rgba(230, 126, 34, 0.3); }
        .log-entry .log-yellow { background-color: rgba(241, 196, 15, 0.15); color: #c78b02; border: 1px solid rgba(241, 196, 15, 0.3); }
        .log-entry .placeholder { color: #adb5bd; font-style: italic; display: inline-block; min-width: 60px; text-align: center; }

        #board-state-log {
            margin-top: 10px;
            border: 1px solid var(--medium-gray);
            border-radius: 5px;
            padding: 10px;
            font-size: 0.75em;
            font-family: monospace;
            word-wrap: break-word;
            background-color: #ffffff;
            max-height: 90px;
            overflow-y: auto;
            line-height: 1.4;
        }

        /* --- Debug Log Section Styling (Optional) --- */
        #debug-log-container {
            width: 100%;
            max-width: calc(var(--board-max-width) + var(--ui-max-width) + 40px);
            margin-top: 20px;
            padding: 15px;
            background-color: #f1f3f5;
            border: 1px solid var(--medium-gray);
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            box-sizing: border-box;
        }
        #debug-log-container h2 { margin-top: 0; margin-bottom: 10px; font-weight: 400; border-bottom: 1px solid var(--medium-gray); padding-bottom: 5px; font-size: 1.2em; }
        #debug-log-output { height: 200px; max-height: 40vh; overflow-y: auto; background-color: #ffffff; border: 1px solid var(--medium-gray); border-radius: 3px; padding: 8px; font-family: monospace; font-size: 0.8em; white-space: pre-wrap; word-break: break-word; line-height: 1.4; }
        .debug-log-entry { padding: 2px 0; border-bottom: 1px dashed #e9ecef; }
        .debug-log-entry:last-child { border-bottom: none; }
        .debug-log-timestamp { color: #6c757d; margin-right: 8px; }
        .debug-log-warn { color: #fd7e14; }
        .debug-log-error { color: #dc3545; font-weight: bold; }
        .debug-hidden { display: none; }

        /* --- Rules Accordion Styling --- */
        #rules-accordion-container { width: 100%; max-width: calc(var(--board-max-width) + var(--ui-max-width) + 40px); margin: 15px auto 15px auto; border: 1px solid var(--medium-gray); border-radius: 5px; overflow: hidden; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05); box-sizing: border-box; background-color: #f8f9fa; }
        .rules-toggle-button { background-color: #e9ecef; color: var(--dark-gray); cursor: pointer; padding: 12px 18px; width: 100%; border: none; text-align: left; outline: none; font-size: 1.1em; transition: background-color 0.3s ease; display: flex; justify-content: space-between; align-items: center; font-weight: 500; }
        .rules-toggle-button:hover, .rules-toggle-button.active { background-color: #dee2e6; }
        .rules-toggle-button:focus-visible { box-shadow: 0 0 0 3px var(--focus-outline); z-index: 1; position: relative; }
        .rules-icon { font-size: 1.2em; font-weight: bold; transition: transform 0.3s ease; }
        .rules-toggle-button.active .rules-icon { transform: rotate(45deg); }
        .rules-content { padding: 0 18px; background-color: white; max-height: 0; overflow: hidden; transition: max-height 0.3s ease-out, padding 0.3s ease-out; border-top: 1px solid var(--medium-gray); }
        .rules-content.expanded { padding: 15px 18px; }
        .rules-content h3 { margin-top: 15px; margin-bottom: 8px; color: var(--dark-orange); border-bottom: 1px solid var(--medium-gray); padding-bottom: 4px; }
        .rules-content h3:first-child { margin-top: 0; }
        .rules-content h4 { margin-top: 12px; margin-bottom: 5px; color: var(--dark-gray); }
        .rules-content p, .rules-content ul, .rules-content ol { margin-bottom: 10px; line-height: 1.6; }
        .rules-content ul, .rules-content ol { padding-left: 25px; }
        .rules-content ul ul, .rules-content ol ol, .rules-content ul ol, .rules-content ol ul { margin-bottom: 5px; }
        .rules-content li { margin-bottom: 5px; }
        .rules-content strong { font-weight: 600; }

        /* --- Mobile Responsiveness --- */
        @media (max-width: 850px) {
            body { padding: 5px; }
            h1 { font-size: 1.5em; margin-bottom: 10px; }
            main { flex-direction: column; align-items: center; gap: 15px; padding: 0 5px; max-width: 100%; }
            #board { width: 95vw; max-width: var(--board-max-width); padding: 10px 8px; order: 1; }
            #ui-info-section { width: 95vw; max-width: var(--board-max-width); order: 2; }
            #move-log { height: 150px; }
            #board-state-log { max-height: 60px; }
            .button-container { padding-top: 10px; }
            .game-button { padding: 8px 12px; font-size: 0.9em; }
            #debug-log-container { margin-top: 15px; width: 95vw; max-width: var(--board-max-width); }
            #debug-log-output { height: 150px; }
        }
        .visually-hidden { position: absolute; width: 1px; height: 1px; margin: -1px; padding: 0; overflow: hidden; clip: rect(0, 0, 0, 0); border: 0; }
    </style>
</head>

<body>

    <h1>CLESTO: The Jungle Chess Game</h1>

    <main id="game-container" role="main">
        <!-- Game Board Section -->
        <section aria-labelledby="board-label">
            <h2 id="board-label" class="visually-hidden">Game Board</h2>
            <div id="board" tabindex="0"> <!-- Outer container for board background/focus -->
                <div id="board-grid-wrapper"> <!-- Inner container for grid layout and pieces -->
                    <!-- Cells will be generated by JavaScript here -->
                </div>
            </div>
        </section>

        <!-- UI and Information Section -->
        <section id="ui-info-section" role="region" aria-labelledby="ui-info-heading">
            <h2 id="ui-info-heading">Game Info</h2>
            <p>Turn: <span id="turn-indicator">Orange</span></p>
            <p>Status: <span id="status-message" aria-live="polite">Loading...</span></p>

            <!-- Player vs Player Toggle -->
            <div class="pvp-toggle-container">
                <label for="pvp-toggle" class="pvp-label">Player vs Player Mode:</label>
                <label class="switch">
                    <input type="checkbox" id="pvp-toggle">
                    <span class="slider round"></span>
                </label>
            </div>

            <div class="button-container">
                <button id="undo-button" class="game-button" disabled>Undo Turn</button>
                <button id="reset-button" class="game-button">Reset Game</button>
            </div>

            <h3>Move Log</h3>
            <div id="move-log" role="log" aria-live="polite" aria-atomic="false">
                <!-- Log entries will be added by JavaScript here -->
            </div>

            <h3>Board State</h3>
            <div id="board-state-log">
                <!-- Board state string for debugging/repetition check -->
            </div>

            <!-- Load From State Section -->
            <div style="margin-top: 15px; border-top: 1px solid var(--medium-gray); padding-top: 10px;">
                <label for="board-state-input" style="display: block; margin-bottom: 5px; font-weight: bold;">Load From State String:</label>
                <input type="text" id="board-state-input" placeholder="Paste state string (e.g., 8G7, 7A9,...)" style="width: calc(100% - 12px); padding: 6px; margin-bottom: 8px; border: 1px solid var(--medium-gray); border-radius: 3px;">
                <button id="load-state-button" class="game-button" style="background-color: #28a745;">Load State</button> <!-- Green button -->
                <p id="load-status-message" style="font-size: 0.85em; color: #6c757d; min-height: 1.2em; margin-top: 5px;"></p>
            </div>
            <!-- End Load From State Section -->
        </section>
    </main>

    <!-- Rules Accordion Section -->
    <section id="rules-accordion-container" aria-labelledby="rules-heading">
        <button id="rules-toggle-button" class="rules-toggle-button" aria-expanded="false" aria-controls="rules-content">
            <span class="rules-button-text">Show Game Rules</span>
            <span class="rules-icon" aria-hidden="true">+</span>
        </button>
        <div id="rules-content" class="rules-content" role="region" aria-hidden="true">
            <h2 id="rules-heading" class="visually-hidden">Game Rules</h2>

            <h3>Objective</h3>
            <p>Be the first player to move any of your animals into the opponent's <strong>Den</strong> square.</p>
            <ul>
                <li>Orange's Den: <strong>d1</strong></li>
                <li>Yellow's Den: <strong>d9</strong></li>
            </ul>

            <h3>Gameplay</h3>
            <ul>
                <li>Orange starts the game.</li>
                <li>Players take turns moving one animal per turn.</li>
                <li>Animals move one square horizontally or vertically (never diagonally).</li>
                <li>You cannot move onto a square occupied by your own animal.</li>
            </ul>

            <h4>Attacking</h4>
            <ul>
                <li>You can move onto a square occupied by an opponent's animal if your animal's rank is <strong>equal to or higher than</strong> the opponent's rank.</li>
                <li>This is an attack, and the opponent's captured animal is removed from the board.</li>
                <li><strong>Exception:</strong> See Special Powers for Rat vs. Elephant.</li>
            </ul>

            <h4>End of Turn Sequence</h4>
            <p>After making your move, the following checks happen automatically:</p>
            <ol>
                <li><strong>Declare Hungry:</strong> Any of the <em>opponent's</em> animals that can now make a valid attack are marked as <strong>hungry</strong> (red glow).</li>
                <li><strong>Check Starvation:</strong> If any of <em>your own</em> animals were marked as hungry at the <em>start</em> of your turn, but you did not make an attacking move with any of them, those hungry animals starve and are removed from the board.</li>
            </ol>

            <h4>Special Squares</h4>
            <ul>
                <li><strong>Den:</strong> Your own Den (Orange: d1, Yellow: d9) cannot be entered by your pieces. Reaching the opponent's Den wins the game. A <strong>hungry</strong> animal cannot enter the opponent's Den.</li>
                <li><strong>Water (b4-c6, e4-f6):</strong> Only specific animals can enter or move on water (see Special Powers).</li>
                <li><strong>Traps:</strong>
                    <ul>
                        <li>Traps near Orange Den (affect Yellow): <strong>c1, d2, e1</strong></li>
                        <li>Traps near Yellow Den (affect Orange): <strong>c9, d8, e9</strong></li>
                    </ul>
                    Any animal landing on an opponent's Trap square has its rank effectively reduced to <strong>0</strong> for the purpose of being attacked while on that square. A "(0)" marker appears above trapped animals. However, an animal attacking <em>from</em> a trap square uses its normal rank.
                 </li>
            </ul>

            <h4>Other Rules</h4>
            <ul>
                <li>You must make a move each turn (passing is not allowed).</li>
                <li>The game cannot end in a draw by stalemate (the player unable to move loses).</li> <!-- Updated Stalemate Rule -->
            </ul>

            <h3>Special Powers</h3>
            <ul>
                <li><strong>Rat [1]:</strong>
                    <ul>
                        <li>Can enter, move on, and <strong>attack from Water</strong> squares.</li>
                        <li>Can attack the <strong>Elephant [8]</strong>, but only when attacking from a land square (cannot attack Elephant when starting from Water).</li>
                    </ul>
                 </li>
                 <li><strong>Dog [3]:</strong>
                    <ul>
                         <li>Can enter, move on, and <strong>attack from Water</strong> squares.</li>
                    </ul>
                 </li>
                 <li><strong>Lion [7] and Tiger [6]:</strong>
                    <ul>
                        <li>Can <strong>jump</strong> horizontally or vertically over <strong>Water</strong> squares.</li>
                        <li>A jump moves from a land square directly across 2 or 3 water squares to another land square.</li>
                        <li>Jumps can be used to move or attack.</li>
                        <li>A jump is blocked if an opponent's swimming animal (Rat or Dog) occupies any water square along the jump path.</li>
                    </ul>
                </li>
                 <li><strong>Leopard [5]:</strong>
                    <ul>
                        <li>Can <strong>jump horizontally</strong> over <strong>Water</strong> squares (across 2 water squares).</li>
                        <li>Cannot jump vertically.</li>
                        <li>Jumps follow the same blocking rules as Lion/Tiger.</li>
                    </ul>
                </li>
                <li><strong>Elephant [8]:</strong> Can attack the Rat [1].</li>
            </ul>

            <h3>Repetition Limit</h3>
            <p>To prevent endless loops and ensure a winner, a repetition rule exists:</p>
            <ul>
                <li>Determine which player currently has more animals on the board. If tied, the starting player (Orange) is considered the "leading player".</li>
                <li>The leading player is <strong>not allowed</strong> to make a move that results in a board position that has already occurred <strong>3 times</strong> previously during the game. Attempting such a move is illegal, and the move destination will be marked red.</li>
            </ul>
            <p><em>(Board positions are tracked automatically.)</em></p>

        </div><!-- /#rules-content -->
    </section><!-- /#rules-accordion-container -->

    <!-- Debug Log Section (conditionally displayed) -->
    <section id="debug-log-container" aria-labelledby="debug-log-heading">
        <h2 id="debug-log-heading">Debug Log</h2>
        <div id="debug-log-output">
            <!-- Console messages mirrored here if debug = true -->
        </div>
        <button id="clear-debug-log" class="game-button" style="margin-top: 10px; background-color: #dc3545;">Clear Log</button>
    </section>

    <!-- Hidden container for preloading/caching piece image assets -->
    <div id="piece-assets" style="display: none;">
        <!-- Orange Pieces -->
        <img data-piece="O_8" src="https://staticjw.com/clesto/animals/elephant-orange.png" alt="Orange Elephant (8)" loading="lazy">
        <img data-piece="O_7" src="https://staticjw.com/clesto/animals/lion-orange.png" alt="Orange Lion (7)" loading="lazy">
        <img data-piece="O_6" src="https://staticjw.com/clesto/animals/tiger-orange.png" alt="Orange Tiger (6)" loading="lazy">
        <img data-piece="O_5" src="https://staticjw.com/clesto/animals/leopard-orange.png" alt="Orange Leopard (5)" loading="lazy">
        <img data-piece="O_4" src="https://staticjw.com/clesto/animals/wolf-orange.png" alt="Orange Wolf (4)" loading="lazy">
        <img data-piece="O_3" src="https://staticjw.com/clesto/animals/dog-orange.png" alt="Orange Dog (3)" loading="lazy">
        <img data-piece="O_2" src="https://staticjw.com/clesto/animals/cat-orange.png" alt="Orange Cat (2)" loading="lazy">
        <img data-piece="O_1" src="https://staticjw.com/clesto/animals/rat-orange.png" alt="Orange Rat (1)" loading="lazy">
        <!-- Yellow Pieces -->
        <img data-piece="Y_8" src="https://staticjw.com/clesto/animals/elephant-yellow.png" alt="Yellow Elephant (8)" loading="lazy">
        <img data-piece="Y_7" src="https://staticjw.com/clesto/animals/lion-yellow.png" alt="Yellow Lion (7)" loading="lazy">
        <img data-piece="Y_6" src="https://staticjw.com/clesto/animals/tiger-yellow.png" alt="Yellow Tiger (6)" loading="lazy">
        <img data-piece="Y_5" src="https://staticjw.com/clesto/animals/leopard-yellow.png" alt="Yellow Leopard (5)" loading="lazy">
        <img data-piece="Y_4" src="https://staticjw.com/clesto/animals/wolf-yellow.png" alt="Yellow Wolf (4)" loading="lazy">
        <img data-piece="Y_3" src="https://staticjw.com/clesto/animals/dog-yellow.png" alt="Yellow Dog (3)" loading="lazy">
        <img data-piece="Y_2" src="https://staticjw.com/clesto/animals/cat-yellow.png" alt="Yellow Cat (2)" loading="lazy">
        <img data-piece="Y_1" src="https://staticjw.com/clesto/animals/rat-yellow.png" alt="Yellow Rat (1)" loading="lazy">
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Debug Flag ---
            const debug = true; // SET TO true TO SHOW DEBUG PANEL, false TO HIDE

            // --- DOM Element References ---
            const boardElement = document.getElementById('board');
            const boardGridWrapper = document.getElementById('board-grid-wrapper');
            const turnIndicator = document.getElementById('turn-indicator');
            const statusMessage = document.getElementById('status-message');
            const resetButton = document.getElementById('reset-button');
            const undoButton = document.getElementById('undo-button');
            const moveLogElement = document.getElementById('move-log');
            const boardStateLogElement = document.getElementById('board-state-log');
            const pieceAssetContainer = document.getElementById('piece-assets');
            const debugLogContainer = document.getElementById('debug-log-container');
            const debugLogOutput = document.getElementById('debug-log-output');
            const clearDebugLogButton = document.getElementById('clear-debug-log');
            const boardStateInput = document.getElementById('board-state-input'); // For keyboard disable check

            // --- Console Override & Debug Panel Logic ---
            const originalConsole = { log: console.log, warn: console.warn, error: console.error };
            function formatArgs(args) {
                const seen = new Set();
                return Array.from(args).map(arg => {
                    if (typeof arg === 'object' && arg !== null) {
                        try {
                            seen.clear();
                            return JSON.stringify(arg, (key, value) => {
                                if (typeof value === 'object' && value !== null) {
                                    if (seen.has(value)) return '[Circular]';
                                    seen.add(value);
                                }
                                return value;
                            }, 2);
                        } catch (e) {
                            return '[Unserializable Object]';
                        }
                    }
                    return String(arg);
                }).join(' ');
            }
            function logToPanel(level, args) {
                if (!debug || !debugLogOutput) return;
                const message = formatArgs(args);
                const timestamp = new Date().toLocaleTimeString();
                const entry = document.createElement('div');
                entry.classList.add('debug-log-entry');
                const timeSpan = document.createElement('span');
                timeSpan.classList.add('debug-log-timestamp');
                timeSpan.textContent = `[${timestamp}]`;
                entry.appendChild(timeSpan);
                const messageSpan = document.createElement('span');
                messageSpan.textContent = message;
                if (level === 'warn') messageSpan.classList.add('debug-log-warn');
                else if (level === 'error') messageSpan.classList.add('debug-log-error');
                entry.appendChild(messageSpan);
                debugLogOutput.appendChild(entry);
                debugLogOutput.scrollTop = debugLogOutput.scrollHeight;
            }
            console.log = function(...args) { originalConsole.log.apply(console, args); logToPanel('log', args); };
            console.warn = function(...args) { originalConsole.warn.apply(console, args); logToPanel('warn', args); };
            console.error = function(...args) { originalConsole.error.apply(console, args); logToPanel('error', args); };
            if (!debug && debugLogContainer) debugLogContainer.classList.add('debug-hidden');
            else if (debugLogContainer) debugLogContainer.classList.remove('debug-hidden');
            if (clearDebugLogButton && debugLogOutput) {
                clearDebugLogButton.addEventListener('click', () => {
                    debugLogOutput.innerHTML = '';
                    console.log("Debug log cleared.");
                });
            }
            // --- END Console Override ---


            // --- Game Constants ---
            const ROWS = 9;
            const COLS = 7;
            const PLAYERS = { ORANGE: 'orange', YELLOW: 'yellow' };
            const RANK_TO_NAME = { 8: 'Elephant', 7: 'Lion', 6: 'Tiger', 5: 'Leopard', 4: 'Wolf', 3: 'Dog', 2: 'Cat', 1: 'Rat' };
            const RANK_TO_CODE = { 8: '8', 7: '7', 6: '6', 5: '5', 4: '4', 3: '3', 2: '2', 1: '1' };
            const SPECIAL_ABILITIES = {
                1: { name: 'Rat', rank: 1, swims: true, attacksElephant: true },
                2: { name: 'Cat', rank: 2 },
                3: { name: 'Dog', rank: 3, swims: true },
                4: { name: 'Wolf', rank: 4 },
                5: { name: 'Leopard', rank: 5, jumpH: true },
                6: { name: 'Tiger', rank: 6, jumpH: true, jumpV: true },
                7: { name: 'Lion', rank: 7, jumpH: true, jumpV: true },
                8: { name: 'Elephant', rank: 8 }
            };
            const INITIAL_SETUP = {
                'a3': { player: PLAYERS.ORANGE, rank: 8 }, 'g1': { player: PLAYERS.ORANGE, rank: 7 }, 'a1': { player: PLAYERS.ORANGE, rank: 6 },
                'e3': { player: PLAYERS.ORANGE, rank: 5 }, 'f2': { player: PLAYERS.ORANGE, rank: 4 }, 'c3': { player: PLAYERS.ORANGE, rank: 3 },
                'b2': { player: PLAYERS.ORANGE, rank: 2 }, 'g3': { player: PLAYERS.ORANGE, rank: 1 },
                'g7': { player: PLAYERS.YELLOW, rank: 8 }, 'a9': { player: PLAYERS.YELLOW, rank: 7 }, 'g9': { player: PLAYERS.YELLOW, rank: 6 },
                'c7': { player: PLAYERS.YELLOW, rank: 5 }, 'b8': { player: PLAYERS.YELLOW, rank: 4 }, 'e7': { player: PLAYERS.YELLOW, rank: 3 },
                'f8': { player: PLAYERS.YELLOW, rank: 2 }, 'a7': { player: PLAYERS.YELLOW, rank: 1 }
            };
            const WATER_SQUARES = new Set(['b4', 'c4', 'e4', 'f4', 'b5', 'c5', 'e5', 'f5', 'b6', 'c6', 'e6', 'f6']);
            // TRAPS.<player> = traps near <player>'s den (affect opponent)
            const TRAPS = {
                orange: new Set(['c1', 'd2', 'e1']), // Traps near Orange's Den (affect Yellow pieces)
                yellow: new Set(['c9', 'd8', 'e9']) // Traps near Yellow's Den (affect Orange pieces)
            };
            const ALL_TRAP_SQUARES = new Set([...TRAPS.orange, ...TRAPS.yellow]);
            const DENS = { orange: 'd1', yellow: 'd9' };
            const MINIMAX_DEPTH = 3;
            const REPETITION_LIMIT = 3; // Allow position 3 times, block the 4th occurrence


            // --- Game State Variables ---
            let gameState = {};
            let gameHistory = [];
            let draggedPieceElement = null;
            let sourceCoords = null;
            let selectedPieceCoords = null;
            let focusedCoords = null;
            let lastMove = { player: null, from: null, to: null }; // NEW: Tracks last move for highlighting
            let isDragging = false;
            let isPlayerVsPlayerMode = false;
            let aiMoveTimeoutId = null;


            // --- Utility Functions ---
            /**
             * Converts zero-based row and column indices to algebraic notation (e.g., 0,0 -> 'a9').
             * @param {number} row - The row index (0-8).
             * @param {number} col - The column index (0-6).
             * @returns {string|null} The algebraic coordinates (e.g., 'a1', 'g9') or null if invalid.
             */
            function getCoords(row, col) {
                if (row < 0 || row >= ROWS || col < 0 || col >= COLS) return null;
                return `${String.fromCharCode(97 + col)}${ROWS - row}`;
            }

            /**
             * Converts algebraic notation coordinates to zero-based row and column indices.
             * @param {string} coords - The algebraic coordinates (e.g., 'a1').
             * @returns {{row: number, col: number}|null} An object with row and col indices, or null if invalid.
             */
            function getRowCol(coords) {
                if (!coords || coords.length < 2) return null;
                const col = coords.charCodeAt(0) - 97; // 'a' -> 0
                const rowNum = parseInt(coords.substring(1));
                if (isNaN(rowNum)) return null;
                const row = ROWS - rowNum; // '9' -> 0
                if (row < 0 || row >= ROWS || col < 0 || col >= COLS) return null;
                return { row, col };
            }

            /**
             * Retrieves the data object for a piece at the given coordinates from the current game state.
             * @param {string} coords - The algebraic coordinates (e.g., 'a1').
             * @param {object} [boardState=gameState.board] - Optional board state to query.
             * @returns {object|null} The piece data object ({player, rank, ...}) or null if the square is empty.
             */
            function getPieceData(coords, boardState = gameState.board) {
                return boardState[coords] || null;
            }

            /** Generates DOM ID for a piece element. */
            function getPieceElementId(coords) { return `piece-${coords}`; }
            /** Generates DOM ID for a cell element. */
            function getCellElementId(coords) { return `cell-${coords}`; }

            /** Gets orthogonal adjacent coordinates. */
            function getAdjacentCoords(coords) {
                const adjacent = [];
                const rc = getRowCol(coords);
                if (!rc) return [];
                const { row, col } = rc;
                const potential = [ getCoords(row + 1, col), getCoords(row - 1, col), getCoords(row, col + 1), getCoords(row, col - 1) ];
                potential.forEach(c => { if (c) adjacent.push(c); });
                return adjacent;
            }

            /** Gets unique adjacent coordinates for a set of squares. */
            function getAdjacentCoordsSet(coordsSet) {
                const allAdjacent = new Set();
                if (!coordsSet) return allAdjacent;
                coordsSet.forEach(coord => {
                    getAdjacentCoords(coord).forEach(adjCoord => { if (adjCoord) allAdjacent.add(adjCoord); });
                });
                return allAdjacent;
            }

            /**
             * Checks if a piece at given coordinates is on an opponent's trap square.
             * @param {object} pieceData - The piece data object ({ player, rank, ... }).
             * @param {string} coords - The algebraic coordinates to check.
             * @returns {boolean} True if the piece is on an opponent's trap, false otherwise.
             */
            function isPieceTrapped(pieceData, coords) {
                if (!pieceData || !coords) return false;
                // Orange piece trapped if on TRAPS.yellow (near Yellow den)
                if (pieceData.player === PLAYERS.ORANGE && TRAPS.yellow.has(coords)) return true;
                // Yellow piece trapped if on TRAPS.orange (near Orange den)
                if (pieceData.player === PLAYERS.YELLOW && TRAPS.orange.has(coords)) return true;
                return false;
            }


            // --- Board Creation and Setup ---

            /** Creates the grid of cell elements. */
            function createBoard() {
                boardGridWrapper.innerHTML = '';
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        const cell = document.createElement('div');
                        const coords = getCoords(r, c);
                        cell.id = getCellElementId(coords);
                        cell.classList.add('cell');
                        cell.dataset.coords = coords; cell.dataset.row = r; cell.dataset.col = c;
                        cell.setAttribute('role', 'gridcell'); cell.setAttribute('tabindex', '-1');
                        if (WATER_SQUARES.has(coords)) cell.classList.add('water');
                        if (TRAPS.yellow.has(coords)) cell.classList.add('trap-yellow'); // Trap near Yellow den
                        if (TRAPS.orange.has(coords)) cell.classList.add('trap-orange'); // Trap near Orange den
                        if (DENS.orange === coords) cell.classList.add('den-orange');
                        if (DENS.yellow === coords) cell.classList.add('den-yellow');
                        boardGridWrapper.appendChild(cell);
                        cell.addEventListener('dragover', handleDragOver);
                        cell.addEventListener('dragenter', handleDragEnter);
                        cell.addEventListener('dragleave', handleDragLeave);
                        cell.addEventListener('drop', handleDrop);
                        cell.addEventListener('click', handleCellClick); // Listener on the cell
                        cell.addEventListener('focus', () => focusedCoords = coords);
                    }
                }
            }

            /** Creates a DOM element for a game piece. */
            function createPieceElement(pieceData, coords) {
                const pieceElement = document.createElement('div');
                pieceElement.id = getPieceElementId(coords);
                pieceElement.classList.add('piece');
                pieceElement.dataset.rank = pieceData.rank;
                pieceElement.dataset.player = pieceData.player;
                pieceElement.dataset.coords = coords;
                pieceElement.setAttribute('role', 'button');
                pieceElement.setAttribute('aria-label', `${pieceData.player} ${RANK_TO_NAME[pieceData.rank]} at ${coords}`);
                pieceElement.setAttribute('tabindex', '-1'); // Made focusable via keyboard nav later

                const pieceKey = `${pieceData.player === PLAYERS.ORANGE ? 'O' : 'Y'}_${pieceData.rank}`;
                const asset = pieceAssetContainer.querySelector(`[data-piece="${pieceKey}"]`);
                if (asset?.tagName === 'IMG') {
                    pieceElement.appendChild(asset.cloneNode(true));
                } else {
                    console.warn("Image asset not found for:", pieceKey);
                    pieceElement.textContent = `${pieceData.player === PLAYERS.ORANGE ? 'O' : 'Y'}${pieceData.rank}`;
                    pieceElement.classList.add(pieceData.player);
                }

                pieceElement.addEventListener('dragstart', handleDragStart);
                pieceElement.addEventListener('dragend', handleDragEnd);
                pieceElement.addEventListener('touchstart', handleTouchStart, { passive: false });
                pieceElement.addEventListener('touchmove', handleTouchMove, { passive: false });
                pieceElement.addEventListener('touchend', handleTouchEnd);
                // pieceElement.addEventListener('click', handlePieceClick); // Click listener moved to cell

                pieceElement.addEventListener('mouseover', handlePieceMouseOver);
                pieceElement.addEventListener('mouseout', handlePieceMouseOut);
                pieceElement.addEventListener('focus', () => focusedCoords = coords);

                // Trap indicator span
                const indicatorSpan = document.createElement('span');
                indicatorSpan.classList.add('trap-rank-indicator');
                indicatorSpan.textContent = '(0)';
                pieceElement.appendChild(indicatorSpan);

                return pieceElement;
            }

            /** Clears and places pieces based on game state. */
            function placePieces() {
                // Don't clear last move highlight here, handled by performMove/clearHighlights
                boardGridWrapper.querySelectorAll('.piece').forEach(p => p.remove());
                for (const coords in gameState.board) {
                    if (gameState.board.hasOwnProperty(coords)) {
                        const pieceData = gameState.board[coords];
                        if (!pieceData) continue;
                        const pieceElement = createPieceElement(pieceData, coords);
                        positionElementOnBoard(pieceElement, coords);
                        boardGridWrapper.appendChild(pieceElement);
                        updateHungryVisual(coords, pieceData.isHungry || false);
                        updatePieceAccessibility(pieceElement);
                        const isTrapped = isPieceTrapped(pieceData, coords);
                        updateTrapIndicatorVisual(coords, isTrapped); // Update trap visual
                    }
                }
            }

            /** Positions a piece element on the board grid. */
            function positionElementOnBoard(element, coords) {
                const rc = getRowCol(coords);
                if (!rc) { console.error("Cannot position element, invalid coords:", coords); return; }
                const { row, col } = rc;
                const cellWidthPercent = 100 / COLS;
                const cellHeightPercent = 100 / ROWS;
                const pieceWidthPercent = 12.07; // Must match CSS
                const wrapperWidth = boardGridWrapper.offsetWidth;
                const wrapperHeight = boardGridWrapper.offsetHeight;
                let pieceHeightPercent = pieceWidthPercent * (wrapperWidth / wrapperHeight);
                if (wrapperHeight > 0 && wrapperWidth > 0) {
                    const pieceWidthPx = wrapperWidth * (pieceWidthPercent / 100);
                    pieceHeightPercent = (pieceWidthPx / wrapperHeight) * 100;
                    element.style.height = `${pieceHeightPercent}%`;
                } else {
                    element.style.height = 'auto';
                }
                element.style.width = `${pieceWidthPercent}%`;
                const cellLeftPercent = col * cellWidthPercent;
                const cellTopPercent = row * cellHeightPercent;
                const offsetXPercent = (cellWidthPercent - pieceWidthPercent) / 2;
                const offsetYPercent = (cellHeightPercent - pieceHeightPercent) / 2;
                element.style.left = `${cellLeftPercent + offsetXPercent}%`;
                element.style.top = `${cellTopPercent + offsetYPercent}%`;
                element.style.transform = '';
                element.dataset.coords = coords;
            }

            /** Updates tabindex and draggable attributes based on game state. */
            function updatePieceAccessibility(pieceElement) {
                if (!pieceElement) return;
                const piecePlayer = pieceElement.dataset.player;
                const shouldBeInteractive = !gameState.gameOver &&
                                            (isPlayerVsPlayerMode || piecePlayer === gameState.currentPlayer);
                pieceElement.setAttribute('tabindex', shouldBeInteractive ? '0' : '-1');
                pieceElement.draggable = shouldBeInteractive;
            }

            /** Updates accessibility for all pieces. */
            function updateAllPieceAccessibility() {
                boardGridWrapper.querySelectorAll('.piece').forEach(p => updatePieceAccessibility(p));
            }


            // --- Game State Management ---

            /** Saves the current game state to history. */
            function saveGameState() {
                const stateToSave = {
                    board: JSON.parse(JSON.stringify(gameState.board)),
                    currentPlayer: gameState.currentPlayer,
                    turnNumber: gameState.turnNumber,
                    moveHistory: JSON.parse(JSON.stringify(gameState.moveHistory)),
                    boardStateHistory: JSON.parse(JSON.stringify(gameState.boardStateHistory)),
                    gameOver: gameState.gameOver,
                    winner: gameState.winner,
                    lastMove: JSON.parse(JSON.stringify(lastMove)) // Save last move info
                };
                gameHistory.push(stateToSave);
                updateUndoButtonState();
                // console.log(`Game state saved. History length: ${gameHistory.length}`);
            }

            /** Restores game state from history (used by undo). */
            function loadGameState(stateToLoad) {
                if (!stateToLoad) return;
                console.log("Loading game state (for Undo)...");
                gameState.board = stateToLoad.board;
                gameState.currentPlayer = stateToLoad.currentPlayer;
                gameState.turnNumber = stateToLoad.turnNumber;
                gameState.moveHistory = stateToLoad.moveHistory;
                gameState.boardStateHistory = stateToLoad.boardStateHistory;
                gameState.gameOver = stateToLoad.gameOver;
                gameState.winner = stateToLoad.winner;
                lastMove = stateToLoad.lastMove; // Restore last move info
                placePieces();
                rebuildMoveLog();
                highlightLastMove(); // Re-apply last move highlight
                updateUI();
                logBoardState(true); // Log restored state without incrementing count
                updateStatus(gameState.gameOver ? `Game Over: ${gameState.winner} wins!` : `${gameState.currentPlayer.toUpperCase()}'s turn.`);
                if (!gameState.gameOver) enablePlayerInteraction();
                else disablePlayerInteraction();
                updateUndoButtonState();
                clearHighlights();
                selectedPieceCoords = null;
                console.log("Game state loaded (Undo).");
            }

            /** Clears and rebuilds the visual move log from history. */
            function rebuildMoveLog() {
                moveLogElement.innerHTML = '';
                gameState.moveHistory.forEach(entry => {
                    addLogEntryToDOM(entry.turn, entry.orange, entry.yellow);
                });
                moveLogElement.scrollTop = moveLogElement.scrollHeight;
            }

            /** Handles the Undo button click. Reverts the game by one move. */
            function undoMove() {
                // Prevent undo while AI is processing
                if (!isPlayerVsPlayerMode && gameState.currentPlayer === PLAYERS.YELLOW && boardGridWrapper.style.pointerEvents === 'none') {
                    console.log("Cannot undo while AI is thinking.");
                    updateStatus("Cannot undo while AI is thinking.");
                    return;
                }
                if (gameHistory.length === 0) {
                    console.log("Nothing to undo.");
                    return;
                }

                console.log("Undoing last move...");
                gameHistory.pop(); // Remove the current state

                const stateToRestore = gameHistory.length > 0 ? gameHistory[gameHistory.length - 1] : null;

                if (stateToRestore) {
                    loadGameState(stateToRestore); // Load the previous state
                    updateStatus(`Undo successful. ${gameState.currentPlayer.toUpperCase()}'s turn.`);
                } else {
                    // If history becomes empty, reset the game
                    console.log("History empty after undo, resetting game.");
                    initializeGame();
                }
                updateUndoButtonState(); // Update button based on new history length
            }

            /** Enables/disables Undo button based on history and game state. */
            function updateUndoButtonState() {
                const aiThinking = !isPlayerVsPlayerMode && gameState.currentPlayer === PLAYERS.YELLOW && boardGridWrapper.style.pointerEvents === 'none';
                undoButton.disabled = gameHistory.length === 0 || gameState.gameOver || aiThinking;
            }


            // --- Game Initialization ---

            /** Sets up the initial game state. */
            function initializeGame(customBoard = null) {
                console.log("Initializing game..." + (customBoard ? " with custom state." : ""));
                gameState = {
                    board: customBoard ? customBoard : JSON.parse(JSON.stringify(INITIAL_SETUP)),
                    currentPlayer: PLAYERS.ORANGE,
                    turnNumber: 1,
                    moveHistory: [],
                    boardStateHistory: {},
                    gameOver: false,
                    winner: null
                };
                isPlayerVsPlayerMode = false;
                const pvpToggle = document.getElementById('pvp-toggle');
                if (pvpToggle) pvpToggle.checked = false;
                if (aiMoveTimeoutId) { clearTimeout(aiMoveTimeoutId); aiMoveTimeoutId = null; }
                gameHistory = [];
                lastMove = { player: null, from: null, to: null }; // Reset last move

                // Add abilities and ensure isHungry is false initially
                Object.keys(gameState.board).forEach(coords => {
                    const piece = gameState.board[coords];
                    if (!piece) return;
                    piece.isHungry = false;
                    const abilities = SPECIAL_ABILITIES[piece.rank];
                    if (abilities) {
                        piece.swims = abilities.swims || false;
                        piece.attacksElephant = abilities.attacksElephant || false;
                        piece.jumpH = abilities.jumpH || false;
                        piece.jumpV = abilities.jumpV || false;
                    } else {
                        piece.swims = false; piece.attacksElephant = false; piece.jumpH = false; piece.jumpV = false;
                    }
                });

                createBoard();
                placePieces();
                moveLogElement.innerHTML = '';
                boardStateLogElement.textContent = '';
                updateStatus("Game Ready. Orange to move.");
                updateUI();
                clearHighlights();
                clearLastMoveHighlight(); // Clear visual highlight
                logBoardState();
                enablePlayerInteraction();
                updateUndoButtonState();
                selectedPieceCoords = null;
                console.log("Game Initialized. Orange starts.");
            }


            // --- Input Handling (Drag & Drop, Touch, Click, Keyboard) ---

            /** Handles drag start on a piece. */
            function handleDragStart(e) {
                const pieceDiv = e.target.closest('.piece');
                if (!pieceDiv || pieceDiv.dataset.player !== gameState.currentPlayer || gameState.gameOver) {
                    e.preventDefault(); return;
                }
                // Check if this player is making a new move, clear previous highlight if so
                if (lastMove.player === gameState.currentPlayer) {
                    clearLastMoveHighlight();
                }

                isDragging = true;
                draggedPieceElement = pieceDiv;
                sourceCoords = draggedPieceElement.dataset.coords;
                setTimeout(() => { if (draggedPieceElement) draggedPieceElement.classList.add('dragging'); }, 0);
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', sourceCoords);
                highlightValidMoves(sourceCoords);
                draggedPieceElement.classList.add('selected');
                selectedPieceCoords = sourceCoords;
                // console.log(`Drag Start: ${sourceCoords}`);
            }

            /** Handles drag end. */
            function handleDragEnd(e) {
                isDragging = false;
                if (draggedPieceElement) {
                    draggedPieceElement.classList.remove('dragging', 'selected');
                }
                draggedPieceElement = null;
                sourceCoords = null;
                clearHighlights();
                // Don't reset selectedPieceCoords here, handled by drop/fail
                // console.log("Drag End");
            }

            /** Handles drag over potential drop targets. */
            function handleDragOver(e) {
                e.preventDefault(); e.dataTransfer.dropEffect = 'move';
            }

            /** Utility: Apply hover style during drag. */
            function handleDragEnterAny(targetElement) {
                if (!targetElement || !isDragging) return;
                const targetCoords = getCoordsFromElement(targetElement);
                const cellElement = targetCoords ? document.getElementById(getCellElementId(targetCoords)) : null;
                if (cellElement) {
                     if (cellElement.classList.contains('repetition-blocked-highlight')) {
                          cellElement.classList.add('repetition-blocked'); // Orange highlight for repetition block
                     } else if (cellElement.classList.contains('valid-attack-highlight')) {
                        cellElement.classList.add('valid-attack'); // Red highlight for attack
                    } else if (cellElement.classList.contains('valid-move-highlight')) {
                        cellElement.classList.add('valid-move'); // Green highlight for move
                    }
                }
            }
            /** Utility: Remove hover style during drag leave. */
            function handleDragLeaveAny(targetElement) {
                if (!targetElement) return;
                const targetCoords = getCoordsFromElement(targetElement);
                const cellElement = targetCoords ? document.getElementById(getCellElementId(targetCoords)) : null;
                if (cellElement) {
                    cellElement.classList.remove('valid-move', 'valid-attack', 'repetition-blocked'); // Remove hover styles
                }
            }
            /** Handles drag enter on cell. */
            function handleDragEnter(e) { e.preventDefault(); handleDragEnterAny(e.target.closest('.cell')); }
            /** Handles drag leave on cell. */
            function handleDragLeave(e) { handleDragLeaveAny(e.target.closest('.cell')); }
            /** Handles drag enter on piece (capture target). */
            function handleDragEnterPiece(e) { e.preventDefault(); e.stopPropagation(); handleDragEnterAny(e.target.closest('.piece')); }
            /** Handles drag leave on piece. */
            function handleDragLeavePiece(e) { handleDragLeaveAny(e.target.closest('.piece')); }

            /** Utility: Get coords from cell or piece element. */
            function getCoordsFromElement(element) {
                if (!element) return null;
                const piece = element.closest('.piece');
                if (piece) return piece.dataset.coords;
                const cell = element.closest('.cell');
                if (cell) return cell.dataset.coords;
                return null;
            }

            /** Handles drop event. */
            function handleDrop(e) {
                e.preventDefault();
                if (!draggedPieceElement) { clearHighlights(); isDragging = false; return; }

                const targetElement = e.target;
                let targetCoords = getCoordsFromElement(targetElement); // Use helper
                const targetCell = targetCoords ? document.getElementById(getCellElementId(targetCoords)) : null;
                const dragSourceCoords = draggedPieceElement.dataset.coords || sourceCoords; // Ensure source is known

                clearHighlights(); // Clean up visual highlights immediately

                if (!targetCell || !targetCoords || !dragSourceCoords) {
                    console.log("Drop outside valid target or source unknown.");
                    updateStatus("Invalid drop location.");
                    selectedPieceCoords = null;
                    isDragging = false;
                    if(draggedPieceElement && dragSourceCoords) positionElementOnBoard(draggedPieceElement, dragSourceCoords); // Snap back
                    return;
                }

                // Validate move using the combined logic
                const validationResult = isMoveAllowed(dragSourceCoords, targetCoords, getPieceData(dragSourceCoords));

                if (!validationResult.valid) {
                    console.log(`Drop on invalid target: ${targetCoords}. Reason: ${validationResult.reason}`);
                    updateStatus(`Invalid move: ${validationResult.reason}`);
                    selectedPieceCoords = null;
                    if(draggedPieceElement && dragSourceCoords) positionElementOnBoard(draggedPieceElement, dragSourceCoords); // Snap back
                } else {
                    console.log(`Performing move via drop from ${dragSourceCoords} to ${targetCoords}`);
                    performMove(dragSourceCoords, targetCoords); // Perform valid move
                    selectedPieceCoords = null; // Deselect after successful move
                }
                isDragging = false; // Reset dragging flag
            }

            // --- Touch Handlers (Simplified, focus on core logic) ---
            let touchStartX, touchStartY;
            /** Handles touch start. */
            function handleTouchStart(e) {
                if (gameState.gameOver) return;
                const pieceElement = e.target.closest('.piece');
                if (!pieceElement || pieceElement.dataset.player !== gameState.currentPlayer) return;

                // Check if this player is making a new move, clear previous highlight if so
                if (lastMove.player === gameState.currentPlayer) {
                    clearLastMoveHighlight();
                }

                e.preventDefault();
                draggedPieceElement = pieceElement;
                sourceCoords = draggedPieceElement.dataset.coords;
                selectedPieceCoords = sourceCoords;
                const touch = e.changedTouches[0];
                touchStartX = touch.clientX; touchStartY = touch.clientY;
                isDragging = false; // Could be tap
                draggedPieceElement.style.transition = 'none';
                draggedPieceElement.style.zIndex = '100';
                highlightValidMoves(sourceCoords);
                draggedPieceElement.classList.add('selected');
                // console.log(`Touch Start: ${sourceCoords}`);
            }
            /** Handles touch move. */
            function handleTouchMove(e) {
                if (!draggedPieceElement || !sourceCoords) return;
                e.preventDefault();
                const touch = e.changedTouches[0];
                const deltaX = touch.clientX - touchStartX;
                const deltaY = touch.clientY - touchStartY;
                const touchDragThreshold = 10;
                if (!isDragging && (Math.abs(deltaX) > touchDragThreshold || Math.abs(deltaY) > touchDragThreshold)) {
                    isDragging = true;
                    draggedPieceElement.classList.add('dragging');
                }
                if (isDragging) {
                    const elementUnderTouch = document.elementFromPoint(touch.clientX, touch.clientY);
                    const currentTransform = draggedPieceElement.style.transform.match(/scale\(([^)]+)\)/);
                    const currentScale = currentTransform ? parseFloat(currentTransform[1]) : 1;
                    draggedPieceElement.style.transform = `translate(${deltaX}px, ${deltaY}px) scale(${currentScale})`;
                    // Update hover highlights based on elementUnderTouch
                    document.querySelectorAll('.cell.valid-move, .cell.valid-attack, .cell.repetition-blocked').forEach(c => c.classList.remove('valid-move', 'valid-attack', 'repetition-blocked'));
                    handleDragEnterAny(elementUnderTouch); // Reuse drag logic for highlighting
                }
            }
            /** Handles touch end. */
            function handleTouchEnd(e) {
                if (!draggedPieceElement || !sourceCoords) return;
                e.preventDefault();
                const wasDragging = isDragging;
                isDragging = false;
                draggedPieceElement.classList.remove('dragging');
                draggedPieceElement.style.zIndex = '10';
                draggedPieceElement.style.transform = '';
                setTimeout(() => { if (draggedPieceElement) draggedPieceElement.style.transition = ''; }, 0); // Restore default transition

                if (!wasDragging) {
                    // Treat as tap: Let handleCellClick (triggered after touchend/click) handle it.
                    console.log("TouchEnd: Detected as tap/click.");
                    // We need to reset state here if handleCellClick isn't guaranteed to fire or reset it
                     draggedPieceElement = null;
                     sourceCoords = null;
                    // Keep selectedPieceCoords as handleCellClick might use it
                    return;
                }

                // If it was a drag, determine drop target
                const touch = e.changedTouches[0];
                const elementUnderTouch = document.elementFromPoint(touch.clientX, touch.clientY);
                const targetCoords = getCoordsFromElement(elementUnderTouch);
                const targetCell = targetCoords ? document.getElementById(getCellElementId(targetCoords)) : null;
                const dragSourceCoords = sourceCoords; // Get source from touch start

                clearHighlights(); // Remove visual highlights

                if (targetCell && targetCoords && dragSourceCoords) {
                    const validationResult = isMoveAllowed(dragSourceCoords, targetCoords, getPieceData(dragSourceCoords));
                    if (validationResult.valid) {
                        console.log(`Performing move via touch from ${dragSourceCoords} to ${targetCoords}`);
                        performMove(dragSourceCoords, targetCoords);
                        selectedPieceCoords = null;
                    } else {
                        console.log("Touch end on invalid target:", validationResult.reason);
                        updateStatus(`Invalid move: ${validationResult.reason}`);
                        positionElementOnBoard(draggedPieceElement, dragSourceCoords); // Snap back
                        selectedPieceCoords = null;
                    }
                } else {
                    console.log("Touch end outside valid target");
                    positionElementOnBoard(draggedPieceElement, dragSourceCoords); // Snap back
                    selectedPieceCoords = null;
                }
                draggedPieceElement = null;
                sourceCoords = null;
                // console.log("Touch End (Drag)");
            }


            // --- Click Handlers ---

            /**
             * Handles clicking on a cell (delegated from board wrapper).
             * Selects own piece, deselects, or attempts move/capture if a piece is selected.
             * @param {MouseEvent} e - The click event object.
             */
            function handleCellClick(e) {
                 // console.log("--- handleCellClick triggered ---");
                const targetCell = e.currentTarget; // The cell the listener is on
                if (!targetCell || !targetCell.dataset.coords) return; // Basic check
                const targetCoords = targetCell.dataset.coords;

                // Ignore clicks during drag, game over, or if it's not the player's turn (in PvE)
                if (isDragging || gameState.gameOver || (!isPlayerVsPlayerMode && gameState.currentPlayer !== PLAYERS.ORANGE)) {
                    // console.log(`handleCellClick ignored: isDragging=${isDragging}, gameOver=${gameState.gameOver}, wrong player?`);
                    return;
                }

                 // Find if there's a piece element directly on this cell
                 const pieceElement = document.getElementById(getPieceElementId(targetCoords));
                 const clickedPieceData = getPieceData(targetCoords); // Data of piece on the clicked cell (if any)

                 // --- Case 1: A piece is already selected ---
                 if (selectedPieceCoords) {
                     const pieceToMove = getPieceData(selectedPieceCoords);
                     if (!pieceToMove) { // Safety check
                         console.warn(`Selected piece data not found for ${selectedPieceCoords}. Deselecting.`);
                         deselectPiece(); return;
                     }

                     // Check if the target is the same as the selected piece (click again to deselect)
                     if (selectedPieceCoords === targetCoords) {
                         deselectPiece();
                         // console.log(`handleCellClick: Deselected ${targetCoords}`);
                         return;
                     }

                     // Attempt to move/capture to the target cell
                      // console.log(`handleCellClick: Attempting move validation: ${selectedPieceCoords} -> ${targetCoords}`);
                      const validationResult = isMoveAllowed(selectedPieceCoords, targetCoords, pieceToMove); // Use combined check

                     if (validationResult.valid) {
                         // console.log(`--> handleCellClick: Validation SUCCESS. Calling performMove(${selectedPieceCoords}, ${targetCoords})`);
                         performMove(selectedPieceCoords, targetCoords); // Automatically deselects
                     } else {
                          // console.log(`--> handleCellClick: Validation FAILED: ${validationResult.reason}`);
                         flashCell(targetCoords, 'red', 300);
                         updateStatus(`Invalid move: ${validationResult.reason}`);
                         // Keep piece selected to allow trying another destination
                     }
                     return; // Action taken (move attempt or feedback)
                 }

                 // --- Case 2: No piece is currently selected ---
                 // Check if the click was on a piece belonging to the current player
                 if (clickedPieceData && clickedPieceData.player === gameState.currentPlayer) {
                     // Check if this player is making a new move, clear previous highlight if so
                     if (lastMove.player === gameState.currentPlayer) {
                         clearLastMoveHighlight();
                     }
                     selectPiece(targetCoords); // Select the clicked piece
                     // console.log(`handleCellClick: Selected own piece at ${targetCoords}`);
                 } else {
                      // console.log(`handleCellClick: Clicked on empty cell or opponent piece (${targetCoords}) with no piece selected. No action.`);
                     // Optional: flash cell? Provide feedback?
                 }
                  // console.log("--- /handleCellClick finished ---");
            }


            /** Handles mouse entering a piece element (for hover). */
            function handlePieceMouseOver(e) {
                const pieceElement = e.target.closest('.piece');
                if (!pieceElement || gameState.gameOver || selectedPieceCoords || isDragging) return;
                const coords = pieceElement.dataset.coords;
                const pieceData = getPieceData(coords);
                if (pieceData && pieceData.player === gameState.currentPlayer) {
                    highlightValidMoves(coords, false); // Highlight moves on hover (isSelection = false)
                }
            }
            /** Handles mouse leaving a piece element (for hover). */
            function handlePieceMouseOut(e) {
                if (!selectedPieceCoords && !isDragging) {
                    clearHighlights(); // Clear hover highlights if nothing is selected/dragging
                }
            }


            // --- Keyboard Handlers ---
            /** Handles keyboard navigation and actions. */
            function handleKeyDown(e) {
                // Task 11: Disable shortcuts if input field is focused
                if (document.activeElement === boardStateInput) {
                    console.log("Input field focused, ignoring game keyboard shortcuts.");
                    return;
                }

                if (gameState.gameOver || (!isPlayerVsPlayerMode && gameState.currentPlayer === PLAYERS.YELLOW)) return;

                const { key } = e;
                let newRow, newCol, targetCoords, currentElement;

                if (!focusedCoords) { // Set initial focus if none
                    const firstPiece = boardGridWrapper.querySelector(`.piece[data-player="${gameState.currentPlayer}"][tabindex="0"]`);
                    if (firstPiece) focusedCoords = firstPiece.dataset.coords;
                    else focusedCoords = getCoords(Math.floor(ROWS/2), Math.floor(COLS/2)) || 'd5';
                    focusOn(focusedCoords);
                    if (!focusedCoords) return;
                }

                const currentRC = getRowCol(focusedCoords);
                if (!currentRC) { console.warn("Keyboard nav: Invalid focusedCoords", focusedCoords); return; }

                switch (key) {
                    case 'ArrowUp': newRow = currentRC.row - 1; newCol = currentRC.col; break;
                    case 'ArrowDown': newRow = currentRC.row + 1; newCol = currentRC.col; break;
                    case 'ArrowLeft': newRow = currentRC.row; newCol = currentRC.col - 1; break;
                    case 'ArrowRight': newRow = currentRC.row; newCol = currentRC.col + 1; break;
                    case 'Enter': case ' ':
                        e.preventDefault();
                        currentElement = document.getElementById(getPieceElementId(focusedCoords)) || document.getElementById(getCellElementId(focusedCoords));

                        if (currentElement?.classList.contains('piece')) { // Focused on piece
                            const pieceData = getPieceData(focusedCoords);
                            if (pieceData?.player === gameState.currentPlayer) {
                                if (selectedPieceCoords === focusedCoords) deselectPiece(); // Deselect if already selected
                                else {
                                     // Check if this player is making a new move, clear previous highlight if so
                                    if (lastMove.player === gameState.currentPlayer) {
                                        clearLastMoveHighlight();
                                    }
                                    selectPiece(focusedCoords); // Select otherwise
                                }
                            }
                        } else if (currentElement?.classList.contains('cell') && selectedPieceCoords) { // Focused on cell & piece selected
                            const pieceToMove = getPieceData(selectedPieceCoords);
                            if (pieceToMove) {
                                const validationResult = isMoveAllowed(selectedPieceCoords, focusedCoords, pieceToMove); // Use combined check
                                if (validationResult.valid) {
                                    console.log(`Performing move via keyboard from ${selectedPieceCoords} to ${focusedCoords}`);
                                    performMove(selectedPieceCoords, focusedCoords);
                                } else {
                                    flashCell(focusedCoords, 'red', 300);
                                    updateStatus(`Invalid move: ${validationResult.reason}`);
                                }
                            }
                        }
                        return;
                    case 'Escape': e.preventDefault(); if (selectedPieceCoords) deselectPiece(); return;
                    default: return;
                }

                targetCoords = getCoords(newRow, newCol);
                if (targetCoords) { e.preventDefault(); focusOn(targetCoords); }
            }

            /** Programmatically sets focus on a cell or piece. */
            function focusOn(coords) {
                if (!coords) return;
                let targetElement = document.getElementById(getPieceElementId(coords)) || document.getElementById(getCellElementId(coords));
                if (targetElement) {
                    targetElement.focus(); // Browser focus updates focusedCoords via listener
                }
            }


            // --- Selection and Interaction State ---

            /** Selects a piece. */
            function selectPiece(coords) {
                deselectPiece(); // Deselect previous first
                const pieceElement = document.getElementById(getPieceElementId(coords));
                if (pieceElement?.dataset.player === gameState.currentPlayer) {
                    selectedPieceCoords = coords;
                    pieceElement.classList.add('selected');
                    highlightValidMoves(coords); // Show valid moves (handles selection state)
                    focusOn(coords);
                    // console.log(`Selected piece at ${coords}`);
                }
            }

            /** Deselects the current piece. */
            function deselectPiece() {
                if (selectedPieceCoords) {
                    const pieceElement = document.getElementById(getPieceElementId(selectedPieceCoords));
                    if (pieceElement) pieceElement.classList.remove('selected');
                    // console.log(`Deselected piece at ${selectedPieceCoords}`);
                    selectedPieceCoords = null;
                    clearHighlights(); // Remove move highlights
                }
            }

            /** Enables user interaction. */
            function enablePlayerInteraction() {
                boardGridWrapper.style.pointerEvents = 'auto';
                document.addEventListener('keydown', handleKeyDown);
                updateAllPieceAccessibility();
                // console.log("Player interaction enabled.");
            }
            /** Disables user interaction. */
            function disablePlayerInteraction() {
                boardGridWrapper.style.pointerEvents = 'none';
                document.removeEventListener('keydown', handleKeyDown);
                updateAllPieceAccessibility();
                // console.log("Player interaction disabled.");
            }


            // --- Move Logic & Validation ---

            /**
             * Executes a validated move, updating state, DOM, checking conditions, etc.
             * @param {string} fromCoords - Starting coordinates.
             * @param {string} toCoords - Ending coordinates.
             */
            function performMove(fromCoords, toCoords) {
                const piece = getPieceData(fromCoords);

                // --- Pre-move validation and setup ---
                if (!piece || piece.player !== gameState.currentPlayer || gameState.gameOver) {
                    console.error("Invalid move attempt condition in performMove.");
                    updateStatus("Cannot move now."); return;
                }
                // Use combined validation including repetition check
                const validationResult = isMoveAllowed(fromCoords, toCoords, piece);
                if (!validationResult.valid) {
                    console.log(`Invalid move attempt in performMove: ${validationResult.reason}`);
                    updateStatus(`Invalid move: ${validationResult.reason}`);
                    flashCell(toCoords, 'red');
                    return; // Do not proceed
                }

                // --- Clear Highlights (Before Save) ---
                // Clear selection/move highlights, but NOT last move highlight yet
                clearHighlights();
                // If the current player is making a move, and they were the last player to move,
                // clear the highlight from their *previous* move now.
                 if (lastMove.player === gameState.currentPlayer) {
                    clearLastMoveHighlight();
                 }
                deselectPiece(); // Ensure no piece remains visually selected

                // Save the state BEFORE making changes
                saveGameState();

                // --- Execute the move ---
                const targetPiece = getPieceData(toCoords);
                const isAttack = !!targetPiece;
                const playerWhoMoved = gameState.currentPlayer;
                let notation = `${RANK_TO_CODE[piece.rank]}`;
                let statusAction = "";

                // --- Handle Starvation BEFORE the move ---
                const starvedPiecesCoords = checkAndApplyStarvation(fromCoords, isAttack);

                // --- Handle Capture ---
                if (isAttack) {
                    console.log(`${piece.player} ${RANK_TO_NAME[piece.rank]}@${fromCoords} captures ${targetPiece.player} ${RANK_TO_NAME[targetPiece.rank]}@${toCoords}`);
                    notation += 'x'; statusAction = ` captures ${RANK_TO_NAME[targetPiece.rank]} at ${toCoords}`;
                    const capturedElement = document.getElementById(getPieceElementId(toCoords));
                    if (capturedElement) {
                        capturedElement.classList.add('captured');
                        setTimeout(() => { capturedElement.remove(); }, 400);
                    }
                }

                // --- Update Game State Board ---
                gameState.board[toCoords] = piece; // Move piece data
                delete gameState.board[fromCoords];

                // --- Update Piece DOM Element ---
                const pieceElement = document.getElementById(getPieceElementId(fromCoords));
                if (pieceElement) {
                    pieceElement.id = getPieceElementId(toCoords);
                    pieceElement.setAttribute('aria-label', `${piece.player} ${RANK_TO_NAME[piece.rank]} at ${toCoords}`);
                    positionElementOnBoard(pieceElement, toCoords); // Visually move

                    // Update hungry status of attacker *after* capture
                    if (isAttack) {
                        const attackerPieceData = gameState.board[toCoords]; // Get data again (might have changed?)
                        if (attackerPieceData) {
                             attackerPieceData.isHungry = false; // Attacker satisfied hunger
                             updateHungryVisual(toCoords, false, pieceElement); // Update visual immediately
                        }
                    }
                    // Update trap indicator for the moved piece at its new location
                    const movedPieceData = gameState.board[toCoords];
                    if (movedPieceData) {
                        const isNowTrapped = isPieceTrapped(movedPieceData, toCoords);
                        updateTrapIndicatorVisual(toCoords, isNowTrapped, pieceElement); // Pass element ref
                    }
                    updatePieceAccessibility(pieceElement); // Update interactivity (for next turn)

                } else {
                    console.error(`Piece element not found at ${fromCoords}! Re-placing all pieces.`);
                    placePieces(); // Fallback
                }

                notation += toCoords; // Complete notation e.g., "8xg7"

                // --- Check Win Conditions ---
                const opponent = playerWhoMoved === PLAYERS.ORANGE ? PLAYERS.YELLOW : PLAYERS.ORANGE;
                const opponentDen = playerWhoMoved === PLAYERS.ORANGE ? DENS.yellow : DENS.orange;
                if (toCoords === opponentDen) {
                    gameState.winner = playerWhoMoved; gameState.gameOver = true;
                    updateStatus(`${playerWhoMoved.toUpperCase()} wins by reaching the den!${statusAction}`);
                    logMove(notation, playerWhoMoved); logBoardState(); updateUI(); disablePlayerInteraction(); updateUndoButtonState();
                     lastMove = { player: playerWhoMoved, from: fromCoords, to: toCoords }; // Record final move
                     highlightLastMove(); // Show final move
                    return;
                }
                let opponentPieceCount = 0;
                for (const coords in gameState.board) { if (gameState.board[coords]?.player === opponent) { opponentPieceCount++; } }
                if (opponentPieceCount === 0) {
                    gameState.winner = playerWhoMoved; gameState.gameOver = true;
                    updateStatus(`${playerWhoMoved.toUpperCase()} wins by eliminating all pieces!${statusAction}`);
                    logMove(notation, playerWhoMoved); logBoardState(); updateUI(); disablePlayerInteraction(); updateUndoButtonState();
                     lastMove = { player: playerWhoMoved, from: fromCoords, to: toCoords }; // Record final move
                     highlightLastMove(); // Show final move
                    return;
                }

                // --- Declare Hungry Animals for the *Next* Player ---
                const { hungryCount, hungryPiecesMap } = declareHungryAnimals(opponent);
                Object.keys(gameState.board).forEach(coords => {
                    const p = gameState.board[coords];
                    if (p) {
                         // Only update state/visual for the player whose turn is NEXT
                         if (p.player === opponent) {
                            const isNowHungry = !!hungryPiecesMap[coords];
                            p.isHungry = isNowHungry; // Update state
                            updateHungryVisual(coords, isNowHungry); // Update visual
                         }
                    }
                });
                if (hungryCount > 0) notation += '+'.repeat(hungryCount);

                // --- Handle Starvation Notation ---
                let starvationOccurred = starvedPiecesCoords.length > 0;
                if (starvationOccurred) {
                    statusAction += ` (${starvedPiecesCoords.length} animal${starvedPiecesCoords.length > 1 ? 's' : ''} starved)`;
                    // Apply Clesto notation rule: 's' becomes 'x'
                    if (!notation.endsWith('x')) {
                         notation += 'x'; // Use 'x' to denote starvation if no capture happened
                         console.log(`Applying Clesto rule: Starvation occurred, notation corrected to end with 'x': ${notation}`);
                    }
                }

                // --- Log Move & Board State ---
                logMove(notation, playerWhoMoved);
                logBoardState(); // Checks repetition internally now

                // --- Check Stalemate (for next player) ---
                if (checkForStalemate(opponent)) {
                    gameState.winner = playerWhoMoved; // Player who just moved wins, opponent has no moves
                    gameState.gameOver = true;
                    updateStatus(`Game Over! ${opponent.toUpperCase()} has no valid moves. ${playerWhoMoved.toUpperCase()} wins!`);
                    disablePlayerInteraction(); updateUI(); updateUndoButtonState();
                    lastMove = { player: playerWhoMoved, from: fromCoords, to: toCoords }; // Record final move
                    highlightLastMove(); // Show final move
                    return;
                }

                // --- Switch Player and Update UI ---
                gameState.currentPlayer = opponent;
                if (playerWhoMoved === PLAYERS.YELLOW) gameState.turnNumber++;
                updateStatus(`${opponent.toUpperCase()}'s turn.${statusAction}`);
                updateUI();
                updateUndoButtonState();
                updateAllPieceAccessibility();

                // --- Store and Highlight Last Move ---
                lastMove = { player: playerWhoMoved, from: fromCoords, to: toCoords };
                highlightLastMove(); // Highlight the move just made

                // --- Trigger AI if applicable ---
                 console.log(`Checking AI Trigger: isPlayerVsPlayerMode = ${isPlayerVsPlayerMode}, currentPlayer = ${gameState.currentPlayer}, gameOver = ${gameState.gameOver}`);
                if (!isPlayerVsPlayerMode && gameState.currentPlayer === PLAYERS.YELLOW && !gameState.gameOver) {
                    disablePlayerInteraction(); undoButton.disabled = true;
                    console.log("AI Turn: Waiting 1.5 seconds before thinking...");
                    if (aiMoveTimeoutId) clearTimeout(aiMoveTimeoutId);
                    aiMoveTimeoutId = setTimeout(triggerAIMove, 1500);
                } else if (!gameState.gameOver) {
                    enablePlayerInteraction(); // Ensure interaction enabled for human turn (PvE or PvP)
                }
            }

            /**
             * Checks if the specified player has any valid moves available.
             * @param {string} playerToCheck - Player ('orange' or 'yellow').
             * @returns {boolean} True if the player has no valid moves, false otherwise.
             */
            function checkForStalemate(playerToCheck) {
                for (const fromCoords in gameState.board) {
                    const piece = gameState.board[fromCoords];
                    if (piece?.player === playerToCheck) {
                        const destinations = getPotentialMoveDestinations(fromCoords, piece);
                        for (const toCoords of destinations) {
                            // Use isMoveAllowed to check validity including repetition
                            if (isMoveAllowed(fromCoords, toCoords, piece).valid) {
                                // console.log(`Stalemate check: Found valid move for ${playerToCheck}: ${fromCoords} to ${toCoords}`);
                                return false; // Found a valid move
                            }
                        }
                    }
                }
                console.log(`Stalemate check: No valid moves found for ${playerToCheck}.`);
                return true; // No valid moves found
            }

            /**
             * Determines if a move is legal, considering rules, terrain, capture, jumps, AND repetition.
             * @param {string} fromCoords - Starting coordinates.
             * @param {string} toCoords - Ending coordinates.
             * @param {object} piece - The piece attempting the move.
             * @param {object} [currentBoardState=gameState.board] - Optional board state for simulation.
             * @param {object} [currentHistory=gameState.boardStateHistory] - Optional history for simulation.
             * @returns {{valid: boolean, reason: string, repetitionBlocked?: boolean}} Result object.
             */
            function isMoveAllowed(fromCoords, toCoords, piece, currentBoardState = gameState.board, currentHistory = gameState.boardStateHistory) {
                // 1. Check basic move validity (terrain, capture rules, etc.)
                const basicValidation = isValidMove(fromCoords, toCoords, piece, currentBoardState);
                if (!basicValidation.valid) {
                    return basicValidation; // Return early if basic rules fail
                }

                // 2. Check Repetition Rule
                const playerMakingMove = piece.player;

                 // Simulate the board state AFTER the move
                 const simulatedBoard = JSON.parse(JSON.stringify(currentBoardState));
                 simulatedBoard[toCoords] = simulatedBoard[fromCoords]; // Move piece
                 delete simulatedBoard[fromCoords];
                 const simulatedStateString = getBoardStateString(simulatedBoard);

                const repetitionCount = currentHistory[simulatedStateString] || 0;

                if (repetitionCount >= REPETITION_LIMIT) {
                     // Determine the leading player in the *current* state (before the move)
                    const orangeCount = Object.values(currentBoardState).filter(p => p?.player === PLAYERS.ORANGE).length;
                    const yellowCount = Object.values(currentBoardState).filter(p => p?.player === PLAYERS.YELLOW).length;
                    let leadingPlayer = null;
                    if (orangeCount > yellowCount) leadingPlayer = PLAYERS.ORANGE;
                    else if (yellowCount > orangeCount) leadingPlayer = PLAYERS.YELLOW;
                    else leadingPlayer = PLAYERS.ORANGE; // Orange leads on ties

                    // If the player attempting the move IS the leading player, block repetition
                    if (playerMakingMove === leadingPlayer) {
                         console.log(`Repetition Blocked: ${playerMakingMove} (leading) attempting state ${simulatedStateString} (count ${repetitionCount + 1})`);
                        return { valid: false, reason: "Move blocked by repetition rule.", repetitionBlocked: true };
                    }
                }

                // If basic rules pass and repetition doesn't block, the move is allowed
                return { valid: true, reason: "" };
            }


            /**
             * Determines if a move is legal based *only* on game rules (terrain, capture, jumps).
             * Does NOT check repetition.
             * @param {string} fromCoords - Starting coordinates.
             * @param {string} toCoords - Ending coordinates.
             * @param {object} piece - The piece attempting the move (ATTACKER).
             * @param {object} [currentBoardState=gameState.board] - Optional board state for simulation.
             * @returns {{valid: boolean, reason: string}} Result object.
             */
            function isValidMove(fromCoords, toCoords, piece, currentBoardState = gameState.board) {
                 if (!piece) return { valid: false, reason: "No piece selected." };
                 if (fromCoords === toCoords) return { valid: false, reason: "Cannot move to the same square." };
                 const fromRC = getRowCol(fromCoords); const toRC = getRowCol(toCoords);
                 if (!fromRC || !toRC) return { valid: false, reason: "Invalid coordinates." };

                 const targetPieceData = currentBoardState[toCoords] || null; // DEFENDER
                 const pieceRank = piece.rank; const pieceAbilities = SPECIAL_ABILITIES[pieceRank] || {};

                 if (targetPieceData?.player === piece.player) return { valid: false, reason: "Cannot capture your own piece." };
                 const ownDen = piece.player === PLAYERS.ORANGE ? DENS.orange : DENS.yellow;
                 if (toCoords === ownDen) return { valid: false, reason: "Cannot enter your own den." };
                 const opponentDen = piece.player === PLAYERS.ORANGE ? DENS.yellow : DENS.orange;
                 if (piece.isHungry && toCoords === opponentDen) return { valid: false, reason: "Hungry animal cannot enter the den." };

                 const dr = Math.abs(fromRC.row - toRC.row); const dc = Math.abs(fromRC.col - toRC.col);
                 const isOrthogonal = (dr === 1 && dc === 0) || (dr === 0 && dc === 1);

                 const isMovingToWater = WATER_SQUARES.has(toCoords);
                 const isMovingFromWater = WATER_SQUARES.has(fromCoords);

                 if (isMovingToWater && !pieceAbilities.swims) return { valid: false, reason: "This animal cannot enter water." };
                 if (pieceRank === 1 && targetPieceData?.rank === 8 && isMovingFromWater) return { valid: false, reason: "Rat cannot attack Elephant from water."};
                 if (isMovingFromWater && !isMovingToWater && targetPieceData && !pieceAbilities.swims) return { valid: false, reason: "Only Rat/Dog can attack land from water." };

                 let isJumpValid = false;
                 if (!isMovingFromWater && !isMovingToWater) {
                     const isVerticalJump = dc === 0 && dr === 4 && (fromRC.col >= 1 && fromRC.col <= 2 || fromRC.col >= 4 && fromRC.col <= 5); // Cols B,C, E,F
                     const isHorizontalJump = dr === 0 && dc === 3 && (fromRC.row >= 3 && fromRC.row <= 5); // Rows 4,5,6 (indices 3,4,5)

                     if (isVerticalJump || isHorizontalJump) {
                         if ((isVerticalJump && !pieceAbilities.jumpV) || (isHorizontalJump && !pieceAbilities.jumpH)) return { valid: false, reason: "This animal cannot jump that way." };
                         if (!checkJumpPathClear(fromRC, toRC, piece.player, currentBoardState)) return { valid: false, reason: "Jump path blocked by opponent swimmer." };
                         isJumpValid = true;
                     }
                 }

                 if (!isOrthogonal && !isJumpValid) return { valid: false, reason: "Invalid move distance or type." };

                 if (targetPieceData) { // Capture Rules
                     let attackerRank = pieceRank;
                     let defenderRank = targetPieceData.rank;
                     const defenderPlayer = targetPieceData.player;

                     // Trap Rule: Defender's rank becomes 0 if on an opponent's trap square
                     const opponentTraps = defenderPlayer === PLAYERS.ORANGE ? TRAPS.yellow : TRAPS.orange;
                     const defenderIsTrapped = opponentTraps.has(toCoords);
                     if (defenderIsTrapped) {
                         defenderRank = 0;
                         // console.log(`Trap Rule: Defender ${defenderPlayer} ${RANK_TO_NAME[targetPieceData.rank]}@${toCoords} rank set to 0.`);
                     }

                     const isRatAttackElephant = pieceRank === 1 && targetPieceData.rank === 8;
                     if (isRatAttackElephant && !isMovingFromWater) return { valid: true }; // Rat exception

                     if (attackerRank < defenderRank && defenderRank !== 0) { // Cannot attack strictly higher rank (unless trapped)
                         return { valid: false, reason: `Cannot attack higher rank (${attackerRank} vs ${targetPieceData.rank}${defenderIsTrapped ? ' [Trap->0]' : ''}).` };
                     }
                 }
                 return { valid: true, reason: "" }; // All checks passed
            }


            /** Checks jump path over water. */
            function checkJumpPathClear(fromRC, toRC, attackerPlayer, currentBoardState = gameState.board) {
                const opponent = attackerPlayer === PLAYERS.ORANGE ? PLAYERS.YELLOW : PLAYERS.ORANGE;
                const startRow = Math.min(fromRC.row, toRC.row); const endRow = Math.max(fromRC.row, toRC.row);
                const startCol = Math.min(fromRC.col, toRC.col); const endCol = Math.max(fromRC.col, toRC.col);

                if (fromRC.col === toRC.col) { // Vertical
                    for (let r = startRow + 1; r < endRow; r++) {
                        const coords = getCoords(r, fromRC.col);
                        if (!WATER_SQUARES.has(coords)) { console.warn(`Jump path error: ${coords} not water.`); return false; }
                        const blockingPiece = getPieceData(coords, currentBoardState);
                        if (blockingPiece?.player === opponent && SPECIAL_ABILITIES[blockingPiece.rank]?.swims) { // Opponent swimmer blocks
                            // console.log(`Jump blocked by opponent ${RANK_TO_NAME[blockingPiece.rank]}@${coords}`);
                            return false;
                        }
                    }
                } else if (fromRC.row === toRC.row) { // Horizontal
                    for (let c = startCol + 1; c < endCol; c++) {
                        const coords = getCoords(fromRC.row, c);
                        if (!WATER_SQUARES.has(coords)) { console.warn(`Jump path error: ${coords} not water.`); return false; }
                        const blockingPiece = getPieceData(coords, currentBoardState);
                        if (blockingPiece?.player === opponent && SPECIAL_ABILITIES[blockingPiece.rank]?.swims) { // Opponent swimmer blocks
                            // console.log(`Jump blocked by opponent ${RANK_TO_NAME[blockingPiece.rank]}@${coords}`);
                            return false;
                        }
                    }
                } else { console.error("checkJumpPathClear called with non-orthogonal jump."); return false; }
                return true; // Path clear
            }


            // --- Hungry/Starve Logic ---

            /** Identifies hungry pieces for a player. */
            function declareHungryAnimals(playerToDeclareFor, boardState = gameState.board) {
                let hungryCount = 0; const hungryPiecesMap = {};
                const opponent = playerToDeclareFor === PLAYERS.ORANGE ? PLAYERS.YELLOW : PLAYERS.ORANGE;
                for (const coords in boardState) {
                    const piece = boardState[coords];
                    if (piece?.player === playerToDeclareFor) {
                        const destinations = getPotentialMoveDestinations(coords, piece);
                        for (const targetCoords of destinations) {
                            const targetPiece = boardState[targetCoords];
                            if (targetPiece?.player === opponent) {
                                // Use basic isValidMove (no repetition check needed here)
                                if (isValidMove(coords, targetCoords, piece, boardState).valid) {
                                    hungryPiecesMap[coords] = true; hungryCount++; break;
                                }
                            }
                        }
                    }
                }
                // if (hungryCount > 0) console.log(`${playerToDeclareFor.toUpperCase()} has ${hungryCount} hungry animal(s): ${Object.keys(hungryPiecesMap).join(', ')}`);
                return { hungryCount, hungryPiecesMap };
            }

            /** Checks and applies starvation rules. Called before move execution. */
            function checkAndApplyStarvation(movedPieceCoords, wasAttack) {
                const currentPlayer = gameState.currentPlayer;
                const starvedPiecesCoords = [];
                for (const coords in gameState.board) {
                    const piece = gameState.board[coords];
                    // Must check player AND if it was hungry *before* this move started
                    if (piece?.player === currentPlayer && piece.isHungry) {
                        const didThisPieceAttack = (coords === movedPieceCoords) && wasAttack;
                        if (!didThisPieceAttack) {
                            console.log(`STARVE: ${currentPlayer} ${RANK_TO_NAME[piece.rank]}@${coords} starved.`);
                            starvedPiecesCoords.push(coords);
                        } else {
                             // console.log(`SAVED: ${currentPlayer} ${RANK_TO_NAME[piece.rank]}@${coords} attacked.`);
                        }
                    }
                }
                // Remove starved pieces
                starvedPiecesCoords.forEach(coords => {
                    const starvedElement = document.getElementById(getPieceElementId(coords));
                    const pieceData = gameState.board[coords];
                    if (pieceData) {
                        console.log(`Removing starved ${RANK_TO_NAME[pieceData.rank]}@${coords}`);
                        delete gameState.board[coords];
                        if (starvedElement) {
                            starvedElement.classList.add('captured');
                            setTimeout(() => starvedElement.remove(), 400);
                        }
                    }
                });
                return starvedPiecesCoords;
            }

            /** Gets geometrically possible destinations (orthogonal + jumps). */
            function getPotentialMoveDestinations(fromCoords, piece) {
                const destinations = new Set(); const rc = getRowCol(fromCoords);
                if (!rc || !piece) return [];
                const { row, col } = rc; const abilities = SPECIAL_ABILITIES[piece.rank] || {};
                // Orthogonal
                [getCoords(row + 1, col), getCoords(row - 1, col), getCoords(row, col + 1), getCoords(row, col - 1)].forEach(c => { if (c) destinations.add(c); });
                // Jumps
                 if (abilities.jumpV && (col >= 1 && col <= 2 || col >= 4 && col <= 5)) { // Cols B,C, E,F
                     if (row >= 3) { const destUp = getCoords(row - 4, col); if (destUp) destinations.add(destUp); } // Jump Up (over rows 3,4,5)
                     if (row <= 5) { const destDown = getCoords(row + 4, col); if (destDown) destinations.add(destDown); } // Jump Down (over rows 3,4,5)
                 }
                 if (abilities.jumpH && (row >= 3 && row <= 5)) { // Rows 4,5,6 (indices 3,4,5)
                     if (col >= 3) { const destLeft = getCoords(row, col - 3); if (destLeft) destinations.add(destLeft); } // Jump Left (over cols C,D or E,F)
                     if (col <= 3) { const destRight = getCoords(row, col + 3); if (destRight) destinations.add(destRight); } // Jump Right (over cols B,C or D,E)
                 }
                return [...destinations];
            }


            // --- AI Logic (Minimax) ---

            /** Initiates AI move calculation. */
            function triggerAIMove() {
                console.log("AI (Yellow) is thinking...");
                const bestMoveResult = findBestMoveMinimax(MINIMAX_DEPTH, gameState, PLAYERS.YELLOW);

                if (bestMoveResult?.move) {
                    console.log(`AI chooses move: ${bestMoveResult.move.from} to ${bestMoveResult.move.to} (Score: ${bestMoveResult.score.toFixed(2)})`);
                    performMove(bestMoveResult.move.from, bestMoveResult.move.to);
                } else {
                    console.log("AI has no valid moves! Game should end.");
                    if (!gameState.gameOver) {
                        // If AI has no moves, the player who just moved (Orange) wins.
                        gameState.winner = PLAYERS.ORANGE;
                        gameState.gameOver = true;
                        updateStatus("Stalemate! AI (Yellow) has no moves. Orange wins!");
                        disablePlayerInteraction(); updateUI(); updateUndoButtonState();
                        highlightLastMove(); // Show Orange's final winning move
                    }
                }
            }

            /** Root level of Minimax search. */
            function findBestMoveMinimax(depth, currentGameState, playerForMax) {
                let bestScore = -Infinity; let bestMove = null;
                const opponentDen = playerForMax === PLAYERS.ORANGE ? DENS.yellow : DENS.orange;

                // Get all moves allowed by rules AND repetition limit
                const possibleMoves = getAllValidMoves(currentGameState.board, currentGameState.currentPlayer, true); // Check repetition

                if (possibleMoves.length === 0) { console.log("AI findBestMove: No possible moves found."); return null; }

                // Immediate Win Check
                for (const move of possibleMoves) {
                    if (move.to === opponentDen && !getPieceData(move.from, currentGameState.board)?.isHungry) { // Can't enter den if hungry
                        console.log("AI Found immediate winning move to Den:", move);
                        return { move: move, score: 10000 + depth };
                    }
                }

                // Handle Hungry Pieces Obligation
                const currentBoard = currentGameState.board; // For easier access
                const hungryPieces = Object.keys(currentBoard).filter(coord => currentBoard[coord]?.player === playerForMax && currentBoard[coord]?.isHungry);
                let movesToConsider = possibleMoves;

                if (hungryPieces.length > 0) {
                    const attackingHungryMoves = possibleMoves.filter(move => hungryPieces.includes(move.from) && !!currentBoard[move.to]);
                    if (attackingHungryMoves.length > 0) {
                        // console.log("AI considering only ATTACKING moves by hungry pieces:", attackingHungryMoves);
                        movesToConsider = attackingHungryMoves;
                    } else {
                        // If no attacking moves possible for hungry pieces, must move one of them non-attackingly
                        const nonAttackingHungryMoves = possibleMoves.filter(move => hungryPieces.includes(move.from));
                         // console.log("AI considering only non-attacking moves by hungry pieces:", nonAttackingHungryMoves);
                        movesToConsider = nonAttackingHungryMoves.length > 0 ? nonAttackingHungryMoves : possibleMoves; // Fallback if somehow no hungry moves possible
                    }
                }

                // Evaluate prioritized moves
                for (const move of movesToConsider) {
                    const nextState = simulateMove(currentGameState, move);
                    const score = minimax(depth - 1, nextState, false, -Infinity, Infinity, playerForMax);
                    let currentScore = score;
                    if (Math.abs(score) < 5000) currentScore += Math.random() * 0.1; // Tie-breaking

                    if (currentScore > bestScore) {
                        bestScore = currentScore; bestMove = move;
                    }
                }

                // Fallback if no move found among considered (e.g., all led to forced loss)
                if (!bestMove && possibleMoves.length > 0) {
                     console.warn("Minimax didn't find a best move among 'movesToConsider'. Picking first valid move as fallback.");
                     // Pick the first move from the *original* list of possible moves
                    bestMove = possibleMoves[0];
                    // Evaluate this fallback move to get a score, even if bad
                     const fallbackState = simulateMove(currentGameState, bestMove);
                     bestScore = minimax(depth - 1, fallbackState, false, -Infinity, Infinity, playerForMax);
                }

                return { move: bestMove, score: bestScore };
            }

            /** Recursive Minimax with Alpha-Beta. */
            function minimax(depth, nodeGameState, isMaximizingPlayer, alpha, beta, playerForMax) {
                if (depth === 0 || nodeGameState.gameOver) {
                    const baseScore = evaluateBoard(nodeGameState.board, playerForMax);
                    if (baseScore > 5000) return baseScore + depth; // Faster win
                    if (baseScore < -5000) return baseScore - depth; // Slower loss
                    return baseScore;
                }

                // Get moves allowed by rules AND repetition (pass true)
                const possibleMoves = getAllValidMoves(nodeGameState.board, nodeGameState.currentPlayer, true, nodeGameState);

                if (possibleMoves.length === 0) {
                    // If current player has no moves, they lose (opponent wins)
                    return isMaximizingPlayer ? (-10000 - depth) : (10000 + depth);
                }

                // Handle Hungry Pieces Obligation within simulation
                const currentBoard = nodeGameState.board;
                const hungryPieces = Object.keys(currentBoard).filter(coord => currentBoard[coord]?.player === nodeGameState.currentPlayer && currentBoard[coord]?.isHungry);
                let movesToConsider = possibleMoves;
                 if (hungryPieces.length > 0) {
                    const attackingHungryMoves = possibleMoves.filter(move => hungryPieces.includes(move.from) && !!currentBoard[move.to]);
                    if (attackingHungryMoves.length > 0) {
                        movesToConsider = attackingHungryMoves;
                    } else {
                         const nonAttackingHungryMoves = possibleMoves.filter(move => hungryPieces.includes(move.from));
                        movesToConsider = nonAttackingHungryMoves.length > 0 ? nonAttackingHungryMoves : possibleMoves; // Fallback
                    }
                }


                if (isMaximizingPlayer) {
                    let maxEval = -Infinity;
                    for (const move of movesToConsider) {
                        const nextState = simulateMove(nodeGameState, move);
                        const evaluation = minimax(depth - 1, nextState, false, alpha, beta, playerForMax);
                        maxEval = Math.max(maxEval, evaluation);
                        alpha = Math.max(alpha, evaluation);
                        if (beta <= alpha) break; // Beta cutoff
                    }
                     // Fallback if only forced bad moves considered
                     if (maxEval === -Infinity && possibleMoves.length > 0 && movesToConsider.length < possibleMoves.length) {
                          const fallbackMove = possibleMoves.find(m => !movesToConsider.includes(m)) || possibleMoves[0];
                          const fallbackState = simulateMove(nodeGameState, fallbackMove);
                          return minimax(depth -1, fallbackState, false, alpha, beta, playerForMax);
                     }
                    return maxEval;
                } else { // Minimizing Player
                    let minEval = Infinity;
                    for (const move of movesToConsider) {
                        const nextState = simulateMove(nodeGameState, move);
                        const evaluation = minimax(depth - 1, nextState, true, alpha, beta, playerForMax);
                        minEval = Math.min(minEval, evaluation);
                        beta = Math.min(beta, evaluation);
                        if (beta <= alpha) break; // Alpha cutoff
                    }
                     // Fallback if only forced bad moves considered
                     if (minEval === Infinity && possibleMoves.length > 0 && movesToConsider.length < possibleMoves.length) {
                         const fallbackMove = possibleMoves.find(m => !movesToConsider.includes(m)) || possibleMoves[0];
                         const fallbackState = simulateMove(nodeGameState, fallbackMove);
                         return minimax(depth -1, fallbackState, true, alpha, beta, playerForMax);
                     }
                    return minEval;
                }
            }

            /**
             * Generates all valid moves for a player, optionally checking repetition.
             * @param {object} boardState - The board state.
             * @param {string} player - The player.
             * @param {boolean} [checkRepetition=false] - Whether to include repetition check.
             * @param {object} [currentFullGameState=gameState] - Full game state needed for repetition check.
             * @returns {Array<object>} Array of valid move objects [{ from, to }, ...].
             */
            function getAllValidMoves(boardState, player, checkRepetition = false, currentFullGameState = gameState) {
                const validMoves = [];
                if (!boardState) return [];
                for (const fromCoords in boardState) {
                    const piece = boardState[fromCoords];
                    if (piece?.player === player) {
                        const destinations = getPotentialMoveDestinations(fromCoords, piece);
                        for (const toCoords of destinations) {
                            let validationResult;
                            if (checkRepetition) {
                                validationResult = isMoveAllowed(fromCoords, toCoords, { ...piece }, boardState, currentFullGameState.boardStateHistory);
                            } else {
                                validationResult = isValidMove(fromCoords, toCoords, { ...piece }, boardState);
                            }
                            if (validationResult.valid) {
                                validMoves.push({ from: fromCoords, to: toCoords });
                            }
                        }
                    }
                }
                return validMoves;
            }

            /** Simulates a move for AI evaluation. Does NOT handle full turn logic. */
            function simulateMove(currentGameState, move) {
                // Deep copy only essential parts for simulation
                const nextState = {
                    board: JSON.parse(JSON.stringify(currentGameState.board)),
                    currentPlayer: currentGameState.currentPlayer, // Keep same player temporarily
                    gameOver: false, winner: null,
                    boardStateHistory: currentGameState.boardStateHistory, // Pass history reference for repetition check in isMoveAllowed
                    // No need for moveHistory, turnNumber etc in simulation
                };
                const piece = nextState.board[move.from];
                if (!piece) { /* Error handled in calling function */ return nextState; }

                // Simplified capture
                if (nextState.board[move.to]) { delete nextState.board[move.to]; }
                // Move piece
                nextState.board[move.to] = piece; delete nextState.board[move.from];

                // Simplified Win Checks
                const playerWhoMoved = piece.player;
                const opponent = playerWhoMoved === PLAYERS.ORANGE ? PLAYERS.YELLOW : PLAYERS.ORANGE;
                const opponentDen = playerWhoMoved === PLAYERS.ORANGE ? DENS.yellow : DENS.orange;
                if (move.to === opponentDen && !piece.isHungry) { // Check if not hungry when entering den
                    nextState.gameOver = true; nextState.winner = playerWhoMoved;
                } else {
                    let opponentPieceCount = 0;
                    for (const coords in nextState.board) { if (nextState.board[coords]?.player === opponent) { opponentPieceCount++; break; } }
                    if (opponentPieceCount === 0) { nextState.gameOver = true; nextState.winner = playerWhoMoved; }
                }

                // Switch player for the next simulated turn
                nextState.currentPlayer = opponent;

                // Update hungry status for the *next* player in the simulated state
                // Use the simulated board state
                 const { hungryPiecesMap } = declareHungryAnimals(nextState.currentPlayer, nextState.board);
                 Object.keys(nextState.board).forEach(coords => {
                     const p = nextState.board[coords];
                     if (p) {
                         p.isHungry = !!hungryPiecesMap[coords]; // Update based on simulation
                     }
                 });

                return nextState;
            }

            /** Evaluates board state for AI. */
            function evaluateBoard(boardState, playerForMax) {
                let score = 0;
                const pieceValues = { 1: 35, 2: 10, 3: 40, 4: 30, 5: 50, 6: 70, 7: 80, 8: 75 };
                const opponent = playerForMax === PLAYERS.ORANGE ? PLAYERS.YELLOW : PLAYERS.ORANGE;

                const maxDen = playerForMax === PLAYERS.ORANGE ? DENS.orange : DENS.yellow;
                const minDen = playerForMax === PLAYERS.ORANGE ? DENS.yellow : DENS.orange;
                const maxTraps = playerForMax === PLAYERS.ORANGE ? TRAPS.orange : TRAPS.yellow; // Traps near AI den (affect AI)
                const minTraps = playerForMax === PLAYERS.ORANGE ? TRAPS.yellow : TRAPS.orange; // Traps near Opponent den (affect Opponent)

                const adjacentToMaxDen = getAdjacentCoords(maxDen);
                const adjacentToMinTraps = getAdjacentCoordsSet(minTraps); // Squares next to traps near opponent's den

                const IMMEDIATE_THREAT_PENALTY = 750;
                const NEAR_OPPONENT_TRAP_BONUS = 50;
                const DEN_PROXIMITY_MULTIPLIER = 0.5;
                const HUNGRY_OPPONENT_PENALTY = -20; // Penalty for making opponent hungry

                let maxHasWon = false; let minHasWon = false;
                let maxPieceCount = 0; let minPieceCount = 0;

                for (const coords in boardState) {
                    const piece = boardState[coords];
                    if (!piece) continue;
                    let pieceScore = pieceValues[piece.rank] || 0;
                    const rc = getRowCol(coords);

                    if (piece.player === playerForMax) { // AI piece
                        maxPieceCount++;
                        if (rc) { // Positional bonuses
                             const targetDenRC = getRowCol(minDen);
                             if (targetDenRC) { const dist = Math.abs(rc.row - targetDenRC.row) + Math.abs(rc.col - targetDenRC.col); pieceScore += (16 - dist) * DEN_PROXIMITY_MULTIPLIER; }
                             // Bonus for being near opponent's traps (good setup)
                             if (adjacentToMinTraps.has(coords)) pieceScore += NEAR_OPPONENT_TRAP_BONUS;
                        }
                        score += pieceScore;
                        if (coords === minDen) maxHasWon = true; // Check win
                    } else { // Opponent piece
                        minPieceCount++;
                        if (coords === maxDen) minHasWon = true; // Check loss

                        // Check threats
                        const isOnMinTrap = minTraps.has(coords); // Opponent on trap near *their* den
                        const isAdjacentToMaxDen = adjacentToMaxDen.includes(coords); // Opponent near AI den
                         const opponentIsTrapped = maxTraps.has(coords); // Is opponent on trap near *AI* den?

                        if (isAdjacentToMaxDen || opponentIsTrapped) {
                             // If opponent is next to AI den OR on a trap near AI den (weakened but still threat)
                             console.log(`Threat detected: Opponent ${RANK_TO_NAME[piece.rank]} at ${coords} (Adjacent: ${isAdjacentToMaxDen}, OnTrapNearMax: ${opponentIsTrapped}). Penalty: -${IMMEDIATE_THREAT_PENALTY}`);
                             score -= IMMEDIATE_THREAT_PENALTY;
                        }

                        // Penalty if opponent piece is hungry (Task 13 consideration)
                        if (piece.isHungry) {
                            score += HUNGRY_OPPONENT_PENALTY * (pieceValues[piece.rank] / 10); // Penalty scaled by hungry piece value
                             // console.log(`Opponent ${RANK_TO_NAME[piece.rank]}@${coords} is hungry. Penalty: ${HUNGRY_OPPONENT_PENALTY * (pieceValues[piece.rank]/10)}`);
                        }

                        score -= pieceScore; // Subtract opponent material value
                    }
                }

                if (maxHasWon || minPieceCount === 0) return 10000;
                if (minHasWon || maxPieceCount === 0) return -10000;
                return score;
            }


            // --- UI Update & Logging ---

            /** Updates main UI elements. */
            function updateUI() {
                if (gameState.gameOver) {
                    turnIndicator.textContent = `Game Over - ${gameState.winner ? gameState.winner.toUpperCase() : 'DRAW'} Wins!`;
                    turnIndicator.className = 'game-over';
                } else {
                    turnIndicator.textContent = gameState.currentPlayer.toUpperCase();
                    turnIndicator.className = gameState.currentPlayer;
                }
                updateUndoButtonState();
                updateAllPieceAccessibility();
            }

            /** Updates status message. */
            function updateStatus(message) {
                statusMessage.textContent = message;
                // console.log("Status:", message); // Keep this for basic flow tracking
            }

            /** Adds entry to visual move log. */
            function addLogEntryToDOM(turn, orangeMove, yellowMove) {
                const logEntryDiv = document.createElement('div');
                logEntryDiv.classList.add('log-entry'); logEntryDiv.dataset.turn = turn;
                const turnSpan = document.createElement('span');
                turnSpan.classList.add('turn-number'); turnSpan.textContent = `${turn}.`;
                logEntryDiv.appendChild(turnSpan);
                const orangeSpan = document.createElement('span');
                if (orangeMove) { orangeSpan.classList.add('log-orange'); orangeSpan.textContent = orangeMove; }
                else { orangeSpan.classList.add('placeholder'); orangeSpan.textContent = '...'; }
                logEntryDiv.appendChild(orangeSpan);
                if (yellowMove) {
                    const yellowSpan = document.createElement('span');
                    yellowSpan.classList.add('log-yellow'); yellowSpan.textContent = yellowMove;
                    logEntryDiv.appendChild(yellowSpan);
                }
                moveLogElement.appendChild(logEntryDiv);
                moveLogElement.scrollTop = moveLogElement.scrollHeight;
            }

            /** Logs move to history and updates visual log. */
            function logMove(notation, playerWhoMoved) {
                const turnNum = gameState.turnNumber;
                let currentTurnEntry = gameState.moveHistory.find(entry => entry.turn === turnNum);
                let existingLogDiv = moveLogElement.querySelector(`div.log-entry[data-turn="${turnNum}"]`);

                if (playerWhoMoved === PLAYERS.ORANGE) {
                    if (!currentTurnEntry) {
                        currentTurnEntry = { turn: turnNum, orange: notation, yellow: null };
                        gameState.moveHistory.push(currentTurnEntry);
                        if (existingLogDiv) existingLogDiv.remove();
                        addLogEntryToDOM(turnNum, notation, null);
                    } else { // Update existing (e.g., after undo)
                        currentTurnEntry.orange = notation; currentTurnEntry.yellow = null; // Reset yellow move if orange re-moves
                        if (existingLogDiv) {
                            let orangeSpan = existingLogDiv.querySelector('.log-orange, .placeholder');
                            if (orangeSpan) { orangeSpan.textContent = notation; orangeSpan.className = 'log-orange'; }
                            let yellowSpan = existingLogDiv.querySelector('.log-yellow');
                            if (yellowSpan) yellowSpan.remove(); // Remove old yellow move
                        } else { addLogEntryToDOM(turnNum, notation, null); }
                    }
                } else { // Yellow moved
                    if (currentTurnEntry) {
                        currentTurnEntry.yellow = notation;
                        if (existingLogDiv) {
                            let yellowSpan = existingLogDiv.querySelector('.log-yellow');
                            if (!yellowSpan) { yellowSpan = document.createElement('span'); existingLogDiv.appendChild(yellowSpan); }
                            yellowSpan.textContent = notation; yellowSpan.className = 'log-yellow';
                        } else { console.error("Log div missing for Yellow's move in turn", turnNum); addLogEntryToDOM(turnNum, currentTurnEntry.orange || '...', notation); }
                    } else { console.error("Yellow moved but no history entry found for turn", turnNum); currentTurnEntry = { turn: turnNum, orange: null, yellow: notation }; gameState.moveHistory.push(currentTurnEntry); if (existingLogDiv) existingLogDiv.remove(); addLogEntryToDOM(turnNum, null, notation); }
                }
                moveLogElement.scrollTop = moveLogElement.scrollHeight;
            }

            /** Generates board state string for repetition check. */
            function getBoardStateString(board = gameState.board) {
                const pieces = [];
                const coordsList = Object.keys(board).sort((a, b) => {
                    const colA = a.charCodeAt(0); const colB = b.charCodeAt(0);
                    if (colA !== colB) return colA - colB;
                    const rowA = parseInt(a.substring(1)); const rowB = parseInt(b.substring(1));
                    return rowB - rowA; // Higher row number first (a9 before a1)
                });
                for (const coords of coordsList) {
                    const piece = board[coords];
                    if (piece) {
                        const stateOutput = piece.player === PLAYERS.ORANGE ? `${piece.rank}${coords.toUpperCase()}` : `${piece.rank}${coords.toLowerCase()}`;
                        pieces.push(stateOutput);
                    }
                }
                // pieces.sort(); // Secondary sort might be redundant but safe
                return pieces.join(',');
            }

            /** Parses board state string into board object. */
            function parseBoardStateString(stateString) {
                if (!stateString || typeof stateString !== 'string') return null;
                // Task 12: Remove spaces around commas and trim
                const cleanedString = stateString.replace(/\s*,\s*/g, ',').trim();
                if (!cleanedString) return {}; // Handle empty string after cleaning

                const parsedBoard = {};
                const pieceStrings = cleanedString.split(',');
                const pieceRegex = /^([1-8])([a-gA-G][1-9])$/;

                for (const pieceStr of pieceStrings) {
                    if (!pieceStr) continue;
                    const match = pieceStr.match(pieceRegex);
                    if (!match) { console.error(`Parse Error: Invalid piece format "${pieceStr}"`); return null; }
                    const rank = parseInt(match[1], 10);
                    const coordsRaw = match[2];
                    const coordsLower = coordsRaw.toLowerCase();
                    if (!getRowCol(coordsLower)) { console.error(`Parse Error: Invalid coords "${coordsRaw}"`); return null; }
                    const player = (coordsRaw === coordsRaw.toUpperCase()) ? PLAYERS.ORANGE : PLAYERS.YELLOW;
                    const pieceData = { player, rank, isHungry: false };
                    const abilities = SPECIAL_ABILITIES[rank];
                    if (abilities) {
                        pieceData.swims = abilities.swims || false; pieceData.attacksElephant = abilities.attacksElephant || false;
                        pieceData.jumpH = abilities.jumpH || false; pieceData.jumpV = abilities.jumpV || false;
                    } else { pieceData.swims = false; pieceData.attacksElephant = false; pieceData.jumpH = false; pieceData.jumpV = false; }
                    if (parsedBoard[coordsLower]) { console.error(`Parse Error: Duplicate piece at "${coordsLower}"`); return null; }
                    parsedBoard[coordsLower] = pieceData;
                }
                console.log("Successfully parsed board state:", parsedBoard);
                return parsedBoard;
            }

            /** Logs board state string and updates history count. */
            function logBoardState(isRestoring = false) {
                const stateString = getBoardStateString();
                boardStateLogElement.textContent = stateString;
                if (!isRestoring) {
                    gameState.boardStateHistory[stateString] = (gameState.boardStateHistory[stateString] || 0) + 1;
                    // console.log(`Board State (${gameState.boardStateHistory[stateString]}x):`, stateString);
                } else {
                    // console.log(`Restored Board State:`, stateString);
                }
                return stateString;
            }

            /** Shows/hides trap indicator visual. */
            function updateTrapIndicatorVisual(coords, isTrapped, element = null) {
                 const pieceElement = element || document.getElementById(getPieceElementId(coords));
                 if (!pieceElement) return;
                 const indicatorSpan = pieceElement.querySelector('.trap-rank-indicator');
                 if (!indicatorSpan) { console.warn("Trap indicator span not found for piece at", coords); return; }
                 if (isTrapped) indicatorSpan.classList.add('visible');
                 else indicatorSpan.classList.remove('visible');
            }

            /** Adds/removes 'hungry' class visual. */
            function updateHungryVisual(coords, isHungry, element = null) {
                const pieceElement = element || document.getElementById(getPieceElementId(coords));
                if (pieceElement) {
                    if (isHungry) pieceElement.classList.add('hungry');
                    else pieceElement.classList.remove('hungry');
                } // else { console.warn(`updateHungryVisual: Element not found for ${coords}`); }
            }


            // --- Highlighting & Visual Feedback ---

            /** Highlights valid moves, attacks, and repetition blocks. */
            function highlightValidMoves(fromCoords, isSelection = true) {
                 clearHighlights(); // Clear previous highlights first
                 const piece = gameState.board[fromCoords];
                 if (!piece || (isSelection && piece.player !== gameState.currentPlayer)) return;

                 const destinations = getPotentialMoveDestinations(fromCoords, piece);

                 destinations.forEach(toCoords => {
                     // Check move validity including repetition
                     const validation = isMoveAllowed(fromCoords, toCoords, piece);
                     const cell = document.getElementById(getCellElementId(toCoords));
                     if (cell) {
                         if (validation.valid) {
                             cell.classList.add('valid-move-highlight'); // Base class for hover/drag check
                             if (gameState.board[toCoords]) { // Is it an attack?
                                 cell.classList.add('valid-attack-highlight');
                                 if (isSelection) cell.classList.add('valid-attack'); // Red style for selection
                             } else {
                                 if (isSelection) cell.classList.add('valid-move'); // Green style for selection
                             }
                             cell.setAttribute('tabindex', '0'); // Make valid targets focusable
                         } else if (validation.repetitionBlocked) {
                              // If invalid ONLY due to repetition
                              cell.classList.add('repetition-blocked-highlight'); // Base class
                              if (isSelection) cell.classList.add('repetition-blocked'); // Orange style for selection
                              // Do not make repetition-blocked cells focusable via tab
                         }
                         // Don't highlight or make focusable if invalid for other reasons
                     }
                 });

                 if (isSelection) { // Mark source piece as selected if this is for selection
                     const pieceEl = document.getElementById(getPieceElementId(fromCoords));
                     if (pieceEl) pieceEl.classList.add('selected');
                 }
            }

            /** Removes all temporary highlights and selection styles. */
            function clearHighlights() {
                 boardGridWrapper.querySelectorAll('.cell').forEach(cell => {
                     cell.classList.remove('valid-move', 'valid-attack', 'repetition-blocked', 'valid-move-highlight', 'valid-attack-highlight', 'repetition-blocked-highlight');
                     cell.setAttribute('tabindex', '-1'); // Reset tabindex
                 });
                 if (!selectedPieceCoords) { // Deselect piece visual only if no piece is selected
                     boardGridWrapper.querySelectorAll('.piece.selected').forEach(p => p.classList.remove('selected'));
                 }
                 updateAllPieceAccessibility(); // Ensure piece tabindex/draggable correct
                 // Restore focus on current element if needed
                 if (focusedCoords) {
                     let focusedEl = document.getElementById(getCellElementId(focusedCoords)) || document.getElementById(getPieceElementId(focusedCoords));
                     if (focusedEl?.getAttribute('tabindex') === '0') focusedEl.focus(); // Refocus if it should be focusable
                 }
            }

            /** Briefly flashes cell background. */
            function flashCell(coords, color = 'red', duration = 300) {
                const cell = document.getElementById(getCellElementId(coords));
                if (cell) {
                    const originalTransition = cell.style.transition;
                    cell.style.transition = `background-color ${duration / 2}ms ease-out`;
                    cell.style.backgroundColor = color === 'red' ? 'rgba(255,0,0,0.5)' : 'rgba(0,255,0,0.5)';
                    setTimeout(() => {
                        cell.style.backgroundColor = '';
                        setTimeout(() => { cell.style.transition = originalTransition; }, 50);
                    }, duration / 2);
                }
            }

            /** Highlights the squares of the last move made. */
            function highlightLastMove() {
                clearLastMoveHighlight(); // Clear previous
                if (lastMove.from && lastMove.to) {
                    const fromCell = document.getElementById(getCellElementId(lastMove.from));
                    const toCell = document.getElementById(getCellElementId(lastMove.to));
                    if (fromCell) fromCell.classList.add('last-move-from');
                    if (toCell) toCell.classList.add('last-move-to');
                }
            }
            /** Removes the last move highlight. */
            function clearLastMoveHighlight() {
                boardGridWrapper.querySelectorAll('.cell.last-move-from, .cell.last-move-to').forEach(cell => {
                    cell.classList.remove('last-move-from', 'last-move-to');
                });
            }


            // --- Event Listeners Setup ---
            resetButton.addEventListener('click', () => initializeGame());
            undoButton.addEventListener('click', undoMove);

            // --- Load State Button Listener ---
            const loadStateButton = document.getElementById('load-state-button');
            // boardStateInput already defined
            const loadStatusMessage = document.getElementById('load-status-message');
            if (loadStateButton && boardStateInput && loadStatusMessage) {
                loadStateButton.addEventListener('click', () => {
                    const stateString = boardStateInput.value; // Get raw value
                    if (!stateString) {
                        loadStatusMessage.textContent = "Please paste a state string first."; loadStatusMessage.style.color = 'red'; return;
                    }
                    const parsedBoard = parseBoardStateString(stateString); // parseBoardStateString handles cleaning
                    if (parsedBoard) {
                        initializeGame(parsedBoard);
                        loadStatusMessage.textContent = "Board state loaded successfully!"; loadStatusMessage.style.color = '#28a745';
                        boardStateInput.value = '';
                        updateStatus("Loaded custom state. Orange to move.");
                    } else {
                        loadStatusMessage.textContent = "Invalid state string format. See console."; loadStatusMessage.style.color = 'red';
                        boardStateInput.style.borderColor = 'red'; setTimeout(() => { boardStateInput.style.borderColor = ''; }, 2000);
                    }
                });
            } else { console.error("Could not find Load State elements."); }

            // --- Accordion Logic ---
            const rulesButton = document.getElementById('rules-toggle-button');
            const rulesContent = document.getElementById('rules-content');
            if (rulesButton && rulesContent) {
                rulesButton.addEventListener('click', () => {
                    const isExpanded = rulesButton.getAttribute('aria-expanded') === 'true';
                    rulesButton.setAttribute('aria-expanded', !isExpanded);
                    rulesContent.setAttribute('aria-hidden', isExpanded);
                    rulesButton.classList.toggle('active');
                    rulesContent.classList.toggle('expanded');
                    if (!isExpanded) {
                        rulesContent.style.maxHeight = rulesContent.scrollHeight + 'px';
                        rulesButton.querySelector('.rules-button-text').textContent = 'Hide Game Rules';
                    } else {
                        rulesContent.style.maxHeight = null;
                        rulesButton.querySelector('.rules-button-text').textContent = 'Show Game Rules';
                    }
                });
            } else { console.warn("Rules accordion elements not found."); }

            // --- PvP Toggle Listener ---
            const pvpToggleButton = document.getElementById('pvp-toggle');
            if (pvpToggleButton) {
                pvpToggleButton.addEventListener('change', (event) => {
                    isPlayerVsPlayerMode = event.target.checked;
                    console.log(`Player vs Player mode ${isPlayerVsPlayerMode ? 'ENABLED' : 'DISABLED'}`);
                    if (aiMoveTimeoutId) { clearTimeout(aiMoveTimeoutId); aiMoveTimeoutId = null; } // Clear pending AI move

                    if (isPlayerVsPlayerMode) {
                        console.log("PvP Mode ACTIVE: Enabling interaction.");
                        enablePlayerInteraction(); // Ensure interaction enabled for current player
                        updateStatus(`${gameState.currentPlayer.toUpperCase()}'s turn (PvP Mode)`);
                    } else { // Switching to PvE
                        if (gameState.currentPlayer === PLAYERS.YELLOW && !gameState.gameOver) {
                            console.log("PvE Mode ACTIVE and Yellow's turn: Disabling interaction, scheduling AI move.");
                            disablePlayerInteraction();
                            aiMoveTimeoutId = setTimeout(triggerAIMove, 1500);
                        } else {
                             console.log("PvE Mode ACTIVE and Orange's turn: Enabling interaction.");
                            enablePlayerInteraction(); // Ensure Orange can move
                            updateStatus(`${gameState.currentPlayer.toUpperCase()}'s turn`);
                        }
                    }
                    updateAllPieceAccessibility(); // Update visuals/interactivity
                    updateUndoButtonState(); // Update undo button state
                });
            } else { console.warn("PvP toggle button not found."); }

            // --- Initial Game Setup ---
            console.log("Initializing Clesto Game...");
            initializeGame();
            console.log("Game setup complete. Board and UI ready.");

        }); // End DOMContentLoaded
    </script>

</body>
</html>