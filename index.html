<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Play Clesto, the Jungle Chess game online. A strategy board game with unique animal movements and rules.">
    <title>CLESTO: The Jungle Chess Game</title>

    <!-- Preload key visual assets -->
    <link rel="preload" as="image" href="https://staticjw.com/clesto/board.png">
    <link rel="preload" as="image" href="https://staticjw.com/clesto/animals/elephant-orange.png">
    <link rel="preload" as="image" href="https://staticjw.com/clesto/animals/lion-orange.png">
    <link rel="preload" as="image" href="https://staticjw.com/clesto/animals/elephant-yellow.png">
    <link rel="preload" as="image" href="https://staticjw.com/clesto/animals/lion-yellow.png">

    <style>
        /* --- Global Variables & Basic Setup --- */
        :root {
            /* Player Colors */
            --orange-color: #E67E22;
            --yellow-color: #F1C40F;
            --dark-orange: #D35400;
            --dark-yellow: #F39C12;

            /* UI Colors */
            --light-gray: #f8f9fa;
            --medium-gray: #dee2e6;
            --dark-gray: #343a40;

            /* Highlight & Feedback Colors */
            --cell-highlight-move: rgba(0, 255, 0, 0.7);
            /* Green for valid move */
            --cell-highlight-attack: rgba(255, 0, 0, 0.7);
            /* Red for valid attack */
            --piece-select-glow: rgba(0, 191, 255, 0.9);
            /* Blue glow for selected piece */
            --hungry-outline: rgba(255, 0, 0, 0.8);
            /* Dashed red outline for hungry pieces */
            --ai-move-from-bg: rgba(0, 0, 255, 0.15);
            /* Light blue for AI's previous move start */
            --ai-move-to-bg: rgba(0, 0, 255, 0.3);
            /* Darker blue for AI's previous move end */
            --focus-outline: 2px solid #007bff;
            /* Standard focus indicator */

            /* Layout Dimensions */
            --board-max-width: 550px;
            --ui-max-width: 300px;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: var(--light-gray);
            color: var(--dark-gray);
            padding: 10px;
            margin: 0;
            box-sizing: border-box;
            width: 100%;
            min-height: 100vh;
        }

        h1 {
            margin-top: 10px;
            margin-bottom: 15px;
            color: var(--dark-gray);
            font-weight: 300;
            border-bottom: 1px solid var(--medium-gray);
            padding-bottom: 10px;
            font-size: 1.8em;
            text-align: center;
            width: 100%;
            /* Max width matches the combined width of board and UI */
            max-width: calc(var(--board-max-width) + var(--ui-max-width) + 40px);
        }

        main {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            margin-top: 10px;
            width: 100%;
            max-width: calc(var(--board-max-width) + var(--ui-max-width) + 40px);
            box-sizing: border-box;
        }

        /* --- Board Styling --- */
        #board {
            /* Outer container: Sets dimensions, background image, and padding */
            width: var(--board-max-width);
            max-width: 100%;
            /* Responsive width */
            aspect-ratio: 7 / 9;
            /* Maintain board proportions */
            height: auto;
            border: none;
            position: relative;
            background-image: url('https://staticjw.com/clesto/board.png');
            background-size: cover;
            background-position: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
            border-radius: 5px;
            outline: none;
            /* For custom focus */
            box-sizing: border-box;
            padding: 21px 17px;
            /* Adjust padding to align grid with background */
            overflow: hidden;
            /* Clip any potential overflow */
        }

        #board-grid-wrapper {
            /* Inner container: Holds the grid cells and pieces */
            width: 100%;
            height: 100%;
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            grid-template-rows: repeat(9, 1fr);
            position: relative;
            outline: none;
        }

        #board:focus {
            /* Custom focus style for the board */
            box-shadow: 0 0 0 3px var(--focus-outline);
        }

        .cell {
            /* Individual grid cells */
            width: 100%;
            height: 100%;
            border: none;
            box-sizing: border-box;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.6em;
            /* For coordinate display (optional) */
            color: rgba(0, 0, 0, 0.3);
            user-select: none;
            background-clip: padding-box;
            /* Ensure background doesn't overlap borders */
            transition: background-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            outline: none;
            /* For custom focus */
        }

        .cell:focus {
            /* Custom focus style for cells */
            box-shadow: inset 0 0 0 3px var(--focus-outline);
            z-index: 5;
            /* Bring focus outline above other elements */
        }

        .cell::before {
            /* Pseudo-element for styling special terrain (water, traps, dens) */
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            /* Doesn't interfere with clicks/drags */
            box-sizing: border-box;
            border-radius: inherit;
            opacity: 0.8;
            /* Slightly transparent overlay */
        }

        /* Specific terrain styles using the ::before pseudo-element */
        .water::before {
            background-color: rgba(100, 150, 255, 0.3);
        }

        .trap-orange::before { /* Affects Orange, near Yellow den */
            /* background-color: rgba(255, 255, 150, 0.3); */
            /* border: 2px dashed var(--dark-yellow); */
        }

        .trap-yellow::before { /* Affects Yellow, near Orange den */
            /* background-color: rgba(255, 150, 150, 0.3); */
            /* border: 2px dashed var(--hungry-outline); */
        }

        .den-orange::before {
            /* background-color: rgba(255, 100, 0, 0.4); */
            /* border: 3px solid var(--dark-orange); */
        }

        .den-yellow::before {
            /* background-color: rgba(255, 255, 0, 0.4); */
            /* border: 3px solid var(--dark-yellow); */
        }

        /* Highlighting for AI's last move */
        .ai-move-from {
            background-color: var(--ai-move-from-bg) !important;
        }

        .ai-move-to {
            background-color: var(--ai-move-to-bg) !important;
        }

        /* --- Highlighting for Last Moves --- */
        /* Generic cell styles (apply to both players) */
        .last-move-from {
            background-color: rgba(0, 0, 255, 0.1); /* Light background for origin */
             transition: background-color 0.3s ease-out;
        }
        .last-move-to {
            background-color: rgba(0, 0, 255, 0.25); /* Darker background for destination */
             transition: background-color 0.3s ease-out;
        }
        /* Player-specific border/glow (optional, can use background only) */
        .orange-last-move {
            background-color: rgba(0, 0, 255, 0.25); /* Light background for origin */
             transition: background-color 0.3s ease-out;
        }
        .yellow-last-move {
            background-color: rgba(0, 0, 255, 0.25); /* Darker background for destination */
             transition: background-color 0.3s ease-out;
        }

        /* --- Piece Styling --- */
        .piece {
            /* Width calculated as a percentage of the GRID WRAPPER */
            /* Cell Width = 100% / 7 columns ≈ 14.2857% */
            /* Piece Width = 84.5% of Cell Width */
            /* Piece % of Wrapper = (100/7) * 0.845 ≈ 12.07% */
            width: 12.07%;
            aspect-ratio: 1 / 1;
            /* Make piece square relative to its width */
            height: auto;
            /* Height is automatically determined by width + aspect ratio */

            position: absolute;
            /* Positioned relative to #board-grid-wrapper */
            left: 0;
            /* Left position set by JavaScript */
            top: 0;
            /* Top position set by JavaScript */

            cursor: grab;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.25);
            z-index: 10;
            /* Pieces sit above cells */
            /* Smooth transitions for movement, scaling, and effects */
            transition: transform 0.3s ease-in-out, box-shadow 0.2s ease, outline 0.2s ease, left 0.3s ease-in-out, top 0.3s ease-in-out;
            user-select: none;
            /* Prevent text selection */
            overflow: visible;
            /* Allow outlines/glows to extend slightly */
            background: none;
            border: none;
            border-radius: 50%;
            /* Circular pieces */
            outline: none;
            /* Custom focus/selection */
            touch-action: none;
            /* Improve touch interactions */
        }

        .piece img {
            /* Styling for the animal image inside the piece div */
            width: 100%;
            height: 100%;
            display: block;
            object-fit: contain;
            /* Scale image while preserving aspect ratio */
            pointer-events: none;
            /* Image doesn't interfere with events on the parent div */
            border-radius: 50%;
        }

        .piece:focus {
            /* Custom focus style for pieces 
            outline: 3px solid var(--focus-outline);
            outline-offset: 1px;
            z-index: 15; */
            /* Bring focused piece above others */
        }

        .piece.dragging {
            /* Style applied when a piece is being dragged */
            opacity: 0.6;
            cursor: grabbing;
            z-index: 100;
            /* Ensure dragged piece is on top */
            transform: scale(1.1);
            /* Slightly enlarge */
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            /* Enhance shadow */
            transition: transform 0.15s ease-out, box-shadow 0.2s ease, outline 0.2s ease;
            /* Faster transition while dragging */
        }

        .piece.captured {
            /* Animation for captured pieces */
            animation: capture-animation 0.4s ease-out forwards;
        }

        /* --- Trap Rank Indicator Styling --- */
        .trap-rank-indicator {
            position: absolute;
            top: -2px; /* Position slightly above the piece image */
            left: 0;
            width: 100%;
            text-align: center;
            font-size: 0.75em; /* Smaller font size */
            font-weight: bold;
            color: white; /* White text */
            background-color: rgba(200, 0, 0, 0.75); /* Reddish semi-transparent background */
            border-radius: 3px;
            padding: 0 2px;
            z-index: 1; /* Above the image (z-index 0 default) but below selection/hungry (z-index > 1) */
            pointer-events: none; /* So it doesn't interfere with clicks/drags */
            display: none; /* Hidden by default */
            box-sizing: border-box;
            user-select: none; /* Prevent text selection */
        }

        .trap-rank-indicator.visible {
            display: block; /* Show the indicator when this class is added */
        }

        @keyframes capture-animation {
            0% {
                transform: scale(1);
                opacity: 1;
            }

            100% {
                transform: scale(0.5);
                opacity: 0;
            }
        }

        /* --- Visual Feedback --- */
        .valid-move {
            /* Style for cells representing a valid non-attack move */
            box-shadow: inset 0 0 0 3px var(--cell-highlight-move);
            background-color: rgba(0, 255, 0, 0.1);
        }

        .valid-attack {
            /* Style for cells representing a valid attack move */
            box-shadow: inset 0 0 0 3px var(--cell-highlight-attack);
            background-color: rgba(255, 0, 0, 0.1);
        }

        .selected {
            /* Outline for the currently selected piece */
            /* outline: 3px solid var(--piece-select-glow); */ /* Blue solid */
            /* outline-offset: 1px;
            z-index: 16; */ /* Ensure selected outline is visually prominent */
        }

        .hungry {
            /* Box-shadow glow for pieces that must attack if possible */
            /* outline: 3px dashed var(--hungry-outline); */ /* Keep old style commented */
            /* outline-offset: 2px; */
            box-shadow: 0 0 0 3px var(--hungry-outline); /* Red 'glow' effect */
             /* Optional: Add a subtle animation */
            /* animation: hungry-pulse 1.5s infinite ease-in-out; */
        }

        /* Optional pulse animation for hungry pieces */
        @keyframes hungry-pulse {
            0% { box-shadow: 0 0 0 3px var(--hungry-outline); }
            50% { box-shadow: 0 0 0 5px rgba(255, 0, 0, 0.5); } /* Slightly wider, semi-transparent */
            100% { box-shadow: 0 0 0 3px var(--hungry-outline); }
        }

        /* --- UI Info Panel Styling --- */
        #ui-info-section {
            width: var(--ui-max-width);
            max-width: 100%;
            /* Responsive width */
            border: none;
            padding: 20px;
            background-color: #ffffff;
            height: fit-content;
            /* Adjust height based on content */
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
        }

        #ui-info-section h2,
        #ui-info-section h3 {
            margin-top: 0;
            margin-bottom: 15px;
            border-bottom: 1px solid var(--medium-gray);
            padding-bottom: 8px;
            font-weight: 400;
            color: var(--dark-gray);
        }

        #ui-info-section h3 {
            margin-top: 15px;
            /* Space above subheadings */
        }

        #ui-info-section p {
            margin: 10px 0;
            line-height: 1.5;
        }

        #turn-indicator {
            font-weight: 600;
            padding: 3px 6px;
            border-radius: 4px;
            color: white;
        }

        /* Player-specific turn indicator colors */
        #turn-indicator.orange {
            background-color: var(--orange-color);
        }

        #turn-indicator.yellow {
            background-color: var(--yellow-color);
            color: var(--dark-gray);
            /* Better contrast */
        }

        #turn-indicator.game-over {
            background-color: #dc3545;
            /* Red for game over */
        }

        #status-message {
            min-height: 1.5em;
            /* Prevent layout shifts */
        }

        /* --- Clock Styling --- */
        .clock-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 10px;
            margin: 4px 0 8px 0; /* Space around clocks */
            border: 1px solid var(--medium-gray);
            border-radius: 4px;
            background-color: #f8f9fa; /* Light background */
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }

        .clock-label {
            font-weight: 500;
            font-size: 0.9em;
            margin-right: 10px;
            color: var(--dark-gray);
        }

        .clock-time {
            font-family: 'Courier New', Courier, monospace; /* Monospaced font for consistent width */
            font-size: 1.1em;
            font-weight: bold;
            padding: 2px 5px;
            border-radius: 3px;
            background-color: #e9ecef; /* Slightly darker background for time */
        }

        /* Style for the active clock */
        .clock-container.clock-active {
            border-color: var(--dark-gray);
            background-color: #e9ecef; /* Highlight background */
        }

        /* Player-specific active clock time background (optional) */
        #orange-clock-container.clock-active .clock-time {
             background-color: var(--orange-color);
             color: white;
        }
         #yellow-clock-container.clock-active .clock-time {
             background-color: var(--yellow-color);
             color: var(--dark-gray);
         }

        /* --- Buttons --- */
        .button-container {
            padding-top: 10px;
            margin-bottom: 15px;
            display: flex;
            gap: 10px;
            justify-content: space-around;
            flex-wrap: wrap;
        }

        .game-button {
            padding: 10px 18px;
            cursor: pointer;
            border-radius: 5px;
            border: none;
            font-size: 0.95em;
            transition: background-color 0.2s ease, box-shadow 0.2s ease;
            background-color: #6c757d;
            /* Default gray */
            color: white;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            outline: none;
            /* Custom focus */
            margin-bottom: 5px;
            /* Spacing when wrapping */
        }

        .game-button:hover {
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.15);
        }

        .game-button:focus-visible {
            /* Style for keyboard focus */
            box-shadow: 0 0 0 3px var(--focus-outline);
        }

        /* Specific button colors */
        #reset-button {
            background-color: #007bff;
            /* Blue */
        }

        #reset-button:hover {
            background-color: #0056b3;
        }

        #undo-button {
            background-color: #ffc107;
            /* Yellow */
            color: var(--dark-gray);
        }

        #undo-button:hover {
            background-color: #e0a800;
        }

        #undo-button:disabled {
            background-color: #adb5bd;
            cursor: not-allowed;
            box-shadow: none;
        }

        /* --- PvP Toggle Switch Styling --- */
        .pvp-toggle-container {
            display: flex;
            align-items: center;
            justify-content: space-between; /* Adjust as needed */
            margin-top: 8px;
            margin-bottom: 8px;
            padding: 5px 0;
        }

        .pvp-label {
            margin-right: 10px;
            font-weight: 500;
            font-size: 0.95em;
        }

        /* The switch - a wrapper around the checkbox and slider */
        .switch {
            position: relative;
            display: inline-block;
            width: 50px; /* Width of the switch */
            height: 24px; /* Height of the switch */
        }

        /* Hide default HTML checkbox */
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        /* The slider */
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 18px; /* Height of the knob */
            width: 18px; /* Width of the knob */
            left: 3px; /* Position from left */
            bottom: 3px; /* Position from bottom */
            background-color: white;
            transition: .4s;
        }

        input:checked + .slider {
            background-color: var(--orange-color); /* Use a game color when active */
        }

        input:focus + .slider {
            box-shadow: 0 0 1px var(--orange-color);
        }
         input:focus-visible + .slider { /* Better focus styling */
             outline: 2px solid var(--focus-outline);
             outline-offset: 1px;
         }


        input:checked + .slider:before {
            transform: translateX(26px); /* Move knob to the right */
        }

        /* Rounded sliders */
        .slider.round {
            border-radius: 24px; /* Make the track round */
        }

        .slider.round:before {
            border-radius: 50%; /* Make the knob round */
        }

        /* --- Logs --- */
        #move-log {
            height: 220px;
            /* Fixed height with scrolling */
            overflow-y: auto;
            border: 1px solid var(--medium-gray);
            border-radius: 5px;
            padding: 8px 10px;
            margin-top: 10px;
            font-size: 0.9em;
            background-color: #ffffff;
            line-height: 1.6;
        }

        .log-entry {
            padding: 3px 0;
            border-bottom: 1px dashed var(--medium-gray);
        }

        .log-entry:last-child {
            border-bottom: none;
        }

        .log-entry .turn-number {
            display: inline-block;
            width: 25px;
            font-weight: bold;
            color: #6c757d;
            margin-right: 5px;
        }

        .log-entry .log-orange,
        .log-entry .log-yellow {
            display: inline-block;
            min-width: 60px;
            padding: 2px 5px;
            border-radius: 3px;
            margin: 0 3px;
            text-align: center;
        }

        /* Move log colors matching player colors */
        .log-entry .log-orange {
            background-color: rgba(230, 126, 34, 0.15);
            color: var(--dark-orange);
            border: 1px solid rgba(230, 126, 34, 0.3);
        }

        .log-entry .log-yellow {
            background-color: rgba(241, 196, 15, 0.15);
            color: #c78b02;
            /* Darker yellow for text */
            border: 1px solid rgba(241, 196, 15, 0.3);
        }

        .log-entry .placeholder {
            /* Style for when a player hasn't moved yet in the current turn */
            color: #adb5bd;
            font-style: italic;
            display: inline-block;
            min-width: 60px;
            text-align: center;
        }

        #board-state-log {
            /* Displays a string representation of the board state (for debugging/repetition check) */
            margin-top: 10px;
            border: 1px solid var(--medium-gray);
            border-radius: 5px;
            padding: 10px;
            font-size: 0.75em;
            font-family: monospace;
            word-wrap: break-word;
            background-color: #ffffff;
            max-height: 90px;
            overflow-y: auto;
            line-height: 1.4;
        }

        /* --- Debug Log Section Styling (Optional) --- */
        #debug-log-container {
            width: 100%;
            max-width: calc(var(--board-max-width) + var(--ui-max-width) + 40px);
            margin-top: 20px;
            padding: 15px;
            background-color: #f1f3f5;
            border: 1px solid var(--medium-gray);
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            box-sizing: border-box;
        }

        #debug-log-container h2 {
            margin-top: 0;
            margin-bottom: 10px;
            font-weight: 400;
            border-bottom: 1px solid var(--medium-gray);
            padding-bottom: 5px;
            font-size: 1.2em;
        }

        #debug-log-output {
            height: 200px;
            max-height: 40vh;
            /* Limit height relative to viewport */
            overflow-y: auto;
            background-color: #ffffff;
            border: 1px solid var(--medium-gray);
            border-radius: 3px;
            padding: 8px;
            font-family: monospace;
            font-size: 0.8em;
            white-space: pre-wrap;
            /* Wrap long lines */
            word-break: break-word;
            line-height: 1.4;
        }

        .debug-log-entry {
            padding: 2px 0;
            border-bottom: 1px dashed #e9ecef;
        }

        .debug-log-entry:last-child {
            border-bottom: none;
        }

        .debug-log-timestamp {
            color: #6c757d;
            margin-right: 8px;
        }

        /* Color coding for debug levels */
        .debug-log-warn {
            color: #fd7e14;
        }

        .debug-log-error {
            color: #dc3545;
            font-weight: bold;
        }

        .debug-hidden {
            /* Class to hide the debug section */
            display: none;
        }

        /* --- Rules Accordion Styling --- */
        #rules-accordion-container {
            width: 100%;
            max-width: calc(var(--board-max-width) + var(--ui-max-width) + 40px); /* Match main content width */
            margin: 15px auto 15px auto; /* Add some space around it */
            border: 1px solid var(--medium-gray);
            border-radius: 5px;
            overflow: hidden; /* Clip content during transition */
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            box-sizing: border-box;
            background-color: #f8f9fa; /* Light background */
        }

        .rules-toggle-button {
            background-color: #e9ecef; /* Slightly darker header background */
            color: var(--dark-gray);
            cursor: pointer;
            padding: 12px 18px;
            width: 100%;
            border: none;
            text-align: left;
            outline: none;
            font-size: 1.1em;
            transition: background-color 0.3s ease;
            display: flex;
            justify-content: space-between; /* Space between text and icon */
            align-items: center;
            font-weight: 500;
        }

        .rules-toggle-button:hover,
        .rules-toggle-button.active {
            background-color: #dee2e6; /* Darker on hover/active */
        }

        .rules-toggle-button:focus-visible {
             box-shadow: 0 0 0 3px var(--focus-outline);
             z-index: 1; /* Ensure focus outline is visible */
             position: relative; /* Needed for z-index */
        }

        .rules-icon {
            font-size: 1.2em;
            font-weight: bold;
            transition: transform 0.3s ease;
        }

        .rules-toggle-button.active .rules-icon {
            transform: rotate(45deg); /* Rotate '+' to 'x' */
        }

        .rules-content {
            padding: 0 18px; /* Add padding only when open */
            background-color: white;
            max-height: 0; /* Initially collapsed */
            overflow: hidden;
            transition: max-height 0.3s ease-out, padding 0.3s ease-out; /* Smooth transition */
            border-top: 1px solid var(--medium-gray); /* Separator line */
        }

        .rules-content.expanded {
             padding: 15px 18px; /* Padding when expanded */
             /* max-height is set by JS */
        }


        .rules-content h3 {
            margin-top: 15px;
            margin-bottom: 8px;
            color: var(--dark-orange);
            border-bottom: 1px solid var(--medium-gray);
            padding-bottom: 4px;
        }
         .rules-content h3:first-child {
            margin-top: 0;
         }

        .rules-content h4 {
            margin-top: 12px;
            margin-bottom: 5px;
            color: var(--dark-gray);
        }


        .rules-content p,
        .rules-content ul,
        .rules-content ol {
            margin-bottom: 10px;
            line-height: 1.6;
        }

        .rules-content ul,
        .rules-content ol {
            padding-left: 25px; /* Indent lists */
        }
         .rules-content ul ul,
         .rules-content ol ol,
         .rules-content ul ol,
         .rules-content ol ul {
             margin-bottom: 5px; /* Less space for nested lists */
         }

        .rules-content li {
            margin-bottom: 5px;
        }

        .rules-content strong {
            font-weight: 600; /* Make bold text stand out */
        }

        /* --- Mobile Responsiveness --- */
        @media (max-width: 850px) {

            /* Adjust layout for smaller screens */
            body {
                padding: 5px;
            }

            h1 {
                font-size: 1.5em;
                margin-bottom: 10px;
            }

            main {
                flex-direction: column;
                align-items: center;
                gap: 15px;
                padding: 0 5px;
                max-width: 100%;
            }

            /* Stack board and UI vertically */
            #board {
                width: 95vw;
                /* Use viewport width */
                max-width: var(--board-max-width);
                /* Still respect max width */
                padding: 10px 8px;
                /* Slightly reduce padding */
                order: 1;
                /* Place board first */
            }

            #ui-info-section {
                width: 95vw;
                max-width: var(--board-max-width);
                /* Match board max width */
                order: 2;
                /* Place UI below board */
            }

            /* Reduce log heights */
            #move-log {
                height: 150px;
            }

            #board-state-log {
                max-height: 60px;
            }

            .button-container {
                padding-top: 10px;
            }

            .game-button {
                padding: 8px 12px;
                font-size: 0.9em;
            }

            #debug-log-container {
                margin-top: 15px;
                width: 95vw;
                max-width: var(--board-max-width);
            }

            #debug-log-output {
                height: 150px;
            }
        }
    </style>
</head>

<body>

    <h1>CLESTO: The Jungle Chess Game</h1>

    <main id="game-container" role="main">
        <!-- Game Board Section -->
        <section aria-labelledby="board-label">
            <h2 id="board-label" class="visually-hidden">Game Board</h2>
            <div id="board" tabindex="0"> <!-- Outer container for board background/focus -->
                <div id="board-grid-wrapper"> <!-- Inner container for grid layout and pieces -->
                    <!-- Cells will be generated by JavaScript here -->
                </div>
            </div>
        </section>

        <!-- UI and Information Section -->
        <section id="ui-info-section" role="region" aria-labelledby="ui-info-heading">
            <h2 id="ui-info-heading">Game Info</h2>

            <!-- START: Clock Displays -->
            <div class="clock-container" id="orange-clock-container">
                <span class="clock-label">Orange Time:</span>
                <span class="clock-time" id="orange-clock-time">10:00</span>
            </div>
            <div class="clock-container" id="yellow-clock-container">
                <span class="clock-label">Yellow Time:</span>
                <span class="clock-time" id="yellow-clock-time">10:00</span>
            </div>
            <!-- END: Clock Displays -->

            <p>Turn: <span id="turn-indicator">Orange</span></p>
            <p>Status: <span id="status-message" aria-live="polite">Loading...</span></p>

            <!-- Player vs Player Toggle -->
            <div class="pvp-toggle-container">
                <label for="pvp-toggle" class="pvp-label">Player vs Player Mode:</label>
                <label class="switch">
                    <input type="checkbox" id="pvp-toggle">
                    <span class="slider round"></span>
                </label>
            </div>

            <div class="button-container">
                <button id="undo-button" class="game-button" disabled>Undo Turn</button>
                <button id="reset-button" class="game-button">Reset Game</button>
            </div>

            <h3>Move Log</h3>
            <div id="move-log" role="log" aria-live="polite" aria-atomic="false">
                <!-- Log entries will be added by JavaScript here -->
            </div>

            <h3>Board State</h3>
            <div id="board-state-log">
                <!-- Board state string for debugging/repetition check -->
            </div>

            <!-- Load From State Section -->
            <div style="margin-top: 15px; border-top: 1px solid var(--medium-gray); padding-top: 10px;">
                <label for="board-state-input" style="display: block; margin-bottom: 5px; font-weight: bold;">Load Board State:</label>
                <input type="text" id="board-state-input" placeholder="Paste board state (e.g., 8G7,7A9,...)" style="width: calc(100% - 12px); padding: 6px; margin-bottom: 8px; border: 1px solid var(--medium-gray); border-radius: 3px;">
                <button id="load-state-button" class="game-button" style="background-color: #28a745;">Load Board State</button> <!-- Green button -->
                <p id="load-status-message" style="font-size: 0.85em; color: #6c757d; min-height: 1.2em; margin-top: 5px;"></p>
            </div>
            <!-- End Load From State Section -->
        </section>
    </main>

    <!-- Rules Accordion Section -->
    <section id="rules-accordion-container" aria-labelledby="rules-heading">
        <button id="rules-toggle-button" class="rules-toggle-button" aria-expanded="false" aria-controls="rules-content">
            <span class="rules-button-text">Show Game Rules</span>
            <span class="rules-icon" aria-hidden="true">+</span>
        </button>
        <div id="rules-content" class="rules-content" role="region" aria-hidden="true">
            <h2 id="rules-heading" class="visually-hidden">Game Rules</h2>

            <h3>Objective</h3>
            <p>Be the first player to move any of your animals into the opponent's <strong>Den</strong> square.</p>
            <ul>
                <li>Orange's Den: <strong>d1</strong></li>
                <li>Yellow's Den: <strong>d9</strong></li>
            </ul>

            <h3>Gameplay</h3>
            <ul>
                <li>Orange starts the game.</li>
                <li>Players take turns moving one animal per turn.</li>
                <li>Animals move one square horizontally or vertically (never diagonally).</li>
                <li>You cannot move onto a square occupied by your own animal.</li>
            </ul>

            <h4>Attacking</h4>
            <ul>
                <li>You can move onto a square occupied by an opponent's animal if your animal's rank is <strong>equal to or higher than</strong> the opponent's rank.</li>
                <li>This is an attack, and the opponent's captured animal is removed from the board.</li>
                <li><strong>Exception:</strong> See Special Powers for Rat vs. Elephant.</li>
            </ul>

            <h4>End of Turn Sequence</h4>
            <p>After making your move, the following checks happen automatically:</p>
            <ol>
                <li><strong>Declare Hungry:</strong> Any of the <em>opponent's</em> animals that can now make a valid attack are marked as <strong>hungry</strong> (red glow).</li>
                <li><strong>Check Starvation:</strong> If any of <em>your own</em> animals were marked as hungry at the <em>start</em> of your turn, but you did not make an attacking move with any of them, those hungry animals starve and are removed from the board.</li>
            </ol>

            <h4>Special Squares</h4>
            <ul>
                <li><strong>Den:</strong> Your own Den (Orange: d1, Yellow: d9) cannot be entered by your pieces. Reaching the opponent's Den wins the game. A <strong>hungry</strong> animal cannot enter the opponent's Den.</li>
                <li><strong>Water (b4-c6, e4-f6):</strong> Only specific animals can enter or move on water (see Special Powers).</li>
                <li><strong>Traps:</strong>
                    <ul>
                        <li>Orange Traps: <strong>c1, d2, e1</strong></li>
                        <li>Yellow Traps: <strong>c9, d8, e9</strong></li>
                    </ul>
                    Any animal landing on a Trap square has its rank effectively reduced to <strong>0</strong> for the purpose of being attacked while on that square. A "(0)" marker appears above trapped animals. However, an animal attacking <em>from</em> a trap square uses its normal rank.
                 </li>
            </ul>

            <h4>Other Rules</h4>
            <ul>
                <li>You must make a move each turn (passing is not allowed).</li>
                <li>The game cannot end in a draw.</li>
            </ul>

            <h3>Special Powers</h3>
            <ul>
                <li><strong>Rat [1]:</strong>
                    <ul>
                        <li>Can enter, move on, and <strong>attack from Water</strong> squares.</li>
                        <li>Can attack the <strong>Elephant [8]</strong>, but only when attacking from a land square (cannot attack Elephant when starting from Water).</li>
                    </ul>
                 </li>
                 <li><strong>Dog [3]:</strong>
                    <ul>
                         <li>Can enter, move on, and <strong>attack from Water</strong> squares.</li>
                    </ul>
                 </li>
                 <li><strong>Lion [7] and Tiger [6]:</strong>
                    <ul>
                        <li>Can <strong>jump</strong> horizontally or vertically over <strong>Water</strong> squares.</li>
                        <li>A jump moves from a land square directly across 2 or 3 water squares to another land square.</li>
                        <li>Jumps can be used to move or attack.</li>
                        <li>A jump is blocked if an opponent's swimming animal (Rat or Dog) occupies any water square along the jump path.</li>
                    </ul>
                </li>
                 <li><strong>Leopard [5]:</strong>
                    <ul>
                        <li>Can <strong>jump horizontally</strong> over <strong>Water</strong> squares (across 2 water squares).</li>
                        <li>Cannot jump vertically.</li>
                        <li>Jumps follow the same blocking rules as Lion/Tiger.</li>
                    </ul>
                </li>
                <li><strong>Elephant [8]:</strong> Can attack the Rat [1].</li>
            </ul>

            <h3>Repetition Limit</h3>
            <p>To prevent endless loops and ensure a winner, a repetition rule exists:</p>
            <ul>
                <li>Determine which player currently has more animals on the board. If tied, the starting player (Orange) is considered the "leading player".</li>
                <li>The leading player is <strong>not allowed</strong> to make a move that results in a board position that has already occurred <strong>3 times</strong> previously during the game.</li>
            </ul>
            <p><em>(Board positions are tracked automatically.)</em></p>

        </div><!-- /#rules-content -->
    </section><!-- /#rules-accordion-container -->

    <!-- Debug Log Section (conditionally displayed) -->
    <section id="debug-log-container" aria-labelledby="debug-log-heading">
        <h2 id="debug-log-heading">Debug Log</h2>
        <div id="debug-log-output">
            <!-- Console messages mirrored here if debug = true -->
        </div>
        <button id="clear-debug-log" class="game-button" style="margin-top: 10px; background-color: #dc3545;">Clear Log</button>
    </section>

    <!-- Utility class to visually hide elements but keep them accessible -->
    <style>
        .visually-hidden {
            position: absolute;
            width: 1px;
            height: 1px;
            margin: -1px;
            padding: 0;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            border: 0;
        }
    </style>

    <!-- Hidden container for preloading/caching piece image assets -->
    <div id="piece-assets" style="display: none;">
        <!-- Orange Pieces -->
        <img data-piece="O_8" src="https://staticjw.com/clesto/animals/elephant-orange.png" alt="Orange Elephant (8)" loading="lazy">
        <img data-piece="O_7" src="https://staticjw.com/clesto/animals/lion-orange.png" alt="Orange Lion (7)" loading="lazy">
        <img data-piece="O_6" src="https://staticjw.com/clesto/animals/tiger-orange.png" alt="Orange Tiger (6)" loading="lazy">
        <img data-piece="O_5" src="https://staticjw.com/clesto/animals/leopard-orange.png" alt="Orange Leopard (5)" loading="lazy">
        <img data-piece="O_4" src="https://staticjw.com/clesto/animals/wolf-orange.png" alt="Orange Wolf (4)" loading="lazy">
        <img data-piece="O_3" src="https://staticjw.com/clesto/animals/dog-orange.png" alt="Orange Dog (3)" loading="lazy">
        <img data-piece="O_2" src="https://staticjw.com/clesto/animals/cat-orange.png" alt="Orange Cat (2)" loading="lazy">
        <img data-piece="O_1" src="https://staticjw.com/clesto/animals/rat-orange.png" alt="Orange Rat (1)" loading="lazy">
        <!-- Yellow Pieces -->
        <img data-piece="Y_8" src="https://staticjw.com/clesto/animals/elephant-yellow.png" alt="Yellow Elephant (8)" loading="lazy">
        <img data-piece="Y_7" src="https://staticjw.com/clesto/animals/lion-yellow.png" alt="Yellow Lion (7)" loading="lazy">
        <img data-piece="Y_6" src="https://staticjw.com/clesto/animals/tiger-yellow.png" alt="Yellow Tiger (6)" loading="lazy">
        <img data-piece="Y_5" src="https://staticjw.com/clesto/animals/leopard-yellow.png" alt="Yellow Leopard (5)" loading="lazy">
        <img data-piece="Y_4" src="https://staticjw.com/clesto/animals/wolf-yellow.png" alt="Yellow Wolf (4)" loading="lazy">
        <img data-piece="Y_3" src="https://staticjw.com/clesto/animals/dog-yellow.png" alt="Yellow Dog (3)" loading="lazy">
        <img data-piece="Y_2" src="https://staticjw.com/clesto/animals/cat-yellow.png" alt="Yellow Cat (2)" loading="lazy">
        <img data-piece="Y_1" src="https://staticjw.com/clesto/animals/rat-yellow.png" alt="Yellow Rat (1)" loading="lazy">
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Debug Flag ---
            const debug = true; // SET TO true TO SHOW DEBUG PANEL, false TO HIDE

            // --- DOM Element References ---
            const boardElement = document.getElementById('board');
            const boardGridWrapper = document.getElementById('board-grid-wrapper');
            const turnIndicator = document.getElementById('turn-indicator');
            const statusMessage = document.getElementById('status-message');
            const resetButton = document.getElementById('reset-button');
            const undoButton = document.getElementById('undo-button');
            const moveLogElement = document.getElementById('move-log');
            const boardStateLogElement = document.getElementById('board-state-log');
            const pieceAssetContainer = document.getElementById('piece-assets');
            const debugLogContainer = document.getElementById('debug-log-container');
            const debugLogOutput = document.getElementById('debug-log-output');
            const clearDebugLogButton = document.getElementById('clear-debug-log');

            // --- Console Override & Debug Panel Logic ---
            // Store original console methods
            const originalConsole = {
                log: console.log,
                warn: console.warn,
                error: console.error
            };

            /**
             * Formats console arguments into a single string, handling objects and circular references.
             * @param {Array} args - The arguments passed to the console method.
             * @returns {string} A formatted string representation of the arguments.
             */
            function formatArgs(args) {
                const seen = new Set(); // Used to detect circular references in objects
                return Array.from(args).map(arg => {
                    if (typeof arg === 'object' && arg !== null) {
                        try {
                            // Stringify objects, handling circular references
                            seen.clear(); // Reset for each top-level object
                            return JSON.stringify(arg, (key, value) => {
                                if (typeof value === 'object' && value !== null) {
                                    if (seen.has(value)) {
                                        return '[Circular]'; // Placeholder for circular reference
                                    }
                                    seen.add(value);
                                }
                                return value;
                            }, 2); // Indent with 2 spaces for readability
                        } catch (e) {
                            // Handle potential errors during stringification
                            if (e instanceof TypeError && e.message.includes('circular structure')) {
                                return '[Circular Object]';
                            }
                            return '[Unserializable Object]';
                        }
                    }
                    if (typeof arg === 'function') {
                        return '[Function]';
                    }
                    if (typeof arg === 'undefined') {
                        return 'undefined';
                    }
                    return String(arg); // Convert other types to string
                }).join(' '); // Join arguments with spaces
            }

            /**
             * Logs a message to the debug panel if debugging is enabled.
             * @param {string} level - The log level ('log', 'warn', 'error').
             * @param {Array} args - The original arguments passed to the console method.
             */
            function logToPanel(level, args) {
                if (!debug || !debugLogOutput) return; // Only log if debug is true and panel exists

                const message = formatArgs(args);
                const timestamp = new Date().toLocaleTimeString();
                const entry = document.createElement('div');
                entry.classList.add('debug-log-entry');

                // Add timestamp
                const timeSpan = document.createElement('span');
                timeSpan.classList.add('debug-log-timestamp');
                timeSpan.textContent = `[${timestamp}]`;
                entry.appendChild(timeSpan);

                // Add message content with appropriate styling
                const messageSpan = document.createElement('span');
                messageSpan.textContent = message;
                if (level === 'warn') {
                    messageSpan.classList.add('debug-log-warn');
                } else if (level === 'error') {
                    messageSpan.classList.add('debug-log-error');
                }
                entry.appendChild(messageSpan);

                // Append to panel and scroll to bottom
                debugLogOutput.appendChild(entry);
                debugLogOutput.scrollTop = debugLogOutput.scrollHeight;
            }

            // Override console methods to also log to the panel
            console.log = function(...args) {
                originalConsole.log.apply(console, args); // Call original console.log
                logToPanel('log', args); // Log to panel
            };
            console.warn = function(...args) {
                originalConsole.warn.apply(console, args); // Call original console.warn
                logToPanel('warn', args); // Log to panel
            };
            console.error = function(...args) {
                originalConsole.error.apply(console, args); // Call original console.error
                logToPanel('error', args); // Log to panel
            };

            // Show or hide the debug panel based on the debug flag
            if (!debug && debugLogContainer) {
                debugLogContainer.classList.add('debug-hidden');
            } else if (debugLogContainer) {
                debugLogContainer.classList.remove('debug-hidden');
            }

            // Add event listener for the "Clear Log" button
            if (clearDebugLogButton && debugLogOutput) {
                clearDebugLogButton.addEventListener('click', () => {
                    debugLogOutput.innerHTML = ''; // Clear panel content
                    console.log("Debug log cleared.");
                });
            }
            // --- END Console Override ---


            // --- Game Constants ---
            const ROWS = 9;
            const COLS = 7;
            const PLAYERS = {
                ORANGE: 'orange',
                YELLOW: 'yellow'
            };
            const RANK_TO_NAME = {
                8: 'Elephant',
                7: 'Lion',
                6: 'Tiger',
                5: 'Leopard',
                4: 'Wolf',
                3: 'Dog',
                2: 'Cat',
                1: 'Rat'
            };
            const RANK_TO_CODE = { // Used for move notation
                8: '8',
                7: '7',
                6: '6',
                5: '5',
                4: '4',
                3: '3',
                2: '2',
                1: '1'
            };
            const SPECIAL_ABILITIES = { // Defines unique animal traits
                1: {
                    name: 'Rat',
                    rank: 1,
                    swims: true,
                    attacksElephant: true
                }, // Can swim, attack Elephant (unless Elephant is in water)
                2: {
                    name: 'Cat',
                    rank: 2
                },
                3: {
                    name: 'Dog',
                    rank: 3,
                    swims: true
                }, // Can swim
                4: {
                    name: 'Wolf',
                    rank: 4
                },
                5: {
                    name: 'Leopard',
                    rank: 5,
                    jumpH: true
                }, // Can jump horizontally over water
                6: {
                    name: 'Tiger',
                    rank: 6,
                    jumpH: true,
                    jumpV: true
                }, // Can jump horizontally and vertically over water
                7: {
                    name: 'Lion',
                    rank: 7,
                    jumpH: true,
                    jumpV: true
                }, // Can jump horizontally and vertically over water
                8: {
                    name: 'Elephant',
                    rank: 8
                } // Cannot be attacked by Rat (except special case)
            };
            const INITIAL_SETUP = { // Standard starting positions
                // Orange Pieces (Bottom Row Area) - Sorted Rank 8 to 1
                'a3': { player: PLAYERS.ORANGE, rank: 8 }, // Elephant
                'g1': { player: PLAYERS.ORANGE, rank: 7 }, // Lion
                'a1': { player: PLAYERS.ORANGE, rank: 6 }, // Tiger
                'e3': { player: PLAYERS.ORANGE, rank: 5 }, // Leopard
                'f2': { player: PLAYERS.ORANGE, rank: 4 }, // Wolf
                'c3': { player: PLAYERS.ORANGE, rank: 3 }, // Dog
                'b2': { player: PLAYERS.ORANGE, rank: 2 }, // Cat
                'g3': { player: PLAYERS.ORANGE, rank: 1 }, // Rat
                // Yellow Pieces (Top Row Area) - Sorted Rank 8 to 1
                'g7': { player: PLAYERS.YELLOW, rank: 8 }, // Elephant
                'a9': { player: PLAYERS.YELLOW, rank: 7 }, // Lion
                'g9': { player: PLAYERS.YELLOW, rank: 6 }, // Tiger
                'c7': { player: PLAYERS.YELLOW, rank: 5 }, // Leopard
                'b8': { player: PLAYERS.YELLOW, rank: 4 }, // Wolf
                'e7': { player: PLAYERS.YELLOW, rank: 3 }, // Dog
                'f8': { player: PLAYERS.YELLOW, rank: 2 }, // Cat
                'a7': { player: PLAYERS.YELLOW, rank: 1 }  // Rat
            };
            const WATER_SQUARES = new Set(['b4', 'c4', 'e4', 'f4', 'b5', 'c5', 'e5', 'f5', 'b6', 'c6', 'e6', 'f6']);
            const TRAPS = { // Opponent's pieces lose rank on these squares
                orange: new Set(['c9', 'd8', 'e9']), // Traps near Yellow's Den (affect Yellow pieces)
                yellow: new Set(['c1', 'd2', 'e1']) // Traps near Orange's Den (affect Orange pieces)
            };
            const ALL_TRAP_SQUARES = new Set([...TRAPS.orange, ...TRAPS.yellow]);
            const DENS = { // Winning squares for each player
                orange: 'd1', // Orange's Den
                yellow: 'd9' // Yellow's Den
            };
            const MINIMAX_DEPTH = 3; // Depth for AI search (higher = stronger but slower)


            // --- Game State Variables ---
            let gameState = {}; // Holds current board, player, turn, etc.
            let gameHistory = []; // Stores previous game states for undo functionality
            let draggedPieceElement = null; // Reference to the DOM element being dragged
            let sourceCoords = null; // Coordinates of the piece being dragged/clicked
            let selectedPieceCoords = null; // Coordinates of the piece selected via click/tap
            let focusedCoords = null; // Coordinates of the currently focused cell/piece (for keyboard nav)
            let playerLastMoves = {
                [PLAYERS.ORANGE]: { from: null, to: null },
                [PLAYERS.YELLOW]: { from: null, to: null }
            };
            let isDragging = false; // Flag to track if a drag operation is in progress
            let isPlayerVsPlayerMode = false; // Flag for PvP mode (default is PvE)
            let aiMoveTimeoutId = null; // To store the AI delay timeout
            let isLoadStateInputFocused = false; // Flag for input focus

            // --- Clock Constants & State ---
            const INITIAL_TIME_SECONDS = 10 * 60; // 10 minutes
            const INCREMENT_SECONDS = 2; // 2 seconds bonus per move
            let orangeTime = INITIAL_TIME_SECONDS;
            let yellowTime = INITIAL_TIME_SECONDS;
            let orangeTimerId = null; // To store the interval ID for Orange's clock
            let yellowTimerId = null; // To store the interval ID for Yellow's clock

            // --- DOM Element References (Add Clock Elements) ---
            const orangeClockContainer = document.getElementById('orange-clock-container');
            const yellowClockContainer = document.getElementById('yellow-clock-container');
            const orangeClockTimeElement = document.getElementById('orange-clock-time');
            const yellowClockTimeElement = document.getElementById('yellow-clock-time');


            // --- Utility Functions ---
            /**
             * Converts zero-based row and column indices to algebraic notation (e.g., 0,0 -> 'a9').
             * @param {number} row - The row index (0-8).
             * @param {number} col - The column index (0-6).
             * @returns {string|null} The algebraic coordinates (e.g., 'a1', 'g9') or null if invalid.
             */
            function getCoords(row, col) {
                if (row < 0 || row >= ROWS || col < 0 || col >= COLS) return null;
                // Column 'a' is ASCII 97. Row 9 is at index 0.
                return `${String.fromCharCode(97 + col)}${ROWS - row}`;
            }

            /**
             * Converts algebraic notation coordinates to zero-based row and column indices.
             * @param {string} coords - The algebraic coordinates (e.g., 'a1').
             * @returns {{row: number, col: number}|null} An object with row and col indices, or null if invalid.
             */
            function getRowCol(coords) {
                if (!coords || coords.length < 2) return null;
                const col = coords.charCodeAt(0) - 97; // 'a' -> 0, 'b' -> 1, ...
                const rowNum = parseInt(coords.substring(1));
                if (isNaN(rowNum)) return null;
                const row = ROWS - rowNum; // '9' -> 0, '8' -> 1, ...
                if (row < 0 || row >= ROWS || col < 0 || col >= COLS) return null;
                return { row, col };
            }

            /**
             * Determines which player is currently restricted by the repetition rule.
             * The player with more pieces is restricted. If piece counts are equal, Orange is restricted.
             * @param {object} [board=gameState.board] - The board state to evaluate. Defaults to current game state.
             * @returns {string} The player ('orange' or 'yellow') who is restricted.
             */
            function getRestrictedPlayer(board = gameState.board) {
                const orangeCount = Object.values(board).filter(p => p?.player === PLAYERS.ORANGE).length;
                const yellowCount = Object.values(board).filter(p => p?.player === PLAYERS.YELLOW).length;

                if (orangeCount > yellowCount) {
                    return PLAYERS.ORANGE;
                } else if (yellowCount > orangeCount) {
                    return PLAYERS.YELLOW;
                } else {
                    // If counts are equal, the starting player (Orange) is restricted
                    return PLAYERS.ORANGE;
                }
            }

            /**
             * Retrieves the data object for a piece at the given coordinates from the current game state.
             * @param {string} coords - The algebraic coordinates (e.g., 'a1').
             * @returns {object|null} The piece data object ({player, rank, ...}) or null if the square is empty.
             */
            function getPieceData(coords) {
                return gameState.board[coords] || null;
            }

            /**
             * Generates the DOM ID for a piece element based on its coordinates.
             * @param {string} coords - The coordinates (e.g., 'a1').
             * @returns {string} The DOM ID string (e.g., 'piece-a1').
             */
            function getPieceElementId(coords) {
                return `piece-${coords}`;
            }

            /**
             * Generates the DOM ID for a cell element based on coordinates.
             * @param {string} coords - The coordinates (e.g., 'a1').
             * @returns {string} The DOM ID string (e.g., 'cell-a1').
             */
            function getCellElementId(coords) {
                return `cell-${coords}`;
            }

            /**
             * Gets orthogonal adjacent coordinates for a given square.
             * @param {string} coords - The algebraic coordinates (e.g., 'd9').
             * @returns {string[]} An array of valid adjacent coordinate strings.
             */
            function getAdjacentCoords(coords) {
                const adjacent = [];
                const rc = getRowCol(coords);
                if (!rc) return [];
                const { row, col } = rc;
                const potential = [
                    getCoords(row + 1, col), // Down
                    getCoords(row - 1, col), // Up
                    getCoords(row, col + 1), // Right
                    getCoords(row, col - 1)  // Left
                ];
                potential.forEach(c => {
                    if (c) adjacent.push(c); // Add if valid coords
                });
                return adjacent;
            }

            /**
             * Gets a set of unique adjacent coordinates for a given set of starting coordinates.
             * @param {Set<string>} coordsSet - A Set of algebraic coordinates (e.g., trap squares).
             * @returns {Set<string>} A Set of unique, valid adjacent coordinate strings.
             */
            function getAdjacentCoordsSet(coordsSet) {
                const allAdjacent = new Set();
                if (!coordsSet) return allAdjacent;

                coordsSet.forEach(coord => {
                    const adjacent = getAdjacentCoords(coord); // Use existing helper
                    adjacent.forEach(adjCoord => {
                        if (adjCoord) allAdjacent.add(adjCoord);
                    });
                });
                return allAdjacent;
            }

            /**
             * Checks if the given coordinates correspond to ANY trap square.
             * @param {string} coords - The algebraic coordinates to check.
             * @returns {boolean} True if the coordinates are a trap square, false otherwise.
             */
            function isOnTrapSquare(coords) {
                if (!coords) return false;
                // Use the pre-defined Set containing all trap squares
                return ALL_TRAP_SQUARES.has(coords);
            }

            /**
             * Formats remaining seconds into MM:SS string format.
             * @param {number} totalSeconds - The total seconds remaining.
             * @returns {string} Formatted time string (e.g., "09:58").
             */
            function formatTime(totalSeconds) {
                const seconds = Math.max(0, totalSeconds); // Ensure time doesn't go below 0
                const minutes = Math.floor(seconds / 60);
                const remainingSeconds = Math.floor(seconds % 60);
                const formattedMinutes = String(minutes).padStart(2, '0');
                const formattedSeconds = String(remainingSeconds).padStart(2, '0');
                return `${formattedMinutes}:${formattedSeconds}`;
            }

            /**
             * Updates the clock display for a specific player in the DOM.
             * @param {string} player - The player ('orange' or 'yellow').
             * @param {number} timeSeconds - The time in seconds to display.
             */
            function updateClockDisplay(player, timeSeconds) {
                const formattedTime = formatTime(timeSeconds);
                if (player === PLAYERS.ORANGE && orangeClockTimeElement) {
                    orangeClockTimeElement.textContent = formattedTime;
                } else if (player === PLAYERS.YELLOW && yellowClockTimeElement) {
                    yellowClockTimeElement.textContent = formattedTime;
                }
            }

            /**
             * Stops the interval timer for a specific player's clock.
             * @param {string} player - The player ('orange' or 'yellow').
             */
            function stopClock(player) {
                if (player === PLAYERS.ORANGE) {
                    if (orangeTimerId !== null) {
                        clearInterval(orangeTimerId);
                        orangeTimerId = null;
                        // console.log("Stopped Orange Clock");
                    }
                     if (orangeClockContainer) orangeClockContainer.classList.remove('clock-active');
                } else if (player === PLAYERS.YELLOW) {
                    if (yellowTimerId !== null) {
                        clearInterval(yellowTimerId);
                        yellowTimerId = null;
                        // console.log("Stopped Yellow Clock");
                    }
                    if (yellowClockContainer) yellowClockContainer.classList.remove('clock-active');
                }
            }

            /**
             * Starts the interval timer for a specific player's clock.
             * @param {string} player - The player ('orange' or 'yellow') whose clock to start.
             */
            function startClock(player) {
                // Don't start if game is over
                if (gameState.gameOver) return;

                // Stop the other player's clock first (safety measure)
                const otherPlayer = player === PLAYERS.ORANGE ? PLAYERS.YELLOW : PLAYERS.ORANGE;
                stopClock(otherPlayer);

                // Clear existing timer for the target player before starting a new one
                stopClock(player);

                // console.log(`Starting Clock for: ${player}`);
                const tick = () => {
                    if (player === PLAYERS.ORANGE) {
                        orangeTime--;
                        updateClockDisplay(PLAYERS.ORANGE, orangeTime);
                        if (orangeTime <= 0) {
                            // console.log("Orange time ran out.");
                            stopClock(PLAYERS.ORANGE); // Stop the clock at 00:00
                            // Requirement: Do nothing else when time runs out
                        }
                    } else if (player === PLAYERS.YELLOW) {
                        yellowTime--;
                        updateClockDisplay(PLAYERS.YELLOW, yellowTime);
                        if (yellowTime <= 0) {
                            // console.log("Yellow time ran out.");
                            stopClock(PLAYERS.YELLOW); // Stop the clock at 00:00
                             // Requirement: Do nothing else when time runs out
                        }
                    }
                };

                // Initial immediate tick to avoid 1-second delay on start/resume
                tick();
                // Then set the interval
                if (player === PLAYERS.ORANGE) {
                    orangeTimerId = setInterval(tick, 1000);
                    if(orangeClockContainer) orangeClockContainer.classList.add('clock-active');
                } else if (player === PLAYERS.YELLOW) {
                    yellowTimerId = setInterval(tick, 1000);
                    if(yellowClockContainer) yellowClockContainer.classList.add('clock-active');
                }
            }

            /**
             * Stops both players' clocks. Used for game end or pausing.
             */
            function pauseAllClocks() {
                stopClock(PLAYERS.ORANGE);
                stopClock(PLAYERS.YELLOW);
                console.log("Paused All Clocks");
            }

            /**
             * Resets clock times to initial values and updates displays. Stops timers.
             */
            function initializeClocks() {
                pauseAllClocks(); // Ensure any running timers are stopped
                orangeTime = INITIAL_TIME_SECONDS;
                yellowTime = INITIAL_TIME_SECONDS;
                updateClockDisplay(PLAYERS.ORANGE, orangeTime);
                updateClockDisplay(PLAYERS.YELLOW, yellowTime);
                 if(orangeClockContainer) orangeClockContainer.classList.remove('clock-active');
                 if(yellowClockContainer) yellowClockContainer.classList.remove('clock-active');
                console.log("Clocks Initialized");
            }

             /**
             * Stops the clock of the player who just moved, adds increment, updates their display,
             * and starts the opponent's clock. Call this *before* switching gameState.currentPlayer.
             * @param {string} playerWhoMoved - The player who just completed their move.
             */
            function switchClocks(playerWhoMoved) {
                if (gameState.gameOver) return; // Don't switch if game ended

                // 1. Stop the clock for the player who moved
                stopClock(playerWhoMoved);

                // 2. Add increment
                if (playerWhoMoved === PLAYERS.ORANGE) {
                    orangeTime += INCREMENT_SECONDS;
                    updateClockDisplay(PLAYERS.ORANGE, orangeTime);
                } else if (playerWhoMoved === PLAYERS.YELLOW) {
                    yellowTime += INCREMENT_SECONDS;
                    updateClockDisplay(PLAYERS.YELLOW, yellowTime);
                }
                 console.log(`${playerWhoMoved} clock stopped, increment added.`);

                // 3. Start the opponent's clock
                const opponent = playerWhoMoved === PLAYERS.ORANGE ? PLAYERS.YELLOW : PLAYERS.ORANGE;
                startClock(opponent);
            }

            /**
             * Resumes the clock for the currently active player based on gameState.
             * Used after loading state (undo) or switching game modes.
             */
            function resumeClockForCurrentPlayer() {
                 if (gameState.gameOver) {
                     pauseAllClocks();
                     return;
                 }
                 console.log(`Resuming clock for current player: ${gameState.currentPlayer}`);
                 startClock(gameState.currentPlayer);
            }

            // --- Board Creation and Setup ---

            /**
             * Creates the grid of cell elements and appends them to the board wrapper.
             * Assigns IDs, data attributes, classes for terrain, and event listeners.
             */
            function createBoard() {
                boardGridWrapper.innerHTML = ''; // Clear existing board elements
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        const cell = document.createElement('div');
                        const coords = getCoords(r, c);
                        cell.id = getCellElementId(coords);
                        cell.classList.add('cell');
                        cell.dataset.coords = coords; // Store coords for easy access
                        cell.dataset.row = r;
                        cell.dataset.col = c;
                        cell.setAttribute('role', 'gridcell'); // Accessibility
                        cell.setAttribute('tabindex', '-1'); // Make focusable via script/keyboard nav

                        // Add terrain classes based on coordinates
                        if (WATER_SQUARES.has(coords)) cell.classList.add('water');
                        if (TRAPS.orange.has(coords)) cell.classList.add('trap-yellow'); // Trap in Yellow's area
                        if (TRAPS.yellow.has(coords)) cell.classList.add('trap-orange'); // Trap in Orange's area
                        if (DENS.orange === coords) cell.classList.add('den-orange');
                        if (DENS.yellow === coords) cell.classList.add('den-yellow');

                        boardGridWrapper.appendChild(cell);

                        // Add event listeners for drag & drop and clicks
                        cell.addEventListener('dragover', handleDragOver);
                        cell.addEventListener('dragenter', handleDragEnter);
                        cell.addEventListener('dragleave', handleDragLeave);
                        cell.addEventListener('drop', handleDrop);
                        cell.addEventListener('click', handleCellClick);
                        cell.addEventListener('focus', () => focusedCoords = coords); // Track focus for keyboard nav
                    }
                }
            }

            /**
             * Creates a DOM element for a game piece.
             * @param {object} pieceData - The piece data ({ player, rank, ... }).
             * @param {string} coords - The algebraic coordinates where the piece is located.
             * @returns {HTMLElement} The created piece div element.
             */
            function createPieceElement(pieceData, coords) {
                const pieceElement = document.createElement('div');
                pieceElement.id = getPieceElementId(coords);
                pieceElement.classList.add('piece');
                pieceElement.dataset.rank = pieceData.rank;
                pieceElement.dataset.player = pieceData.player;
                pieceElement.dataset.coords = coords;
                pieceElement.setAttribute('role', 'button'); // Treat piece like a button for accessibility
                pieceElement.setAttribute('aria-label', `${pieceData.player} ${RANK_TO_NAME[pieceData.rank]} at ${coords}`);
                pieceElement.setAttribute('tabindex', '-1'); // Make focusable conditionally

                // Find and clone the corresponding image from the hidden asset container
                const pieceKey = `${pieceData.player === PLAYERS.ORANGE ? 'O' : 'Y'}_${pieceData.rank}`;
                const asset = pieceAssetContainer.querySelector(`[data-piece="${pieceKey}"]`);

                if (asset && asset.tagName === 'IMG') {
                    const img = asset.cloneNode(true); // Clone the preloaded image
                    pieceElement.appendChild(img);
                } else {
                    // Fallback if image asset is missing
                    console.warn("Image asset not found for:", pieceKey);
                    pieceElement.textContent = `${pieceData.player === PLAYERS.ORANGE ? 'O' : 'Y'}${pieceData.rank}`; // Display text
                    pieceElement.classList.add(pieceData.player); // Add player color class
                }

                // Add event listeners for interactions
                pieceElement.addEventListener('dragstart', handleDragStart);
                pieceElement.addEventListener('dragend', handleDragEnd);
                pieceElement.addEventListener('touchstart', handleTouchStart, { passive: false }); // Need preventDefault
                pieceElement.addEventListener('touchmove', handleTouchMove, { passive: false }); // Need preventDefault
                pieceElement.addEventListener('touchend', handleTouchEnd);
                pieceElement.addEventListener('click', handlePieceClick);
                pieceElement.addEventListener('mouseover', handlePieceMouseOver); // For hover effects
                pieceElement.addEventListener('mouseout', handlePieceMouseOut);
                pieceElement.addEventListener('focus', () => focusedCoords = coords); // Track focus

                // Allow pieces to be drop targets (for captures)
                pieceElement.addEventListener('drop', handleDrop);
                pieceElement.addEventListener('dragover', handleDragOver);
                pieceElement.addEventListener('dragenter', handleDragEnterPiece);
                pieceElement.addEventListener('dragleave', handleDragLeavePiece);
                // Add the trap indicator span (initially hidden)
                const indicatorSpan = document.createElement('span');
                indicatorSpan.classList.add('trap-rank-indicator'); // Base class for styling
                indicatorSpan.textContent = '(0)'; // The text content
                pieceElement.appendChild(indicatorSpan); // Append it inside the piece div

                return pieceElement;
            }

            /**
             * Clears existing pieces from the board and places new ones based on the current game state.
             * Also applies initial hungry and trap indicator visuals.
             */
            function placePieces() {

                // Remove all existing piece elements from the board
                boardGridWrapper.querySelectorAll('.piece').forEach(p => p.remove());

                // Iterate through the board state and create/place pieces
                for (const coords in gameState.board) {
                    if (gameState.board.hasOwnProperty(coords)) {
                        const pieceData = gameState.board[coords];
                        if (!pieceData) {
                            console.warn(`Attempted to place null piece at ${coords}`);
                            continue;
                        }
                        // Create the piece element
                        const pieceElement = createPieceElement(pieceData, coords);
                        // Position it correctly on the grid
                        positionElementOnBoard(pieceElement, coords);
                        // Add it to the board
                        boardGridWrapper.appendChild(pieceElement);
                        // Apply 'hungry' visual if needed
                        updateHungryVisual(coords, pieceData.isHungry || false, pieceElement);
                        // Set initial accessibility (draggable/focusable) - will be refined below
                        // updatePieceAccessibility(pieceElement); // Deferred to end of function

                        // Check and apply trap indicator visual
                        const isPieceOnTrap = isOnTrapSquare(coords);
                        updateTrapIndicatorVisual(coords, isPieceOnTrap, pieceElement);
                    }
                }
                 // Ensure accessibility is correctly set after all pieces are placed
                 updateAllPieceAccessibility();
            }

            /**
             * Calculates and sets the absolute CSS position (left, top percentages) for a piece element
             * within the board grid wrapper, ensuring it's centered within its target cell.
             * Also ensures the piece maintains its aspect ratio.
             * @param {HTMLElement} element - The piece element to position.
             * @param {string} coords - The algebraic coordinates of the target cell.
             */
             function positionElementOnBoard(element, coords) {
                 const rc = getRowCol(coords);
                 if (!rc) {
                     console.error("Cannot position element, invalid coords:", coords);
                     return;
                 }
                 const { row, col } = rc;

                 // Calculate cell dimensions as percentages of the grid wrapper
                 const cellWidthPercent = 100 / COLS; // e.g., 100 / 7 ≈ 14.28%
                 const cellHeightPercent = 100 / ROWS; // e.g., 100 / 9 ≈ 11.11%

                 // Get the piece's width as a percentage of the wrapper (must match CSS)
                 const pieceWidthPercent = parseFloat(element.style.width || '12.07'); // Use CSS value or default

                 // Calculate piece height percentage to maintain 1:1 aspect ratio based on actual pixel dimensions
                 const wrapperWidth = boardGridWrapper.offsetWidth;
                 const wrapperHeight = boardGridWrapper.offsetHeight;
                 let pieceHeightPercent = pieceWidthPercent * (wrapperWidth / wrapperHeight); // Initial calculation based on width %

                 // If wrapper dimensions are available, refine the height percentage calculation
                 if (wrapperHeight > 0 && wrapperWidth > 0) {
                     const pieceWidthPx = wrapperWidth * (pieceWidthPercent / 100);
                     // Calculate the height % needed to make pixel height equal to pixel width
                     pieceHeightPercent = (pieceWidthPx / wrapperHeight) * 100;
                     // Explicitly set height style to ensure consistency if calculated
                     element.style.height = `${pieceHeightPercent}%`;
                 } else {
                    // Fallback if dimensions aren't ready - rely on aspect-ratio CSS
                    element.style.height = 'auto'; // Let CSS aspect-ratio handle height
                 }
                 // Ensure width is set (might have been auto initially)
                 element.style.width = `${pieceWidthPercent}%`;


                 // Calculate the top-left corner of the target cell (relative to the wrapper)
                 const cellLeftPercent = col * cellWidthPercent;
                 const cellTopPercent = row * cellHeightPercent;

                 // Calculate the offset needed to center the piece within the cell
                 const offsetXPercent = (cellWidthPercent - pieceWidthPercent) / 2;
                 const offsetYPercent = (cellHeightPercent - pieceHeightPercent) / 2; // Use the calculated piece height %

                 // Calculate the final top-left position for the piece element
                 const finalLeftPercent = cellLeftPercent + offsetXPercent;
                 const finalTopPercent = cellTopPercent + offsetYPercent;

                 // Apply the calculated position
                 element.style.left = `${finalLeftPercent}%`;
                 element.style.top = `${finalTopPercent}%`;

                 // Reset any transform applied during dragging/animations
                 element.style.transform = '';
                 // Update the element's coordinate data attribute
                 element.dataset.coords = coords;
             }


            /**
             * Updates the tabindex and draggable attributes of a piece element based on the current game state.
             * Pieces are only interactive (focusable, draggable) for the current player during their turn.
             * @param {HTMLElement} pieceElement - The piece element to update.
             */
            function updatePieceAccessibility(pieceElement) {
                if (!pieceElement) return;
                const piecePlayer = pieceElement.dataset.player;
                // --- MODIFIED CONDITION ---
                // Enable interaction if:
                // 1. Game is not over AND
                // 2. ( PvP mode is ON OR the piece belongs to the current player )
                const shouldBeInteractive = !gameState.gameOver &&
                                            (isPlayerVsPlayerMode || piecePlayer === gameState.currentPlayer);
                // --- END MODIFICATION ---

                if (shouldBeInteractive) {
                    pieceElement.setAttribute('tabindex', '0'); // Allow focus
                    pieceElement.draggable = true; // Allow dragging
                } else {
                    pieceElement.setAttribute('tabindex', '-1'); // Disallow focus
                    pieceElement.draggable = false; // Disallow dragging
                }
            }

            /**
             * Updates accessibility attributes for all piece elements on the board.
             * Typically called after a turn change or game state load.
             */
            function updateAllPieceAccessibility() {
                boardGridWrapper.querySelectorAll('.piece').forEach(p => updatePieceAccessibility(p));
            }


            // --- Game State Management ---

            /**
             * Creates a deep copy of the current game state and pushes it onto the history stack.
             */
            function saveGameState() {
                const stateToSave = {
                    board: JSON.parse(JSON.stringify(gameState.board)),
                    currentPlayer: gameState.currentPlayer,
                    turnNumber: gameState.turnNumber,
                    moveHistory: JSON.parse(JSON.stringify(gameState.moveHistory)),
                    boardStateHistory: JSON.parse(JSON.stringify(gameState.boardStateHistory)),
                    gameOver: gameState.gameOver,
                    winner: gameState.winner,
                    playerLastMoves: JSON.parse(JSON.stringify(playerLastMoves)),
                    // --- Add Clock Times ---
                    orangeTime: orangeTime,
                    yellowTime: yellowTime
                    // --- End Add Clock Times ---
                };
                gameHistory.push(stateToSave);
                updateUndoButtonState();
                console.log(`Game state saved. History length: ${gameHistory.length}`);
            }

            /**
             * Restores the game state to a previous state from the history.
             * @param {object} stateToLoad - The game state object retrieved from `gameHistory`.
             */
            function loadGameState(stateToLoad) {
                if (!stateToLoad) return;
                console.log("Loading game state (for Undo/Load)...");

                // --- Stop Clocks Before Loading ---
                pauseAllClocks(); // Stop any active timers

                gameState.board = stateToLoad.board;
                gameState.currentPlayer = stateToLoad.currentPlayer;
                gameState.turnNumber = stateToLoad.turnNumber;
                gameState.moveHistory = stateToLoad.moveHistory;
                gameState.boardStateHistory = stateToLoad.boardStateHistory;
                gameState.gameOver = stateToLoad.gameOver;
                gameState.winner = stateToLoad.winner;
                playerLastMoves = stateToLoad.playerLastMoves;
                // --- Restore Clock Times ---
                orangeTime = stateToLoad.orangeTime ?? INITIAL_TIME_SECONDS; // Use default if missing
                yellowTime = stateToLoad.yellowTime ?? INITIAL_TIME_SECONDS; // Use default if missing
                // --- Update Clock Displays ---
                updateClockDisplay(PLAYERS.ORANGE, orangeTime);
                updateClockDisplay(PLAYERS.YELLOW, yellowTime);

                placePieces();
                rebuildMoveLog();
                highlightLastMoves();
                updateUI();
                logBoardState(true); // Log state without incrementing count
                updateStatus(gameState.gameOver ? `Game Over: ${gameState.winner} wins!` : `${gameState.currentPlayer.toUpperCase()}'s turn.`);

                if (!gameState.gameOver) {
                    // Interaction is handled AFTER load by the calling function (undoMove, initializeGame)
                    // enablePlayerInteraction(); // DON'T enable here, let caller decide
                } else {
                    disablePlayerInteraction(); // Disable if game was over
                    pauseAllClocks(); // Ensure clocks stay stopped if game over
                }

                updateUndoButtonState();
                clearHighlights(); // General selection highlights
                selectedPieceCoords = null;
                console.log("Game state loaded.");
                // Clocks are NOT started here; the function calling loadGameState (e.g., undoMove) will resume them.
            }

            /**
             * Clears and rebuilds the visual move log based on the `gameState.moveHistory`.
             * Necessary after loading a previous game state.
             */
            function rebuildMoveLog() {
                moveLogElement.innerHTML = ''; // Clear the current log display
                // Add each entry from the history back to the DOM
                gameState.moveHistory.forEach(entry => {
                    addLogEntryToDOM(entry.turn, entry.orange, entry.yellow);
                });
                // Scroll to the bottom of the log
                moveLogElement.scrollTop = moveLogElement.scrollHeight;
            }

            /**
             * Handles the Undo button click. Reverts the game state to before the last move was made.
             * This undoes only the single most recent move, regardless of game mode. Also restores clocks. // <-- Updated comment
             */
            function undoMove() {
                // --- Prevent undo while AI is thinking (Clock Independent Check) ---
                if (!isPlayerVsPlayerMode && gameState.currentPlayer === PLAYERS.YELLOW && boardGridWrapper.style.pointerEvents === 'none') {
                    console.log("Cannot undo while AI is thinking.");
                    updateStatus("Cannot undo while AI is thinking.");
                    return;
                }

                // Check if there's anything in the history to undo
                if (gameHistory.length === 0) {
                    console.log("Nothing to undo.");
                    updateStatus("Nothing to undo.");
                    return;
                }

                // --- Pause Clocks Before Undoing ---
                pauseAllClocks();

                // Pop the state representing the board *before* the last move was made.
                // This is the exact state we want to restore to undo the last single move.
                const stateToRestore = gameHistory.pop();

                if (!stateToRestore) {
                    // Safety check: Should not happen if length check passed.
                    console.error("Undo Error: Popped state is null/undefined. History might be corrupted.");
                    initializeGame(); // Reset as a safe fallback
                    updateStatus("Undo error. Game reset.");
                    updateUndoButtonState(); // Update button after reset
                    return;
                }

                console.log("Undoing last move...");
                // Load the state that was just popped from the history.
                // This function now handles restoring clock times and updating displays, but NOT starting timers.
                loadGameState(stateToRestore);

                // Update status message based on the *restored* state's current player
                updateStatus(`Undo successful. ${gameState.currentPlayer.toUpperCase()}'s turn.`);

                // Update the Undo button's state based on the new history length
                updateUndoButtonState();

                // --- Resume Correct Clock ---
                if (!gameState.gameOver) {
                    // Check if AI turn needs to be re-triggered immediately
                    if (!isPlayerVsPlayerMode && gameState.currentPlayer === PLAYERS.YELLOW) {
                        console.log("AI turn after Undo in PvE mode. Scheduling AI move.");
                        disablePlayerInteraction();
                        undoButton.disabled = true; // Explicitly disable undo while AI thinks
                        if (aiMoveTimeoutId) { clearTimeout(aiMoveTimeoutId); aiMoveTimeoutId = null; }
                        // Start the AI's clock *before* the delay
                        startClock(PLAYERS.YELLOW);
                        aiMoveTimeoutId = setTimeout(triggerAIMove, 150); // Short delay (e.g., 150ms)
                    } else {
                        // Human turn (Orange PvE or either PvP), enable interaction and start their clock
                        enablePlayerInteraction();
                        startClock(gameState.currentPlayer); // Start clock for the player whose turn it now is
                    }
                } else {
                    // If undo results in a game-over state, ensure clocks remain paused.
                    pauseAllClocks();
                    // Interaction should already be disabled by loadGameState if game was over
                }
                // Ensure accessibility is correct after potential enable/disable calls
                updateAllPieceAccessibility();

            } // End undoMove (Modified)

            /**
             * Enables or disables the Undo button based on the game history length, game over state, and AI thinking state.
             */
            function updateUndoButtonState() {
                // Disable if history is empty OR game is over OR if it's AI's turn and interaction is disabled
                undoButton.disabled = gameHistory.length === 0 || gameState.gameOver ||
                                      (gameState.currentPlayer === PLAYERS.YELLOW && boardGridWrapper.style.pointerEvents === 'none');
            }


            // --- Game Initialization ---

            /**
             * Sets up the initial game state, creates the board, places pieces, and updates the UI.
             * Accepts an optional custom board state object to load from.
             * @param {object|null} [customBoard=null] - A board object ({ coords: pieceData }) to load instead of INITIAL_SETUP.
             * @param {boolean} [isLoadingFromFile=false] - Flag to indicate if loading from a state string input.
             */
            function initializeGame(customBoard = null, isLoadingFromFile = false) {
                 console.log("Initializing game..." + (customBoard ? " with custom state." : ""));

                // --- Initialize Clocks ---
                initializeClocks(); // Reset times and display, stop timers

                gameState = {
                    board: customBoard ? customBoard : JSON.parse(JSON.stringify(INITIAL_SETUP)),
                    currentPlayer: PLAYERS.ORANGE,
                    turnNumber: 1,
                    moveHistory: [],
                    boardStateHistory: {},
                    gameOver: false,
                    winner: null
                };
                // Reset PvP toggle state only if NOT loading from file
                 if (!isLoadingFromFile) {
                    isPlayerVsPlayerMode = false;
                    const pvpToggle = document.getElementById('pvp-toggle');
                    if (pvpToggle) pvpToggle.checked = false;
                 } // Keep existing PvP state if loading from file

                if (aiMoveTimeoutId) { clearTimeout(aiMoveTimeoutId); aiMoveTimeoutId = null; }
                gameHistory = [];

                playerLastMoves = {
                    [PLAYERS.ORANGE]: { from: null, to: null },
                    [PLAYERS.YELLOW]: { from: null, to: null }
                };

                // --- Apply abilities/hungry status ---
                 if (!customBoard) {
                     // Add abilities/initial state only if not loading custom board
                      Object.values(gameState.board).forEach(piece => {
                          if(piece) {
                             piece.isHungry = false;
                              const abilities = SPECIAL_ABILITIES[piece.rank];
                              if (abilities) { Object.assign(piece, abilities); }
                          }
                     });
                 } else {
                      // When loading custom board, ensure hungry state is reset and abilities are present
                      Object.values(gameState.board).forEach(piece => {
                          if (piece) {
                              piece.isHungry = false; // Reset hungry status
                              const abilities = SPECIAL_ABILITIES[piece.rank];
                              if (abilities) {
                                  // Ensure essential ability flags are set if missing in loaded state
                                  piece.swims = piece.swims ?? abilities.swims ?? false;
                                  piece.attacksElephant = piece.attacksElephant ?? abilities.attacksElephant ?? false;
                                  piece.jumpH = piece.jumpH ?? abilities.jumpH ?? false;
                                  piece.jumpV = piece.jumpV ?? abilities.jumpV ?? false;
                              } else {
                                   // Ensure flags are false if no special abilities
                                  piece.swims = false; piece.attacksElephant = false;
                                  piece.jumpH = false; piece.jumpV = false;
                              }
                          }
                      });
                 }

                createBoard();
                placePieces();

                moveLogElement.innerHTML = '';
                boardStateLogElement.textContent = '';
                updateStatus("Game Ready. Orange to move.");
                updateUI();
                clearHighlights();
                logBoardState(); // Log initial state
                enablePlayerInteraction(); // Enable interaction for Orange
                updateUndoButtonState();
                selectedPieceCoords = null;

                clearPlayerLastMoveHighlight(PLAYERS.ORANGE);
                clearPlayerLastMoveHighlight(PLAYERS.YELLOW);
                highlightLastMoves();

                 // --- Start Orange's Clock ---
                 if (!gameState.gameOver) {
                    startClock(PLAYERS.ORANGE); // Start the clock for the first player
                 }

                console.log("Game Initialized. Orange starts.");
            }


            // --- Input Handling (Drag & Drop, Touch, Click, Keyboard) ---

            /**
             * Handles the start of a drag operation on a piece.
             * Sets up data transfer, highlights valid moves, and applies dragging styles.
             * @param {DragEvent} e - The drag event object.
             */
            function handleDragStart(e) {
                const pieceDiv = e.target.closest('.piece');
                // Only allow dragging current player's pieces when game is active
                if (!pieceDiv || pieceDiv.dataset.player !== gameState.currentPlayer || gameState.gameOver) {
                    e.preventDefault(); // Prevent drag if not allowed
                    return;
                }
                isDragging = true;
                draggedPieceElement = pieceDiv; // Store reference to the dragged element
                sourceCoords = draggedPieceElement.dataset.coords; // Store starting position

                // Apply dragging style slightly after drag starts to avoid flicker
                setTimeout(() => {
                    if (draggedPieceElement) draggedPieceElement.classList.add('dragging');
                 }, 0);

                e.dataTransfer.effectAllowed = 'move'; // Indicate a move operation
                e.dataTransfer.setData('text/plain', sourceCoords); // Store source coords for drop handler

                highlightValidMoves(sourceCoords); // Show potential destinations
                draggedPieceElement.classList.add('selected'); // Visually mark the dragged piece
                selectedPieceCoords = sourceCoords; // Track selection
                console.log(`Drag Start: ${sourceCoords}`);
            }

            /**
             * Handles the end of a drag operation (whether successful drop or cancelled).
             * Cleans up dragging styles and resets related state variables.
             * @param {DragEvent} e - The drag event object.
             */
            function handleDragEnd(e) {
                isDragging = false;
                if (draggedPieceElement) {
                    // Remove visual styles associated with dragging/selection
                    draggedPieceElement.classList.remove('dragging', 'selected');
                }
                // Reset drag-related variables
                draggedPieceElement = null;
                sourceCoords = null;
                clearHighlights(); // Remove valid move highlights
                // Note: selectedPieceCoords is reset in handleDrop or if move fails
                console.log("Drag End");
            }

            /**
             * Handles the drag over event on potential drop targets (cells, pieces).
             * Prevents the default behavior to allow dropping.
             * @param {DragEvent} e - The drag event object.
             */
            function handleDragOver(e) {
                e.preventDefault(); // Necessary to allow dropping
                e.dataTransfer.dropEffect = 'move'; // Indicate that a move is possible
            }

            /**
             * Helper function to apply hover styling during drag based on the target element.
             * Adds 'valid-move' or 'valid-attack' class to the underlying cell if it's a valid target.
             * @param {HTMLElement} targetElement - The element being dragged over (cell or piece).
             */
            function handleDragEnterAny(targetElement) {
                if (!targetElement || !isDragging) return; // Only act if dragging
                const targetCoords = getCoordsFromElement(targetElement);
                const cellElement = targetCoords ? document.getElementById(getCellElementId(targetCoords)) : null;

                // Check if the underlying cell was highlighted as a potential move/attack
                if (cellElement && cellElement.classList.contains('valid-move-highlight')) {
                    // Apply the appropriate hover style based on whether it's an attack or move square
                    if (cellElement.classList.contains('valid-attack-highlight')) {
                        cellElement.classList.add('valid-attack'); // Red highlight
                    } else {
                        cellElement.classList.add('valid-move'); // Green highlight
                    }
                }
            }

            /**
             * Helper function to remove hover styling when the dragged piece leaves an element.
             * @param {HTMLElement} targetElement - The element being left.
             */
            function handleDragLeaveAny(targetElement) {
                if (!targetElement) return;
                const targetCoords = getCoordsFromElement(targetElement);
                const cellElement = targetCoords ? document.getElementById(getCellElementId(targetCoords)) : null;
                // Remove the temporary hover styles
                if (cellElement) {
                    cellElement.classList.remove('valid-move', 'valid-attack');
                }
            }

            /**
             * Handles drag enter event specifically for cell elements.
             * @param {DragEvent} e - The drag event object.
             */
            function handleDragEnter(e) {
                e.preventDefault();
                const targetCell = e.target.closest('.cell');
                handleDragEnterAny(targetCell); // Use helper for styling
            }

            /**
             * Handles drag leave event specifically for cell elements.
             * @param {DragEvent} e - The drag event object.
             */
            function handleDragLeave(e) {
                const targetCell = e.target.closest('.cell');
                handleDragLeaveAny(targetCell); // Use helper for styling
            }

            /**
             * Handles drag enter event specifically for piece elements (potential capture targets).
             * @param {DragEvent} e - The drag event object.
             */
            function handleDragEnterPiece(e) {
                e.preventDefault();
                e.stopPropagation(); // Prevent event bubbling to the underlying cell
                const targetPiece = e.target.closest('.piece');
                handleDragEnterAny(targetPiece); // Use helper for styling
            }

            /**
             * Handles drag leave event specifically for piece elements.
             * @param {DragEvent} e - The drag event object.
             */
            function handleDragLeavePiece(e) {
                const targetPiece = e.target.closest('.piece');
                handleDragLeaveAny(targetPiece); // Use helper for styling
            }

            /**
             * Utility function to extract coordinates from a DOM element (cell or piece).
             * @param {HTMLElement} element - The DOM element.
             * @returns {string|null} The algebraic coordinates or null if not found.
             */
            function getCoordsFromElement(element) {
                if (!element) return null;
                // Check if the element itself is a piece or cell
                if (element.classList.contains('piece') || element.classList.contains('cell')) {
                    return element.dataset.coords;
                }
                // Check if the element is inside a piece or cell
                const piece = element.closest('.piece');
                if (piece) return piece.dataset.coords;
                const cell = element.closest('.cell');
                if (cell) return cell.dataset.coords;
                return null; // Coordinates not found
            }

            /**
             * Handles the drop event when a piece is released over a target.
             * Validates the move and calls performMove if valid.
             * @param {DragEvent} e - The drop event object.
             */
            function handleDrop(e) {
                e.preventDefault();
                if (!draggedPieceElement) { // Should not happen if dragstart fired correctly
                    clearHighlights();
                    isDragging = false;
                    return;
                }

                const targetElement = e.target; // The element directly under the cursor on drop
                let targetCoords = null;
                let targetCell = null;

                // Determine the target coordinates based on what was dropped onto
                const droppedOnPiece = targetElement.closest('.piece');
                // Case 1: Dropped onto another piece (potential capture)
                if (droppedOnPiece && droppedOnPiece !== draggedPieceElement && droppedOnPiece.dataset.player !== gameState.currentPlayer) {
                    targetCoords = droppedOnPiece.dataset.coords;
                    targetCell = document.getElementById(getCellElementId(targetCoords));
                }
                // Case 2: Dropped onto a cell
                else {
                    targetCell = targetElement.closest('.cell');
                    if (targetCell) {
                        targetCoords = targetCell.dataset.coords;
                    }
                    // Case 3: Dropped back onto the original piece (treat as drop on original cell)
                    else if (targetElement === draggedPieceElement) {
                        targetCoords = draggedPieceElement.dataset.coords;
                        targetCell = document.getElementById(getCellElementId(targetCoords));
                    }
                }

                // Retrieve the source coordinates (stored during dragstart)
                const dragSourceCoords = draggedPieceElement.dataset.coords || sourceCoords || e.dataTransfer.getData('text/plain');
                clearHighlights(); // Clean up highlights immediately after drop

                // Check if drop target is valid
                if (!targetCell || !targetCoords) {
                    console.log("Drop outside valid target.");
                    updateStatus("Invalid drop location.");
                    selectedPieceCoords = null; // Deselect if drop is invalid
                    isDragging = false;
                    // Snap piece back to original position if drop is invalid
                    if(draggedPieceElement && dragSourceCoords) positionElementOnBoard(draggedPieceElement, dragSourceCoords);
                    return;
                }

                // Validate the move using game logic
                const validationResult = isValidMove(dragSourceCoords, targetCoords, getPieceData(dragSourceCoords));

                if (!validationResult.valid) {
                    // If move is invalid, log reason, update status, and snap piece back
                    console.log(`Drop on invalid target: ${targetCoords}. Reason: ${validationResult.reason}`);
                    updateStatus(`Invalid move: ${validationResult.reason}`);
                    selectedPieceCoords = null; // Deselect
                    if(draggedPieceElement && dragSourceCoords) positionElementOnBoard(draggedPieceElement, dragSourceCoords);
                } else {
                    // If move is valid, perform the move
                    console.log(`Performing move via drop from ${dragSourceCoords} to ${targetCoords}`);
                    performMove(dragSourceCoords, targetCoords);
                    selectedPieceCoords = null; // Deselect after successful move
                }
                isDragging = false; // Reset dragging flag
            }


            // --- Touch Handlers ---
            let touchStartX, touchStartY; // Store initial touch coordinates

            /**
             * Handles the start of a touch interaction on a piece.
             * Initiates potential drag, stores start position, highlights moves.
             * @param {TouchEvent} e - The touch event object.
             */
            function handleTouchStart(e) {
                if (gameState.gameOver) return; // Ignore touches if game is over
                const pieceElement = e.target.closest('.piece');
                // Only handle touches on the current player's pieces
                if (!pieceElement || pieceElement.dataset.player !== gameState.currentPlayer) return;

                e.preventDefault(); // Prevent default touch behavior like scrolling
                draggedPieceElement = pieceElement; // Reference the touched piece
                sourceCoords = draggedPieceElement.dataset.coords; // Store start position
                selectedPieceCoords = sourceCoords; // Select the piece

                // Store initial touch coordinates for calculating movement delta
                const touch = e.changedTouches[0];
                touchStartX = touch.clientX;
                touchStartY = touch.clientY;

                isDragging = false; // Not dragging yet, could be a tap
                // Temporarily disable smooth transition for direct manipulation
                draggedPieceElement.style.transition = 'none';
                draggedPieceElement.style.zIndex = '100'; // Bring to front

                highlightValidMoves(sourceCoords); // Show valid moves
                draggedPieceElement.classList.add('selected'); // Mark as selected
                console.log(`Touch Start: ${sourceCoords}`);
            }

            /**
             * Handles touch movement while holding a piece.
             * Updates the piece's position visually and detects if it's a drag vs. tap.
             * @param {TouchEvent} e - The touch event object.
             */
            function handleTouchMove(e) {
                if (!draggedPieceElement || !sourceCoords) return; // Only if a piece touch is active
                e.preventDefault(); // Prevent scrolling during piece drag

                const touch = e.changedTouches[0];
                const deltaX = touch.clientX - touchStartX; // Horizontal movement
                const deltaY = touch.clientY - touchStartY; // Vertical movement

                // Define a threshold to distinguish between a tap and a drag
                const touchDragThreshold = 10; // Pixels

                // If not already dragging, check if threshold is exceeded
                if (!isDragging && (Math.abs(deltaX) > touchDragThreshold || Math.abs(deltaY) > touchDragThreshold)) {
                    isDragging = true; // It's now officially a drag
                    draggedPieceElement.classList.add('dragging'); // Apply dragging style
                    console.log("Touch drag initiated");
                }

                // If dragging, update the element's visual position using transform
                if (isDragging) {
                    // Get the element currently under the touch point
                    const elementUnderTouch = document.elementFromPoint(touch.clientX, touch.clientY);

                    // Preserve scaling if already applied (e.g., dragging style)
                    const currentTransform = draggedPieceElement.style.transform.match(/scale\(([^)]+)\)/);
                    const currentScale = currentTransform ? parseFloat(currentTransform[1]) : 1;
                    // Apply translation based on touch movement and maintain scale
                    draggedPieceElement.style.transform = `translate(${deltaX}px, ${deltaY}px) scale(${currentScale})`;

                    // Update cell highlighting based on where the finger is hovering
                    // First, remove hover highlights from all cells
                    document.querySelectorAll('.cell.valid-move, .cell.valid-attack').forEach(c => c.classList.remove('valid-move', 'valid-attack'));
                    // Then, find the cell under the touch
                    const targetCoords = getCoordsFromElement(elementUnderTouch);
                    const cellUnderTouch = targetCoords ? document.getElementById(getCellElementId(targetCoords)) : null;
                    // If over a valid move cell, apply the appropriate hover highlight
                    if (cellUnderTouch && cellUnderTouch.classList.contains('valid-move-highlight')) {
                        if (cellUnderTouch.classList.contains('valid-attack-highlight')) {
                            cellUnderTouch.classList.add('valid-attack'); // Red highlight
                        } else {
                            cellUnderTouch.classList.add('valid-move'); // Green highlight
                        }
                    }
                }
            }

            /**
             * Handles the end of a touch interaction (lifting the finger).
             * Determines if it was a tap (treated like click) or a drag (treated like drop).
             * @param {TouchEvent} e - The touch event object.
             */
            function handleTouchEnd(e) {
                if (!draggedPieceElement || !sourceCoords) return; // Only if a piece touch was active
                e.preventDefault();

                const wasDragging = isDragging; // Store whether a drag occurred
                isDragging = false; // Reset dragging flag
                draggedPieceElement.classList.remove('dragging'); // Remove dragging style
                draggedPieceElement.style.zIndex = '10'; // Restore default z-index
                draggedPieceElement.style.transform = ''; // Reset translation

                // Restore smooth CSS transition after a short delay
                setTimeout(() => {
                    if (draggedPieceElement) {
                        draggedPieceElement.style.transition = 'transform 0.3s ease-in-out, box-shadow 0.2s ease, outline 0.2s ease, left 0.3s ease-in-out, top 0.3s ease-in-out';
                    }
                 }, 0);

                 // If it wasn't a drag, treat it as a tap/click (handled by handlePieceClick)
                 if (!wasDragging) {
                     console.log("TouchEnd: Detected as tap/click. Handled by click listener.");
                     // Let the click handler manage selection/deselection
                     // Resetting here might interfere with the click handler logic
                     // We still need to nullify draggedPieceElement and sourceCoords eventually
                     // to prevent issues if another touch starts immediately.
                     // Consider if handlePieceClick should nullify these.
                      draggedPieceElement = null;
                      sourceCoords = null;
                     return;
                 }

                // If it was a drag, determine the drop target
                const touch = e.changedTouches[0];
                // Find element at the touch release point
                const elementUnderTouch = document.elementFromPoint(touch.clientX, touch.clientY);
                let targetCoords = null;
                let targetCell = null;

                // Determine target similar to handleDrop
                const droppedOnPiece = elementUnderTouch?.closest('.piece');
                if (droppedOnPiece && droppedOnPiece !== draggedPieceElement && droppedOnPiece.dataset.player !== gameState.currentPlayer) {
                    targetCoords = droppedOnPiece.dataset.coords;
                    targetCell = document.getElementById(getCellElementId(targetCoords));
                } else {
                    targetCell = elementUnderTouch?.closest('.cell');
                    if (targetCell) {
                        targetCoords = targetCell.dataset.coords;
                    }
                }

                clearHighlights(); // Remove move highlights

                // If a valid target cell was found
                if (targetCell && targetCoords) {
                    const validationResult = isValidMove(sourceCoords, targetCoords, getPieceData(sourceCoords));
                    if (validationResult.valid) {
                        // Perform move if valid
                        console.log(`Performing move via touch from ${sourceCoords} to ${targetCoords}`);
                        performMove(sourceCoords, targetCoords);
                        selectedPieceCoords = null; // Deselect after move
                    } else {
                        // If invalid, snap piece back
                        console.log("Touch end on invalid target:", validationResult.reason);
                        updateStatus(`Invalid move: ${validationResult.reason}`);
                        positionElementOnBoard(draggedPieceElement, sourceCoords);
                        selectedPieceCoords = null; // Deselect
                    }
                } else {
                    // If dropped outside a valid target, snap piece back
                    console.log("Touch end outside valid target");
                    positionElementOnBoard(draggedPieceElement, sourceCoords);
                    selectedPieceCoords = null; // Deselect
                }

                // Clean up touch state variables
                draggedPieceElement = null;
                sourceCoords = null;
                console.log("Touch End (Drag)");
            }


            // --- Click Handlers ---

            /**
             * Handles clicking on a piece.
             * - Selects/deselects the player's own piece and highlights valid moves.
             * - If a player's piece is already selected, clicking an opponent's piece
             *   directly triggers a move validation and execution attempt (capture).
             * @param {MouseEvent} e - The click event object.
             */
            function handlePieceClick(e) {
                // Clicks on child elements (like the image) should still be handled here now.
                // We want the click on the opponent's piece representation to trigger the capture.
                // console.log("handlePieceClick triggered. Target:", e.target, "CurrentTarget:", e.currentTarget);

                // Ignore clicks during drag or if game is over
                if (isDragging) {
                    console.log("Piece click ignored: Dragging.");
                    return;
                }
                if (gameState.gameOver) {
                    console.log("Piece click ignored: Game Over.");
                    return;
                }

                // Use currentTarget to get the piece DIV the listener is attached to
                const pieceElement = e.currentTarget;
                if (!pieceElement || !pieceElement.classList.contains('piece')) {
                     console.warn("handlePieceClick: currentTarget is not a valid piece element.", pieceElement);
                     return; // Should not happen if listener attached correctly
                }

                const clickedCoords = pieceElement.dataset.coords; // Coords of the piece that was clicked
                const clickedPieceData = getPieceData(clickedCoords); // Data of the piece clicked

                // --- Scenario 1: A friendly piece is already selected ---
                if (selectedPieceCoords && selectedPieceCoords !== clickedCoords) {
                    const selectedPieceData = getPieceData(selectedPieceCoords); // Data of the *selected* piece

                    // Ensure selected piece data exists (sanity check)
                    if (!selectedPieceData) {
                        console.warn(`handlePieceClick: Data for selected piece ${selectedPieceCoords} not found. Deselecting.`);
                        deselectPiece();
                        return;
                    }

                    // Check if the clicked piece is an opponent piece (Capture Attempt)
                    if (clickedPieceData && clickedPieceData.player !== selectedPieceData.player) {
                        console.log(`handlePieceClick: Attempting CAPTURE. Selected: ${selectedPieceCoords}, Clicked Opponent: ${clickedCoords}`);

                        // *** Directly validate and perform the move ***
                        const validationResult = isValidMove(selectedPieceCoords, clickedCoords, selectedPieceData);
                        console.log(`handlePieceClick (Capture): Validation Result =`, JSON.parse(JSON.stringify(validationResult)));

                        if (validationResult.valid) {
                            console.log(`--> handlePieceClick (Capture): Validation SUCCESS. Calling performMove(${selectedPieceCoords}, ${clickedCoords})`);
                            performMove(selectedPieceCoords, clickedCoords);
                            // performMove handles deselecting the piece after a successful move
                        } else {
                            console.log(`--> handlePieceClick (Capture): Validation FAILED: ${validationResult.reason}`);
                            flashCell(clickedCoords, 'red', 300); // Flash the target piece's cell
                            updateStatus(`Invalid move: ${validationResult.reason}`);
                            // Keep the original piece selected to allow trying a different move.
                        }
                        return; // Action completed (capture attempt)
                    }
                    // If clicking another friendly piece while one is selected, switch selection
                    else if (clickedPieceData && clickedPieceData.player === selectedPieceData.player) {
                        console.log(`handlePieceClick: Switching selection from ${selectedPieceCoords} to ${clickedCoords}`);
                        selectPiece(clickedCoords); // selectPiece handles deselecting the old one
                        return; // Action completed (switched selection)
                    }
                    // If clicking an empty square (handled by handleCellClick) or something unexpected
                    else {
                         console.log(`handlePieceClick: Clicked on something unexpected (${clickedCoords}) while ${selectedPieceCoords} was selected. Letting cell handler manage.`);
                         // Do nothing here, let potential bubble to cell handler occur.
                         // (Though clicking the piece div directly shouldn't bubble to cell in the same way)
                         return;
                    }
                }

                // --- Scenario 2: No friendly piece is selected, or clicking the selected piece again ---
                // Check if the clicked piece belongs to the current player
                if (clickedPieceData && clickedPieceData.player === gameState.currentPlayer) {
                    // If clicking the already selected piece, deselect it
                    if (selectedPieceCoords === clickedCoords) {
                        console.log(`handlePieceClick: Deselecting piece ${clickedCoords}`);
                        deselectPiece();
                    }
                    // Otherwise, select the clicked piece
                    else {
                        console.log(`handlePieceClick: Selecting piece ${clickedCoords}`);
                        selectPiece(clickedCoords); // Selects and highlights moves
                    }
                } else if (!selectedPieceCoords) {
                    // If clicking an opponent piece when NOTHING is selected, do nothing.
                    console.log(`handlePieceClick: Clicked opponent piece ${clickedCoords} with no friendly piece selected. Doing nothing.`);
                    // Clear any stray highlights just in case
                    clearHighlights();
                }

                console.log(`handlePieceClick: Action completed. Selected: ${selectedPieceCoords}`);
            }

            /**
             * Handles clicking on a cell. If a piece is selected, attempts to move it to the clicked cell.
             * Ignored if a drag operation is currently happening or no piece is selected.
             * @param {MouseEvent} e - The click event object.
             */
            function handleCellClick(e) {
                // MOVED LOG TO VERY TOP
                console.log("--- handleCellClick triggered --- Target:", e.target, "CurrentTarget:", e.currentTarget); // Added more detail

                // Use e.currentTarget to ensure we reference the cell the listener is attached to
                const targetCell = e.currentTarget;

                // Basic validation of the target cell itself
                if (!targetCell || !targetCell.classList.contains('cell') || !targetCell.dataset.coords) {
                    console.log("handleCellClick ignored: event.currentTarget is not a valid cell element or missing coords.", targetCell);
                    return;
                }
                 const targetCoords = targetCell.dataset.coords;
                 console.log(`handleCellClick: Target Cell Coords = ${targetCoords}`);

                // Ignore clicks during drag or if game is over
                if (isDragging) {
                    console.log("handleCellClick ignored: isDragging is true.");
                    return;
                }
                if (gameState.gameOver) {
                    console.log("handleCellClick ignored: game is over.");
                    return;
                }

                // Check if a piece is selected (critical for move/capture attempts)
                if (!selectedPieceCoords) {
                    console.log("handleCellClick ignored: No piece selected (selectedPieceCoords is null/undefined).");
                    // Optional: Add feedback if desired when clicking cell without selection
                    // flashCell(targetCoords, 'blue', 200); // e.g., flash blue
                    return;
                }
                console.log(`handleCellClick: Proceeding. Selected piece = ${selectedPieceCoords}`);

                // Get data for the selected piece
                const pieceToMove = getPieceData(selectedPieceCoords);

                // Safety check for selected piece data
                if (!pieceToMove) {
                    console.warn(`handleCellClick: Selected piece data unexpectedly not found for: ${selectedPieceCoords}. Deselecting.`);
                    deselectPiece();
                    clearHighlights();
                    return;
                }
                console.log(`handleCellClick: Attempting move validation: ${selectedPieceCoords} (${RANK_TO_NAME[pieceToMove.rank]}) -> ${targetCoords}`);

                // Validate the move from the selected piece to the clicked cell
                const validationResult = isValidMove(selectedPieceCoords, targetCoords, pieceToMove);
                 console.log(`handleCellClick: Validation Result =`, JSON.parse(JSON.stringify(validationResult)));

                if (validationResult.valid) {
                    // Perform the move if valid
                    console.log(`--> handleCellClick: Validation SUCCESS. Calling performMove(${selectedPieceCoords}, ${targetCoords})`);
                    performMove(selectedPieceCoords, targetCoords);
                } else {
                    // If invalid, provide feedback
                    console.log(`--> handleCellClick: Validation FAILED: ${validationResult.reason}`);
                    flashCell(targetCoords, 'red', 300);
                    updateStatus(`Invalid move: ${validationResult.reason}`);
                    // Do not deselect - allow user to try another target cell
                }
                console.log("--- /handleCellClick finished ---"); // Log exit
            }

            /**
             * Handles mouse entering a piece element. Shows potential moves if it's the player's piece
             * and no other piece is currently selected or being dragged. (Hover effect)
             * @param {MouseEvent} e - The mouse event object.
             */
            function handlePieceMouseOver(e) {
                const pieceElement = e.target.closest('.piece');
                // Ignore if game over, another piece is selected, dragging, or not a piece
                if (!pieceElement || gameState.gameOver || selectedPieceCoords || isDragging) return;

                const coords = pieceElement.dataset.coords;
                const pieceData = getPieceData(coords);

                // Only highlight moves on hover for the current player's pieces
                if (pieceData && pieceData.player === gameState.currentPlayer) {
                    // Highlight moves but don't mark the piece as 'selected' (isSelection = false)
                    highlightValidMoves(coords, false);
                }
            }

            /**
             * Handles mouse leaving a piece element. Clears temporary hover highlights
             * if no piece is actively selected or being dragged.
             * @param {MouseEvent} e - The mouse event object.
             */
            function handlePieceMouseOut(e) {
                // If no piece is selected and not dragging, clear any highlights shown on hover
                if (!selectedPieceCoords && !isDragging) {
                    clearHighlights();
                }
            }


            // --- Keyboard Handlers ---

            /**
             * Handles keyboard navigation (arrow keys) and actions (Enter/Space, Escape)
             * for moving focus, selecting/deselecting pieces, and making moves.
             * Ignores input if the "Load State" input field is focused.
             * @param {KeyboardEvent} e - The keyboard event object.
             */
            function handleKeyDown(e) {
                // --- START: Add Input Focus Check ---
                if (isLoadStateInputFocused) {
                    // Allow default browser behavior for input fields (typing, arrows for cursor, etc.)
                    // but prevent game actions defined below.
                    console.log(`Keydown (${e.key}) ignored: Load state input focused.`);
                    return;
                }
                // --- END: Add Input Focus Check ---

                // Ignore keyboard input if game is over OR if it's AI's turn in PvE mode
                if (gameState.gameOver || (!isPlayerVsPlayerMode && gameState.currentPlayer === PLAYERS.YELLOW)) {
                     console.log(`KeyDown ignored: gameOver=${gameState.gameOver}, isPvP=${isPlayerVsPlayerMode}, currentPlayer=${gameState.currentPlayer}`);
                     return;
                }

                const { key } = e;
                let newRow, newCol, targetCoords, currentElement;

                // If no element currently has focus, set initial focus
                if (!focusedCoords) {
                    const firstPiece = boardGridWrapper.querySelector(`.piece[data-player="${gameState.currentPlayer}"][tabindex="0"]`);
                    if (firstPiece) {
                        focusedCoords = firstPiece.dataset.coords;
                        firstPiece.focus();
                    } else {
                        boardElement.focus();
                        focusedCoords = getCoords(Math.floor(ROWS/2), Math.floor(COLS/2)) || 'd5';
                        focusOn(focusedCoords);
                    }
                    if (!focusedCoords) return;
                }

                const currentRC = getRowCol(focusedCoords);
                if (!currentRC) {
                    console.warn("Keyboard nav: Invalid focusedCoords", focusedCoords);
                    const firstPiece = boardGridWrapper.querySelector(`.piece[data-player="${gameState.currentPlayer}"][tabindex="0"]`);
                    if (firstPiece) {
                        focusedCoords = firstPiece.dataset.coords;
                        firstPiece.focus();
                    }
                    return;
                }

                // Handle Arrow Key navigation
                switch (key) {
                    case 'ArrowUp': newRow = currentRC.row - 1; newCol = currentRC.col; break;
                    case 'ArrowDown': newRow = currentRC.row + 1; newCol = currentRC.col; break;
                    case 'ArrowLeft': newRow = currentRC.row; newCol = currentRC.col - 1; break;
                    case 'ArrowRight': newRow = currentRC.row; newCol = currentRC.col + 1; break;
                    // Handle Action Keys (Enter/Space)
                    case 'Enter':
                    case ' ':
                        e.preventDefault();
                        currentElement = document.getElementById(getPieceElementId(focusedCoords)) || document.getElementById(getCellElementId(focusedCoords));
                        if (currentElement?.classList.contains('piece')) {
                            const pieceData = getPieceData(focusedCoords);
                            if (pieceData?.player === gameState.currentPlayer) {
                                if (selectedPieceCoords === focusedCoords) deselectPiece();
                                else selectPiece(focusedCoords);
                            }
                        } else if (currentElement?.classList.contains('cell') && selectedPieceCoords) {
                            const pieceToMove = getPieceData(selectedPieceCoords);
                            if (pieceToMove) {
                                const validationResult = isValidMove(selectedPieceCoords, focusedCoords, pieceToMove);
                                if (validationResult.valid) {
                                    performMove(selectedPieceCoords, focusedCoords);
                                } else {
                                    flashCell(focusedCoords, 'red', 300);
                                    updateStatus(`Invalid move: ${validationResult.reason}`);
                                }
                            }
                        }
                        return;
                    // Handle Escape Key
                    case 'Escape':
                        e.preventDefault();
                        if (selectedPieceCoords) {
                            deselectPiece();
                            clearHighlights();
                        }
                        return;
                    default:
                        return; // Ignore other keys for game actions
                }

                // If an arrow key was pressed, calculate the target coordinates
                targetCoords = getCoords(newRow, newCol);
                if (targetCoords) {
                    e.preventDefault(); // Prevent default arrow key scrolling ONLY for game navigation
                    focusOn(targetCoords); // Move focus to the new cell/piece
                }
            }

            /**
             * Programmatically sets focus on a specific cell or piece element.
             * @param {string} coords - The algebraic coordinates of the target element.
             */
            function focusOn(coords) {
                if (!coords) return;
                // Find the target element (piece first, then cell)
                let targetElement = document.getElementById(getPieceElementId(coords)) || document.getElementById(getCellElementId(coords));
                if (targetElement) {
                    targetElement.focus(); // Set browser focus
                    // focusedCoords is updated by the 'focus' event listener on cells/pieces
                }
            }


            // --- Selection and Interaction State ---

            /**
             * Selects a piece at the given coordinates.
             * Updates the selectedPieceCoords state, applies visual selection style,
             * highlights valid moves, and sets focus.
             * @param {string} coords - The algebraic coordinates of the piece to select.
             */
            function selectPiece(coords) {
                deselectPiece(); // Ensure only one piece is selected at a time
                const pieceElement = document.getElementById(getPieceElementId(coords));
                // Only select if it's the current player's piece
                if (pieceElement?.dataset.player === gameState.currentPlayer) {
                    selectedPieceCoords = coords; // Update state
                    pieceElement.classList.add('selected'); // Apply visual style
                    highlightValidMoves(coords); // Show valid moves for this piece
                    focusOn(coords); // Move focus to the selected piece
                    console.log(`Selected piece at ${coords}`);
                }
            }

            /**
             * Deselects the currently selected piece.
             * Clears the selectedPieceCoords state, removes visual selection style,
             * and clears move highlights.
             */
            function deselectPiece() {
                if (selectedPieceCoords) {
                    const pieceElement = document.getElementById(getPieceElementId(selectedPieceCoords));
                    if (pieceElement) {
                        pieceElement.classList.remove('selected'); // Remove visual style
                    }
                    console.log(`Deselected piece at ${selectedPieceCoords}`);
                    selectedPieceCoords = null; // Clear state
                    clearHighlights(); // Remove move highlights
                }
            }

            /**
             * Enables user interaction with the board (dragging, clicking, keyboard).
             * Sets pointer-events, adds keydown listener, and updates piece accessibility.
             */
            function enablePlayerInteraction() {
                boardGridWrapper.style.pointerEvents = 'auto'; // Allow clicks/drags on the grid
                document.addEventListener('keydown', handleKeyDown); // Enable keyboard controls
                updateAllPieceAccessibility(); // Make current player's pieces draggable/focusable
                console.log("Player interaction enabled.");
            }

            /**
             * Disables user interaction with the board.
             * Used during AI's turn or when the game is over.
             */
            function disablePlayerInteraction() {
                boardGridWrapper.style.pointerEvents = 'none'; // Prevent clicks/drags on the grid
                document.removeEventListener('keydown', handleKeyDown); // Disable keyboard controls
                updateAllPieceAccessibility(); // Make all pieces non-interactive
                console.log("Player interaction disabled.");
            }


            // --- Move Logic & Validation ---

            /**
             * Executes a validated move, updating the game state, moving the piece element,
             * handling captures, checking for win/loss conditions, managing hungry/starve rules,
             * logging the move, checking for repetition/stalemate, switching the player,
             * potentially triggering the AI, and managing last move highlights and clocks. // <-- Updated comment
             * @param {string} fromCoords - The starting coordinates of the move.
             * @param {string} toCoords - The ending coordinates of the move.
             */
            function performMove(fromCoords, toCoords) {
                const piece = getPieceData(fromCoords); // Get data *before* state change

                // --- Pre-move validation and setup ---
                if (!piece || piece.player !== gameState.currentPlayer || gameState.gameOver) {
                    console.error("Invalid move attempt condition in performMove.");
                    updateStatus("Cannot move now.");
                    return;
                }
                const playerWhoMoved = gameState.currentPlayer; // Store player before any state changes

                // --- Clear Previous Highlight for Current Player ---
                clearPlayerLastMoveHighlight(playerWhoMoved);

                // Use a fresh copy of piece data for validation to avoid potential mutation issues
                const validationResult = isValidMove(fromCoords, toCoords, { ...piece });
                if (!validationResult.valid) {
                    console.log(`Invalid move attempt in performMove: ${validationResult.reason}`);
                    updateStatus(`Invalid move: ${validationResult.reason}`);
                    flashCell(toCoords, 'red');
                    // --- Re-apply highlight if move fails ---
                    highlightLastMoves(); // Re-apply previous highlights if move invalid
                    return;
                }

                // --- Save State & Clear UI ---
                saveGameState(); // Save state *after* clearing highlight but *before* making changes
                clearHighlights(); // General selection highlights (keep this)
                deselectPiece(); // Deselect piece visually

                // --- Execute the move ---
                const targetPiece = getPieceData(toCoords); // Check for piece at destination *before* state change
                const isAttack = !!targetPiece;
                let notation = `${RANK_TO_CODE[piece.rank]}`;
                let statusAction = "";

                // --- Handle Starvation BEFORE the move ---
                const starvedPiecesCoords = checkAndApplyStarvation(fromCoords, isAttack);

                // --- Handle Capture (if applicable) ---
                if (isAttack) {
                    console.log(`${playerWhoMoved} ${RANK_TO_NAME[piece.rank]} at ${fromCoords} captures ${targetPiece.player} ${RANK_TO_NAME[targetPiece.rank]} at ${toCoords}`);
                    notation += 'x';
                    statusAction = ` captures ${RANK_TO_NAME[targetPiece.rank]} at ${toCoords}`;
                    const capturedElement = document.getElementById(getPieceElementId(toCoords));
                    if (capturedElement) {
                        const capturedIndicator = capturedElement.querySelector('.trap-rank-indicator.visible');
                        if (capturedIndicator) capturedIndicator.classList.remove('visible');
                        capturedElement.classList.add('captured');
                        setTimeout(() => { capturedElement.remove(); }, 400);
                    }
                }

                // --- Update Game State Board ---
                const pieceDataToMove = JSON.parse(JSON.stringify(piece));
                pieceDataToMove.isHungry = piece.isHungry; // Carry over hungry status
                gameState.board[toCoords] = pieceDataToMove; // Place piece data at the new location
                delete gameState.board[fromCoords]; // Remove piece data from the old location

                // --- Update Piece DOM Element ---
                // Find the element using its ORIGINAL ID (before the move)
                const pieceElement = document.getElementById(getPieceElementId(fromCoords));
                if (pieceElement) {
                    // Update the element's ID to match its new coordinates
                    pieceElement.id = getPieceElementId(toCoords);
                    pieceElement.setAttribute('aria-label', `${playerWhoMoved} ${RANK_TO_NAME[piece.rank]} at ${toCoords}`);
                    // Visually move the piece on the board
                    positionElementOnBoard(pieceElement, toCoords); // This updates element's position & dataset.coords

                    // Update Trap Indicator Visual
                    const movedPieceData = gameState.board[toCoords];
                    if (movedPieceData) {
                        const isNowOnTrap = isOnTrapSquare(toCoords);
                        updateTrapIndicatorVisual(toCoords, isNowOnTrap, pieceElement);
                    } else {
                        console.warn(`performMove: Piece data not found at destination ${toCoords} after move, cannot update trap indicator.`);
                        updateTrapIndicatorVisual(toCoords, false, pieceElement); // Attempt to clear visually
                    }

                    // Update Attacker's Hungry Status After Capture
                     if (isAttack) {
                         const attackerPieceData = gameState.board[toCoords]; // Re-fetch data from final location
                         if (attackerPieceData) {
                             attackerPieceData.isHungry = false; // Attacker is no longer hungry
                             console.log(`Attacker ${RANK_TO_NAME[attackerPieceData.rank]}@${toCoords} state set to not hungry.`);
                             updateHungryVisual(toCoords, false, pieceElement); // Update visual using the element
                         }
                    }
                    // Accessibility update happens AFTER player switch usually, or via updateUI()

                } else {
                    // Fallback if element somehow missing - redraw all pieces
                    console.error(`!!! Piece element not found for move ${fromCoords} -> ${toCoords}! Could not update DOM element. Re-placing all pieces.`);
                    placePieces(); // Less efficient, but ensures consistency
                }

                notation += toCoords; // Complete move notation

                // --- Check Win Conditions ---
                const opponent = playerWhoMoved === PLAYERS.ORANGE ? PLAYERS.YELLOW : PLAYERS.ORANGE;
                const opponentDen = playerWhoMoved === PLAYERS.ORANGE ? DENS.yellow : DENS.orange;
                if (toCoords === opponentDen) {
                    gameState.winner = playerWhoMoved; gameState.gameOver = true;
                    updateStatus(`${playerWhoMoved.toUpperCase()} wins by reaching the den!${statusAction}`);
                    logMove(notation, playerWhoMoved); logBoardState(); updateUI(); disablePlayerInteraction();
                    // --- Stop Clocks on Game Over ---
                    pauseAllClocks();
                    updateUndoButtonState(); return;
                }
                // Check elimination win
                let opponentPieceCount = 0;
                for (const coords in gameState.board) { if (gameState.board[coords]?.player === opponent) { opponentPieceCount++; } }
                if (opponentPieceCount === 0) {
                    gameState.winner = playerWhoMoved; gameState.gameOver = true;
                    updateStatus(`${playerWhoMoved.toUpperCase()} wins by eliminating all opponent pieces!${statusAction}`);
                    logMove(notation, playerWhoMoved); logBoardState(); updateUI(); disablePlayerInteraction();
                    // --- Stop Clocks on Game Over ---
                    pauseAllClocks();
                    updateUndoButtonState(); return;
                }

                // --- Declare Hungry Animals for the *Next* Player ---
                const { hungryCount, hungryPiecesMap } = declareHungryAnimals(opponent);
                 Object.keys(gameState.board).forEach(coords => {
                     const p = gameState.board[coords];
                     if (p && p.player === opponent) { // Only update for the player whose turn is NEXT
                         const isNowHungry = !!hungryPiecesMap[coords];
                         p.isHungry = isNowHungry;
                         updateHungryVisual(coords, isNowHungry); // Update visual for opponent
                     }
                 });
                if (hungryCount > 0) { notation += '+'.repeat(hungryCount); } // Add hungry markers to notation

                // --- Finalize notation based on starvation rule ---
                let starvationOccurred = starvedPiecesCoords.length > 0;
                if (starvationOccurred) {
                    statusAction += ` (${starvedPiecesCoords.length} animal${starvedPiecesCoords.length > 1 ? 's' : ''} starved)`;
                    if (!notation.endsWith('x')) { notation += 'x'; } // Ensure 'x' if starvation occurred
                    console.log(`Applying Clesto rule: Starvation occurred, notation ensured to end with 'x': ${notation}`);
                }

                // --- Log the Move & Board State ---
                logMove(notation, playerWhoMoved);
                const boardStateString = logBoardState();

                // --- Store This Move for Highlighting ---
                playerLastMoves[playerWhoMoved] = { from: fromCoords, to: toCoords };
                highlightLastMoves(); // Apply highlights immediately *before* switching clocks/player

                // --- Switch Clocks (BEFORE switching player) ---
                switchClocks(playerWhoMoved);

                // --- Check Draw/Loss Conditions (Stalemate first, then Repetition) ---
                if (checkForStalemate(opponent)) { // Check if the NEXT player is stalemated
                    gameState.winner = playerWhoMoved; // Stalemate = loss for opponent, win for current player
                    gameState.gameOver = true;
                    updateStatus(`Stalemate! ${opponent.toUpperCase()} has no valid moves. ${playerWhoMoved.toUpperCase()} wins!`);
                    disablePlayerInteraction(); updateUI();
                    // --- Stop Clocks on Game Over ---
                    pauseAllClocks();
                    updateUndoButtonState(); return;
                }
                // Repetition Check (handled by isValidMove)

                // --- Switch Player and Update UI ---
                gameState.currentPlayer = opponent; // Switch to the opponent
                if (playerWhoMoved === PLAYERS.YELLOW) { gameState.turnNumber++; } // Increment turn after Yellow moves
                updateStatus(`${gameState.currentPlayer.toUpperCase()}'s turn.${statusAction}`); // Update status for the new current player
                updateUI(); // Includes accessibility update
                updateUndoButtonState(); // Update based on new state

                // --- Trigger AI if applicable ---
                if (!isPlayerVsPlayerMode && gameState.currentPlayer === PLAYERS.YELLOW && !gameState.gameOver) {
                    disablePlayerInteraction();
                    undoButton.disabled = true; // Disable undo during AI thinking
                    if (aiMoveTimeoutId) clearTimeout(aiMoveTimeoutId);
                    // AI clock is already running, just wait for think time
                    aiMoveTimeoutId = setTimeout(triggerAIMove, 1500);
                } else if (!gameState.gameOver) {
                    enablePlayerInteraction(); // Ensure interaction is enabled for human turn
                } else {
                    // Ensure clocks are stopped if game ended for any other reason here
                    pauseAllClocks();
                }

            } // End performMove (Modified)

            /**
             * Checks if the specified player has any valid moves available in the current board state.
             * @param {string} playerToCheck - The player ('orange' or 'yellow') to check for stalemate.
             * @returns {boolean} True if the player has no valid moves (stalemate), false otherwise.
             */
            function checkForStalemate(playerToCheck) {
                // Iterate through all pieces belonging to the player
                for (const fromCoords in gameState.board) {
                    const piece = gameState.board[fromCoords];
                    if (piece?.player === playerToCheck) {
                        // Get all potential destination squares for this piece
                        const destinations = getPotentialMoveDestinations(fromCoords, piece);
                        // Check if *any* of these potential destinations result in a valid move
                        for (const toCoords of destinations) {
                            if (isValidMove(fromCoords, toCoords, piece).valid) {
                                // Found at least one valid move, so it's not stalemate
                                console.log(`Stalemate check: Found valid move for ${playerToCheck}: ${fromCoords} to ${toCoords}`);
                                return false;
                            }
                        }
                    }
                }
                // If the loop completes without finding any valid moves, it's stalemate
                console.log(`Stalemate check: No valid moves found for ${playerToCheck}.`);
                return true;
            }

            /**
             * Determines if a move from `fromCoords` to `toCoords` is legal according to game rules.
             * Checks terrain, piece abilities, capture rules (including traps), jump paths,
             * AND the repetition rule for the leading player.
             * Returns additional reasonCode for specific failure types.
             * @param {string} fromCoords - Starting algebraic coordinates.
             * @param {string} toCoords - Ending algebraic coordinates.
             * @param {object} piece - The data object of the piece attempting the move (the ATTACKER).
             * @param {object} [currentBoardState=gameState.board] - Optional board state for simulation.
             * @returns {{valid: boolean, reason: string, reasonCode?: string}} An object indicating validity and reason.
             */
            function isValidMove(fromCoords, toCoords, piece, currentBoardState = gameState.board) {
                // --- Basic Checks --- (No changes needed here)
                if (!piece) return { valid: false, reason: "No piece selected." };
                if (fromCoords === toCoords) return { valid: false, reason: "Cannot move to the same square." };
                const fromRC = getRowCol(fromCoords);
                const toRC = getRowCol(toCoords);
                if (!fromRC || !toRC) return { valid: false, reason: "Invalid coordinates." };
                const targetPieceData = currentBoardState[toCoords] || null;
                const pieceRank = piece.rank;
                const pieceAbilities = SPECIAL_ABILITIES[pieceRank] || {};

                // --- Rule Checks --- (No changes needed here)
                if (targetPieceData?.player === piece.player) return { valid: false, reason: "Cannot capture your own piece." };
                const ownDen = piece.player === PLAYERS.ORANGE ? DENS.orange : DENS.yellow;
                if (toCoords === ownDen) return { valid: false, reason: "Cannot enter your own den." };
                if (piece.isHungry) {
                    const opponentDen = piece.player === PLAYERS.ORANGE ? DENS.yellow : DENS.orange;
                    if (toCoords === opponentDen) return { valid: false, reason: "Hungry animal cannot enter the den to win." };
                }

                // --- Movement Type Checks (Water, Jump) --- (No changes needed here)
                const isOrthogonal = (Math.abs(fromRC.row - toRC.row) === 1 && fromRC.col === toRC.col) || (Math.abs(fromRC.col - toRC.col) === 1 && fromRC.row === toRC.row);
                const isMovingToWater = WATER_SQUARES.has(toCoords);
                const isMovingFromWater = WATER_SQUARES.has(fromCoords);
                if (isMovingToWater && !pieceAbilities.swims) return { valid: false, reason: "This animal cannot enter water." };
                if (isMovingFromWater && isMovingToWater && targetPieceData && !pieceAbilities.swims) return { valid: false, reason: "Cannot attack into water (unless Rat/Dog)." };
                if (pieceRank === 1 && targetPieceData?.rank === 8 && isMovingFromWater) return { valid: false, reason: "Rat cannot attack Elephant from water."};
                if (isMovingFromWater && !isMovingToWater && targetPieceData && !pieceAbilities.swims) return { valid: false, reason: "Only Rat/Dog can attack land from water." };
                let isJumpValid = false;
                 if (!isMovingFromWater && !isMovingToWater) {
                     const isVerticalJump = toRC.col === fromRC.col && Math.abs(toRC.row - fromRC.row) === 4 && (fromRC.col === 1 || fromRC.col === 2 || fromRC.col === 4 || fromRC.col === 5);
                     const isHorizontalJump = toRC.row === fromRC.row && Math.abs(toRC.col - fromRC.col) === 3 && (fromRC.row >= 3 && fromRC.row <= 5);
                     if (isVerticalJump || isHorizontalJump) {
                         if ((isVerticalJump && !pieceAbilities.jumpV) || (isHorizontalJump && !pieceAbilities.jumpH)) return { valid: false, reason: "This animal cannot jump that way." };
                         if (!checkJumpPathClear(fromRC, toRC, piece.player, currentBoardState)) return { valid: false, reason: "Jump path blocked by opponent in water." };
                         isJumpValid = true;
                     }
                 }
                if (!isOrthogonal && !isJumpValid) return { valid: false, reason: "Invalid move distance or type (not 1 square orthogonal or valid jump)." };

                // --- Capture Rules --- (No changes needed here)
                if (targetPieceData) {
                    let attackerRank = pieceRank;
                    let defenderOriginalRank = targetPieceData.rank;
                    let defenderEffectiveRank = defenderOriginalRank;
                    let defenderIsTrapped = false;
                    if (isOnTrapSquare(toCoords)) {
                        defenderEffectiveRank = 0;
                        defenderIsTrapped = true;
                        console.log(`isValidMove Check: Defender ${targetPieceData.player} ${RANK_TO_NAME[targetPieceData.rank]}@${toCoords} is on a trap. Defender effective rank for capture = 0.`);
                    }
                    const isRatAttackElephant = pieceRank === 1 && defenderOriginalRank === 8;
                    if (isRatAttackElephant && !isMovingFromWater) return { valid: true };
                    if (attackerRank < defenderEffectiveRank) {
                        const reasonMsg = `Cannot attack higher-ranked animal (${attackerRank} vs ${defenderOriginalRank}${defenderIsTrapped ? ' [Trap->0]' : ''}).`;
                        return { valid: false, reason: reasonMsg, reasonCode: 'RANK_TOO_LOW' };
                    }
                }

                // --- START: Repetition Rule Check ---
                const restrictedPlayer = getRestrictedPlayer(currentBoardState);

                // Check only if the current piece's player is the one restricted by repetition
                if (piece.player === restrictedPlayer) {
                    // Simulate the board state *if* this move were made
                    // Use JSON parse/stringify for a deep clone of the board state object
                    const tempBoard = JSON.parse(JSON.stringify(currentBoardState));
                    const pieceDataToMove = tempBoard[fromCoords]; // Get the piece data

                    // Ensure pieceDataToMove exists before proceeding
                    if (pieceDataToMove) {
                        if (tempBoard[toCoords]) { // Handle capture simulation
                            delete tempBoard[toCoords];
                        }
                        tempBoard[toCoords] = pieceDataToMove; // Move the piece data
                        delete tempBoard[fromCoords]; // Delete from original position

                        const resultingStateString = getBoardStateString(tempBoard);
                        // Access the main gameState's history for checking counts
                        const repetitionCount = gameState.boardStateHistory[resultingStateString] || 0;

                        // Check if this move would cause the 3rd (or more) repetition
                        // Use >= 2 because if it has occurred twice already, this move makes the 3rd.
                        if (repetitionCount >= 2) {
                             console.log(`isValidMove: Repetition rule block for ${piece.player}. Move ${fromCoords}->${toCoords} creates 3rd+ instance of state: ${resultingStateString} (Count: ${repetitionCount + 1})`);
                             // Return invalid with a specific reason and code
                            return { valid: false, reason: "Move creates 3rd repetition.", reasonCode: 'REPETITION_RULE' };
                        }
                    } else {
                        // Should not happen if 'piece' is valid, but added as safeguard
                        console.warn(`isValidMove: Could not find piece data at ${fromCoords} during repetition check simulation.`);
                    }
                }
                // --- END: Repetition Rule Check ---


                // If all checks passed, including repetition rule
                return { valid: true };
            }


            /**
             * Checks if the path for a Lion/Tiger jump over water is clear of opponent swimming pieces (Rat/Dog).
             * @param {{row: number, col: number}} fromRC - Start row/col indices.
             * @param {{row: number, col: number}} toRC - End row/col indices.
             * @param {string} attackerPlayer - The player making the jump ('orange' or 'yellow').
             * @returns {boolean} True if the path is clear, false otherwise.
             */
            function checkJumpPathClear(fromRC, toRC, attackerPlayer) {
                const opponent = attackerPlayer === PLAYERS.ORANGE ? PLAYERS.YELLOW : PLAYERS.ORANGE;
                const startRow = Math.min(fromRC.row, toRC.row);
                const endRow = Math.max(fromRC.row, toRC.row);
                const startCol = Math.min(fromRC.col, toRC.col);
                const endCol = Math.max(fromRC.col, toRC.col);

                // Vertical Jump Check (column is the same)
                if (fromRC.col === toRC.col) {
                    // Check the 2 or 3 water squares between start and end row
                    for (let r = startRow + 1; r < endRow; r++) {
                        const coords = getCoords(r, fromRC.col);
                        // All squares in the path must be water (this should always be true for valid jump coords)
                        if (!WATER_SQUARES.has(coords)) {
                            console.warn(`Jump path check anomaly: ${coords} in vertical jump path is not water.`);
                            return false; // Should not happen with correct jump logic
                        }
                        // Check if an opponent's piece occupies a water square in the path
                        const blockingPiece = getPieceData(coords);
                        // Only opponent's pieces block the jump
                        if (blockingPiece?.player === opponent) {
                            console.log(`Jump blocked by opponent ${RANK_TO_NAME[blockingPiece.rank]} at ${coords}`);
                            return false; // Path is blocked
                        }
                    }
                }
                // Horizontal Jump Check (row is the same)
                else if (fromRC.row === toRC.row) {
                     // Check the 1 or 2 water squares between start and end col
                    for (let c = startCol + 1; c < endCol; c++) {
                        const coords = getCoords(fromRC.row, c);
                        // All squares must be water
                        if (!WATER_SQUARES.has(coords)) {
                             console.warn(`Jump path check anomaly: ${coords} in horizontal jump path is not water.`);
                            return false;
                        }
                        // Check for opponent's blocking piece
                        const blockingPiece = getPieceData(coords);
                        if (blockingPiece?.player === opponent) {
                            console.log(`Jump blocked by opponent ${RANK_TO_NAME[blockingPiece.rank]} at ${coords}`);
                            return false; // Path is blocked
                        }
                    }
                } else {
                    // If not purely vertical or horizontal, it's not a valid jump path
                    console.error("checkJumpPathClear called with non-orthogonal jump coordinates.");
                    return false;
                }

                // If loop completes without finding blockers, the path is clear
                return true;
            }


            // --- Hungry/Starve Logic ---

            /**
             * Identifies all pieces for the specified player that are currently "hungry"
             * (i.e., have a valid capturing move available against an opponent piece).
             * Considers original ranks for triggering hunger, even if the target is trapped.
             * Updates the `isHungry` property on the piece data in `gameState.board`.
             * @param {string} playerToDeclareFor - The player ('orange' or 'yellow') whose pieces should be checked.
             * @returns {{hungryCount: number, hungryPiecesMap: object}} An object containing the count of hungry pieces
             *          and a map `{ coords: true }` for each hungry piece.
             */
            function declareHungryAnimals(playerToDeclareFor) {
                let hungryCount = 0;
                const hungryPiecesMap = {}; // Stores coords of hungry pieces: { 'a1': true, 'c3': true }
                const opponent = playerToDeclareFor === PLAYERS.ORANGE ? PLAYERS.YELLOW : PLAYERS.ORANGE;

                // Check each piece belonging to the specified player
                for (const coords in gameState.board) {
                    const piece = gameState.board[coords];
                    if (piece?.player === playerToDeclareFor) {
                        // Get potential move destinations for this piece
                        const destinations = getPotentialMoveDestinations(coords, piece);
                        let pieceDeclaredHungry = false; // Flag to stop checking destinations once hungry

                        // Check each destination
                        for (const targetCoords of destinations) {
                             if (pieceDeclaredHungry) break; // Already found a reason for this piece to be hungry

                            const targetPiece = gameState.board[targetCoords]; // Potential victim

                            // Is there an opponent piece at the destination?
                            if (targetPiece?.player === opponent) {
                                // *** START: Modified Hunger Check Logic ***

                                // Step 1: Check if the move is valid considering terrain, jumps, and *effective* capture rank (including traps)
                                const validationResult = isValidMove(coords, targetCoords, piece);

                                if (validationResult.valid) {
                                    // If the move is fully valid (including capture with traps), the piece is definitely hungry.
                                    console.log(`DeclareHungry: ${piece.player} ${RANK_TO_NAME[piece.rank]}@${coords} is hungry (can capture ${targetPiece.player} ${RANK_TO_NAME[targetPiece.rank]}@${targetCoords} - trap included).`);
                                    hungryPiecesMap[coords] = true;
                                    hungryCount++;
                                    pieceDeclaredHungry = true; // Mark as hungry and move to next piece
                                } else if (validationResult.reasonCode === 'RANK_TOO_LOW') {
                                    // Step 2: If isValidMove failed *only* due to rank, check original ranks (ignore trap)
                                    console.log(`DeclareHungry: ${piece.player} ${RANK_TO_NAME[piece.rank]}@${coords} vs ${targetPiece.player} ${RANK_TO_NAME[targetPiece.rank]}@${targetCoords} - Failed isValidMove due to rank. Checking original ranks...`);

                                    const attackerRank = piece.rank;
                                    const defenderOriginalRank = targetPiece.rank;
                                    let canCaptureIgnoringTrap = false;

                                    // Special Case: Rat (1) vs Elephant (8) from land
                                    const isRatVsElephant = attackerRank === 1 && defenderOriginalRank === 8;
                                    const isMovingFromWater = WATER_SQUARES.has(coords); // Need origin coords here

                                    if (isRatVsElephant && !isMovingFromWater) {
                                        canCaptureIgnoringTrap = true; // Rat captures Elephant from land based on original ranks
                                    } else if (attackerRank >= defenderOriginalRank) {
                                        // General Case: Attacker >= Defender (using original ranks)
                                        // Exclude Elephant (8) attacking Rat (1) based on original ranks, as Rat wins normally
                                        if (!(attackerRank === 8 && defenderOriginalRank === 1)) {
                                            canCaptureIgnoringTrap = true;
                                        }
                                    }

                                    if (canCaptureIgnoringTrap) {
                                        console.log(`DeclareHungry: ---> YES, ${piece.player} ${RANK_TO_NAME[piece.rank]}@${coords} becomes hungry (can capture ${targetPiece.player} ${RANK_TO_NAME[targetPiece.rank]}@${targetCoords} based on ORIGINAL ranks).`);
                                        hungryPiecesMap[coords] = true;
                                        hungryCount++;
                                        pieceDeclaredHungry = true; // Mark as hungry and move to next piece
                                    } else {
                                         console.log(`DeclareHungry: ---> NO, rank check failed even with original ranks.`);
                                    }
                                }
                                // If validationResult was false for other reasons (terrain, jump blocked, etc.), do nothing.
                                // The piece cannot reach the target, so it doesn't get hungry from it.

                                // *** END: Modified Hunger Check Logic ***
                            }
                        } // End loop through destinations
                    }
                } // End loop through pieces

                if (hungryCount > 0) {
                    console.log(`${playerToDeclareFor.toUpperCase()} has ${hungryCount} hungry animal(s) final map: ${Object.keys(hungryPiecesMap).join(', ')}`);
                }
                return { hungryCount, hungryPiecesMap };
            }


            /**
             * Checks if any hungry pieces of the current player failed to make a capture
             * during the move that just occurred. Removes starved pieces from the board state and DOM.
             * Called *before* the piece is moved in `performMove`.
             * @param {string} movedPieceCoords - The starting coordinates of the piece that is *about* to be moved.
             * @param {boolean} wasAttack - Indicates if the move being performed *is* a capture.
             * @returns {string[]} An array of coordinates of the pieces that starved.
             */
            function checkAndApplyStarvation(movedPieceCoords, wasAttack) {
                const currentPlayer = gameState.currentPlayer; // Player whose turn it *was*
                const starvedPiecesCoords = []; // Store coords of pieces to remove

                // Iterate through all pieces on the board
                for (const coords in gameState.board) {
                    const piece = gameState.board[coords];
                    // Check if it's the current player's piece AND it was marked as hungry *before* this move started
                    if (piece?.player === currentPlayer && piece.isHungry) {
                        // Did *this specific piece* make the capturing move?
                        const didThisPieceAttack = (coords === movedPieceCoords) && wasAttack;

                        if (!didThisPieceAttack) {
                            // If this hungry piece did NOT make a capturing move, it starves
                            console.log(`STARVE: ${currentPlayer} ${RANK_TO_NAME[piece.rank]}@${coords} was hungry but did not attack. Starved.`);
                            starvedPiecesCoords.push(coords);
                        } else {
                            // If this hungry piece *did* make the attack, it's saved
                            console.log(`SAVED: ${currentPlayer} ${RANK_TO_NAME[piece.rank]}@${coords} attacked and is no longer hungry (for now).`);
                            // Note: Its isHungry status will be recalculated for the opponent's turn anyway.
                        }
                    }
                }

                // Remove starved pieces from the board state and DOM
                starvedPiecesCoords.forEach(coords => {
                    const starvedElement = document.getElementById(getPieceElementId(coords));
                    const pieceData = gameState.board[coords]; // Get data before deleting
                    if (pieceData) { // Ensure piece still exists (should always be true here)
                        console.log(`Removing starved piece ${RANK_TO_NAME[pieceData.rank]}@${coords}`);
                        delete gameState.board[coords]; // Remove from board state
                        // Animate and remove DOM element
                        if (starvedElement) {
                            starvedElement.classList.add('captured'); // Use capture animation for removal
                            setTimeout(() => starvedElement.remove(), 400);
                        }
                    }
                });

                return starvedPiecesCoords; // Return list of starved piece coordinates for logging/notation
            }


            /**
             * Gets all geometrically possible destination squares for a piece, considering orthogonal moves and jumps.
             * Does not validate the move legality (terrain, captures), only potential squares.
             * @param {string} fromCoords - The starting coordinates.
             * @param {object} piece - The piece data object.
             * @returns {string[]} An array of potential destination coordinate strings.
             */
            function getPotentialMoveDestinations(fromCoords, piece) {
                const destinations = new Set(); // Use a Set to avoid duplicate coordinates
                const rc = getRowCol(fromCoords);
                if (!rc || !piece) return [];

                const { row, col } = rc;
                const abilities = SPECIAL_ABILITIES[piece.rank] || {};

                // 1. Orthogonal Moves (adjacent squares)
                const orthMoves = [
                    getCoords(row + 1, col), // Down
                    getCoords(row - 1, col), // Up
                    getCoords(row, col + 1), // Right
                    getCoords(row, col - 1)  // Left
                ];
                orthMoves.forEach(c => {
                    if (c) destinations.add(c); // Add if valid coords
                });

                // 2. Jump Moves (Lion/Tiger/Leopard)
                // Vertical jumps (over cols 1, 2, 4, 5 river sections)
                if (abilities.jumpV && (col === 1 || col === 2 || col === 4 || col === 5)) {
                    // Check jump up (possible from rows 3 to 8)
                    if (row >= 3) { // Need 3 rows of water + 1 landing row above
                        const destUp = getCoords(row - 4, col); // 4 rows difference
                        if (destUp) destinations.add(destUp);
                    }
                    // Check jump down (possible from rows 0 to 5)
                    if (row <= 5) { // Need 3 rows of water + 1 landing row below
                        const destDown = getCoords(row + 4, col);
                        if (destDown) destinations.add(destDown);
                    }
                }
                // Horizontal jumps (over rows 3, 4, 5 river sections)
                if (abilities.jumpH && (row >= 3 && row <= 5)) { // Must be in a river row
                    // Check jump left (possible from cols 3 to 6)
                    if (col >= 3) { // Need 2 cols of water + 1 landing col left
                        const destLeft = getCoords(row, col - 3); // 3 cols difference
                        if (destLeft) destinations.add(destLeft);
                    }
                     // Check jump right (possible from cols 0 to 3)
                    if (col <= 3) { // Need 2 cols of water + 1 landing col right
                        const destRight = getCoords(row, col + 3);
                        if (destRight) destinations.add(destRight);
                    }
                }

                return [...destinations]; // Convert Set back to an array
            }


            // --- AI Logic (Minimax) ---

            /**
             * Initiates the AI's move calculation process.
             * Calls the Minimax function to find the best move.
             * Performs the chosen move or handles game end if no moves are possible.
             */
            function triggerAIMove() {
                console.log("AI (Yellow) is thinking...");
                // Find the best move using Minimax with alpha-beta pruning
                const bestMoveResult = findBestMoveMinimax(MINIMAX_DEPTH, gameState, PLAYERS.YELLOW);

                if (bestMoveResult?.move) {
                    // If a best move is found, perform it
                    console.log(`AI chooses move: ${bestMoveResult.move.from} to ${bestMoveResult.move.to} (Score: ${bestMoveResult.score})`);
                    performMove(bestMoveResult.move.from, bestMoveResult.move.to);
                } else {
                    // If AI has no valid moves (should be caught by stalemate check earlier, but as a fallback)
                    console.log("AI has no valid moves! Checking game end conditions.");
                    if (!gameState.gameOver) {
                        if (checkForStalemate(PLAYERS.YELLOW)) {
                            // If it's genuinely stalemate
                            gameState.winner = null;
                            gameState.gameOver = true;
                            updateStatus("Stalemate! AI (Yellow) has no valid moves. Game is a draw.");
                        } else {
                            // If not stalemate but AI failed to find a move (error or unexpected state)
                            gameState.winner = PLAYERS.ORANGE; // Opponent wins
                            gameState.gameOver = true;
                            updateStatus("AI Error or No Moves Found! Orange wins!");
                        }
                        disablePlayerInteraction();
                        updateUI();
                        updateUndoButtonState();
                    }
                }
            }

            /**
             * Finds the best move for the AI using the Minimax algorithm at the root level.
             * Considers hungry piece obligations.
             * @param {number} depth - The maximum search depth for Minimax.
             * @param {object} currentGameState - The current state of the game.
             * @param {string} playerForMax - The player the AI is playing as (always YELLOW here).
             * @returns {{move: object, score: number}|null} The best move found ({from, to}) and its score, or null if no moves.
             */
            function findBestMoveMinimax(depth, currentGameState, playerForMax) {
                let bestScore = -Infinity; // Initialize best score for maximizing player
                let bestMove = null;

                // Get all possible valid moves for the AI
                const possibleMoves = getAllValidMoves(currentGameState.board, currentGameState.currentPlayer);
                const opponentDen = playerForMax === PLAYERS.ORANGE ? DENS.yellow : DENS.orange;

                // If no moves are possible, return null
                if (possibleMoves.length === 0) {
                    console.log("AI findBestMove: No possible moves found.");
                    return null;
                }

                // --- Immediate Win Check ---
                // Check if any move leads directly to the opponent's den (instant win)
                for (const move of possibleMoves) {
                    if (move.to === opponentDen) {
                        console.log("AI Found immediate winning move to Den:", move);
                        // Assign a very high score, factoring in depth (faster win is better)
                        return { move: move, score: 10000 + depth };
                    }
                }

                // --- Handle Hungry Pieces Obligation ---
                // Identify which of the possible moves are made by hungry pieces
                const hungryMoves = possibleMoves.filter(move => currentGameState.board[move.from]?.isHungry);
                let movesToConsider = possibleMoves; // Default to considering all moves

                if (hungryMoves.length > 0) {
                    // If there are hungry pieces, check if any of their moves are attacks
                    const attackingHungryMoves = hungryMoves.filter(move => !!currentGameState.board[move.to]);
                    if (attackingHungryMoves.length > 0) {
                        // Rule: If a hungry piece *can* attack, it *must*. Only consider attacking moves by hungry pieces.
                        console.log("AI considering only ATTACKING moves by hungry pieces:", attackingHungryMoves);
                        movesToConsider = attackingHungryMoves;
                    } else {
                        // Rule: If hungry pieces exist but none can attack, they must still move. Consider only moves by hungry pieces.
                        console.log("AI considering only non-attacking moves by hungry pieces:", hungryMoves);
                        movesToConsider = hungryMoves;
                    }
                }
                // If no hungry pieces, movesToConsider remains all possibleMoves.

                // --- Evaluate Moves using Minimax ---
                // Iterate through the prioritized list of moves
                for (const move of movesToConsider) {
                    // Simulate the move to get the resulting board state
                    const nextState = simulateMove(currentGameState, move);
                    // Call minimax for the opponent's turn (minimizing player)
                    // Alpha/Beta are initialized to worst-case values
                    const score = minimax(depth - 1, nextState, false, -Infinity, Infinity, playerForMax);

                    // --- Add Randomness (Tie-breaking) ---
                    // Add a small random value to scores that aren't immediate wins/losses
                    // This prevents the AI from always making the same move in equivalent situations.
                    let currentScore = score;
                    if (Math.abs(score) < 5000) { // Don't add randomness to clear win/loss scores
                        currentScore += Math.random() * 0.1; // Small random factor
                    }

                    // Update best move if current move yields a higher score
                    if (currentScore > bestScore) {
                        bestScore = currentScore;
                        bestMove = move;
                    }
                }

                 // Fallback: If no best move was found among considered moves (e.g., all led to immediate loss)
                 // but there were other possible moves initially, pick a random valid move to avoid crashing.
                 // This should ideally not happen if evaluation/minimax is correct.
                if (!bestMove && possibleMoves.length > 0) {
                    console.warn("Minimax didn't find a best move among 'movesToConsider'. Picking random valid move as fallback.");
                    bestMove = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                    bestScore = -Infinity; // Assign a low score as it's a fallback
                }

                return { move: bestMove, score: bestScore };
            }

            /**
             * The recursive Minimax function with Alpha-Beta Pruning.
             * Explores the game tree to a specified depth, evaluating board states.
             * @param {number} depth - Remaining depth to search.
             * @param {object} nodeGameState - The game state at the current node in the search tree.
             * @param {boolean} isMaximizingPlayer - True if the current node is for the AI (maximizing), false for the opponent (minimizing).
             * @param {number} alpha - The best score found so far for the maximizing player along the current path.
             * @param {number} beta - The best score found so far for the minimizing player along the current path.
             * @param {string} playerForMax - The player the AI controls (YELLOW).
             * @returns {number} The evaluated score for the current node.
             */
            function minimax(depth, nodeGameState, isMaximizingPlayer, alpha, beta, playerForMax) {
                // --- Base Cases for Recursion ---
                // 1. Reached maximum depth or game is over in this simulated state
                if (depth === 0 || nodeGameState.gameOver) {
                    const baseScore = evaluateBoard(nodeGameState.board, playerForMax);
                    // Add/subtract remaining depth to prioritize faster wins/slower losses
                    if (baseScore > 5000) return baseScore + depth; // Faster win is better
                    if (baseScore < -5000) return baseScore - depth; // Slower loss is better
                    return baseScore; // Return static evaluation
                }

                // Get possible moves from the current node state
                const possibleMoves = getAllValidMoves(nodeGameState.board, nodeGameState.currentPlayer);

                // 2. No moves possible (Stalemate or Checkmate in simulation)
                if (possibleMoves.length === 0) {
                    // Check if it's a stalemate (draw = 0) or if the current player lost (win for opponent)
                    return checkForStalemate(nodeGameState.currentPlayer) ? 0 : // Stalemate score
                           (isMaximizingPlayer ? (-10000 - depth) : (10000 + depth)); // Lost score (opponent won)
                }

                // --- Handle Hungry Pieces Obligation (within simulation) ---
                 // Prioritize moves based on hungry rules, same logic as in findBestMoveMinimax
                const hungryMoves = possibleMoves.filter(move => nodeGameState.board[move.from]?.isHungry);
                let movesToConsider = possibleMoves;
                if (hungryMoves.length > 0) {
                    const attackingHungryMoves = hungryMoves.filter(move => !!nodeGameState.board[move.to]);
                    if (attackingHungryMoves.length > 0) {
                        movesToConsider = attackingHungryMoves;
                    } else {
                        movesToConsider = hungryMoves;
                    }
                }

                // --- Recursive Exploration ---
                if (isMaximizingPlayer) { // AI's turn (maximize score)
                    let maxEval = -Infinity;
                    for (const move of movesToConsider) {
                        const nextState = simulateMove(nodeGameState, move); // Simulate the move
                        // Recursive call for the minimizing player's turn
                        const evaluation = minimax(depth - 1, nextState, false, alpha, beta, playerForMax);
                        maxEval = Math.max(maxEval, evaluation); // Update max score found
                        alpha = Math.max(alpha, evaluation); // Update alpha (best for maximizer)
                        if (beta <= alpha) {
                            break; // Beta cutoff (minimizer already found a better option elsewhere)
                        }
                    }
                     // Fallback if all 'movesToConsider' led to immediate loss/bad score
                     // Check if there were *any* possible moves initially. If so, evaluate one as fallback.
                     // This prevents returning -Infinity if only forced bad moves were considered due to hungry rules.
                     if (maxEval === -Infinity && possibleMoves.length > 0 && movesToConsider.length < possibleMoves.length) {
                          console.log(`Minimax Max fallback: Evaluating non-hungry move at depth ${depth}`);
                          const fallbackState = simulateMove(nodeGameState, possibleMoves.find(m => !movesToConsider.includes(m)) || possibleMoves[0]);
                          return minimax(depth -1, fallbackState, false, alpha, beta, playerForMax);
                     }
                    return maxEval;
                } else { // Opponent's turn (minimize score)
                    let minEval = Infinity;
                    for (const move of movesToConsider) {
                        const nextState = simulateMove(nodeGameState, move); // Simulate the move
                        // Recursive call for the maximizing player's turn
                        const evaluation = minimax(depth - 1, nextState, true, alpha, beta, playerForMax);
                        minEval = Math.min(minEval, evaluation); // Update min score found
                        beta = Math.min(beta, evaluation); // Update beta (best for minimizer)
                        if (beta <= alpha) {
                            break; // Alpha cutoff (maximizer already found a better option elsewhere)
                        }
                    }
                     // Similar fallback for minimizer
                     if (minEval === Infinity && possibleMoves.length > 0 && movesToConsider.length < possibleMoves.length) {
                          console.log(`Minimax Min fallback: Evaluating non-hungry move at depth ${depth}`);
                         const fallbackState = simulateMove(nodeGameState, possibleMoves.find(m => !movesToConsider.includes(m)) || possibleMoves[0]);
                         return minimax(depth -1, fallbackState, true, alpha, beta, playerForMax);
                     }
                    return minEval;
                }
            }

            /**
             * Generates a list of all valid moves for a given player in a specific board state.
             * @param {object} boardState - The board state object ({ coords: pieceData }).
             * @param {string} player - The player ('orange' or 'yellow') whose moves to find.
             * @returns {Array<object>} An array of valid move objects [{ from, to }, ...].
             */
            function getAllValidMoves(boardState, player) {
                const validMoves = [];
                if (!boardState) return []; // Safety check

                // Iterate through all squares on the board
                for (const fromCoords in boardState) {
                    const piece = boardState[fromCoords];
                    // Check if the piece belongs to the specified player
                    if (piece?.player === player) {
                        // Get potential destinations (geometric moves)
                        const destinations = getPotentialMoveDestinations(fromCoords, piece);
                        // Validate each potential destination
                        for (const toCoords of destinations) {
                            // Use isValidMove with a copy of piece data to avoid state mutation issues
                            if (isValidMove(fromCoords, toCoords, { ...piece }, boardState).valid) {
                                validMoves.push({ from: fromCoords, to: toCoords });
                            }
                        }
                    }
                }
                return validMoves;
            }

            /**
             * Creates a new game state object representing the result of making a specific move.
             * Does *not* handle hungry/starve rules or complex win conditions, focuses on board changes.
             * Used for AI simulation.
             * @param {object} currentGameState - The game state *before* the move.
             * @param {object} move - The move object { from, to }.
             * @returns {object} A new game state object representing the state *after* the move.
             */
            function simulateMove(currentGameState, move) {
                // Create a deep copy of the board to avoid modifying the original state
                const nextState = {
                    board: JSON.parse(JSON.stringify(currentGameState.board)),
                    currentPlayer: currentGameState.currentPlayer, // Temporarily keep current player
                    gameOver: false, // Assume game not over unless conditions met
                    winner: null
                };

                const piece = nextState.board[move.from];

                // Error handling: If piece doesn't exist at source (shouldn't happen with valid moves)
                if (!piece) {
                    console.error("SimulateMove Error: Piece not found at source", move.from, "Current Board:", currentGameState.board);
                    // Mark game as over, opponent wins (as current player can't move)
                    nextState.gameOver = true;
                    nextState.winner = currentGameState.currentPlayer === PLAYERS.ORANGE ? PLAYERS.YELLOW : PLAYERS.ORANGE;
                    return nextState;
                }

                // Simulate capture by deleting piece at destination (if any)
                const targetPiece = nextState.board[move.to];
                if (targetPiece) {
                    // In simulation, we just remove the piece from the board state
                    delete nextState.board[move.to];
                }

                // Move the piece in the board state
                nextState.board[move.to] = piece;
                delete nextState.board[move.from];

                // --- Simplified Win Condition Checks for Simulation ---
                const opponent = piece.player === PLAYERS.ORANGE ? PLAYERS.YELLOW : PLAYERS.ORANGE;
                const opponentDen = piece.player === PLAYERS.ORANGE ? DENS.yellow : DENS.orange;

                // 1. Reached opponent's den
                if (move.to === opponentDen) {
                    nextState.gameOver = true;
                    nextState.winner = piece.player;
                } else {
                    // 2. Check if opponent has any pieces left (simplified check)
                    let opponentPieceCount = 0;
                    for (const coords in nextState.board) {
                        if (nextState.board[coords]?.player === opponent) {
                            opponentPieceCount++;
                            break; // Found one, no need to count all
                        }
                    }
                    if (opponentPieceCount === 0) {
                        nextState.gameOver = true;
                        nextState.winner = piece.player;
                    }
                }

                // Switch the current player for the next node in the simulation tree
                nextState.currentPlayer = opponent;

                 // Update hungry status for the *next* player in the simulated state
                 // This is crucial for the minimax evaluation to correctly consider forced moves.
                 const { hungryPiecesMap } = declareHungryAnimals(nextState.currentPlayer); // Use the *new* current player
                 Object.keys(nextState.board).forEach(coords => {
                     const p = nextState.board[coords];
                     if (p) {
                         p.isHungry = !!hungryPiecesMap[coords];
                     }
                 });


                return nextState;
            }

            /**
             * Evaluates the static board state from the perspective of the AI player (playerForMax).
             * Assigns scores based on piece values, positional advantage, den/trap threats, and win/loss conditions. // <-- Updated comment
             * @param {object} boardState - The board state to evaluate.
             * @param {string} playerForMax - The player considered "maximizing" (AI, usually Yellow).
             * @returns {number} A numerical score representing the board state's favorability for playerForMax.
             *          Positive scores favor playerForMax, negative scores favor the opponent.
             *          Very large positive/negative scores indicate win/loss.
             */
            function evaluateBoard(boardState, playerForMax) {
                let score = 0;
                const pieceValues = { 1: 35, 2: 10, 3: 40, 4: 30, 5: 50, 6: 70, 7: 80, 8: 75 }; // Rat:35, Cat:10, Dog:40, Wolf:30, Leopard:50, Tiger:70, Lion:80, Elephant:75
                const opponent = playerForMax === PLAYERS.ORANGE ? PLAYERS.YELLOW : PLAYERS.ORANGE;

                // Dens and Traps relative to the player being evaluated (playerForMax)
                const maxDen = playerForMax === PLAYERS.ORANGE ? DENS.orange : DENS.yellow; // playerForMax's own den
                const minDen = playerForMax === PLAYERS.ORANGE ? DENS.yellow : DENS.orange; // Opponent's den (target)
                // Traps near playerForMax's den (where opponent pieces are penalized)
                const maxTraps = playerForMax === PLAYERS.ORANGE ? TRAPS.yellow : TRAPS.orange;
                // Traps near opponent's den (where playerForMax pieces get bonus for proximity)
                const minTraps = playerForMax === PLAYERS.ORANGE ? TRAPS.orange : TRAPS.yellow; // Identify opponent's traps (near AI's den)

                const adjacentToMaxDen = getAdjacentCoords(maxDen); // Squares next to playerForMax's den
                // Calculate squares adjacent to the traps near the opponent's den (using helper)
                const adjacentToMinTraps = getAdjacentCoordsSet(minTraps);

                // --- Evaluation Constants ---
                const IMMEDIATE_THREAT_PENALTY = 750;  // Penalty for opponent near AI den/traps
                const NEAR_OPPONENT_TRAP_BONUS = 50;   // Bonus for AI near opponent's traps (tune if needed)
                const DEN_PROXIMITY_MULTIPLIER = 0.5; // Bonus multiplier for distance to opponent den

                let maxHasWon = false;
                let minHasWon = false;
                let maxPieceCount = 0;
                let minPieceCount = 0;

                for (const coords in boardState) {
                    const piece = boardState[coords];
                    if (!piece) continue;

                    let pieceScore = pieceValues[piece.rank] || 0;
                    const rc = getRowCol(coords);

                    // --- Evaluate based on player ---
                    if (piece.player === playerForMax) { // Piece belongs to the AI (maximizing player)
                        maxPieceCount++;
                        // --- Positional Bonuses for playerForMax ---
                        // 1. Proximity to opponent's den (the target)
                        const targetDenRC = getRowCol(minDen);
                        if (rc && targetDenRC) {
                            const dist = Math.abs(rc.row - targetDenRC.row) + Math.abs(rc.col - targetDenRC.col);
                            // Bonus increases as distance decreases (16 is roughly max possible distance)
                            pieceScore += (16 - dist) * DEN_PROXIMITY_MULTIPLIER;
                        }
                        // 2. Proximity to opponent's traps (near AI's own den - defensive bonus)
                        if (adjacentToMinTraps.has(coords)) {
                            console.log(`--- AI Bonus: ${RANK_TO_NAME[piece.rank]}@${coords} is adjacent to opponent trap (near own den). Applying bonus: +${NEAR_OPPONENT_TRAP_BONUS}`);
                            pieceScore += NEAR_OPPONENT_TRAP_BONUS;
                        }

                        score += pieceScore; // Add piece value and bonuses to total score

                        // Check if playerForMax reached opponent's den (win condition)
                        if (coords === minDen) maxHasWon = true;

                    } else { // Piece belongs to the opponent (minimizing player)
                        minPieceCount++;
                        // --- Penalties based on opponent's position ---
                        // 1. Opponent reached playerForMax's den (loss condition)
                        if (coords === maxDen) minHasWon = true;

                        // 2. Check for Immediate Threats to playerForMax's Den
                        const isOnMaxTrap = maxTraps.has(coords); // Opponent is on a trap near AI's den
                        const isAdjacentToMaxDen = adjacentToMaxDen.includes(coords); // Opponent is next to AI's den

                        if (isOnMaxTrap || isAdjacentToMaxDen) {
                             // Apply large penalty if opponent is on AI's trap OR adjacent to AI's den
                             console.log(`!!! Immediate threat detected: Opponent ${RANK_TO_NAME[piece.rank]} at ${coords} (Trap: ${isOnMaxTrap}, Adjacent: ${isAdjacentToMaxDen}). Applying penalty: -${IMMEDIATE_THREAT_PENALTY}`);
                             score -= IMMEDIATE_THREAT_PENALTY;
                        }

                        score -= pieceScore; // Subtract opponent's piece value from total score
                    }
                }

                // --- Check for Win/Loss by Den or Elimination ---
                if (maxHasWon || minPieceCount === 0) return 10000; // Maximizing player wins
                if (minHasWon || maxPieceCount === 0) return -10000; // Minimizing player wins

                return score;
            }


            // --- UI Update & Logging ---

            /**
             * Updates the main UI elements (turn indicator, button states) based on the current game state.
             */
            function updateUI() {
                if (gameState.gameOver) {
                    // Display Game Over message and winner
                    turnIndicator.textContent = `Game Over - ${gameState.winner ? gameState.winner.toUpperCase() : 'DRAW'} Wins!`;
                    turnIndicator.className = 'game-over'; // Apply game over style
                } else {
                    // Display current player's turn
                    turnIndicator.textContent = gameState.currentPlayer.toUpperCase();
                    turnIndicator.className = gameState.currentPlayer; // Apply player color style
                }
                updateUndoButtonState(); // Enable/disable undo button
                updateAllPieceAccessibility(); // Update piece interactivity based on current player/game state
            }

            /**
             * Updates the status message display area and logs the message to the console.
             * @param {string} message - The message to display.
             */
            function updateStatus(message) {
                statusMessage.textContent = message; // Update the DOM element
                console.log("Status:", message); // Also log to console (and potentially debug panel)
            }

            /**
             * Creates and appends a log entry element to the visual move log panel.
             * @param {number} turn - The turn number.
             * @param {string|null} orangeMove - The notation for Orange's move this turn, or null.
             * @param {string|null} yellowMove - The notation for Yellow's move this turn, or null.
             */
            function addLogEntryToDOM(turn, orangeMove, yellowMove) {
                const logEntryDiv = document.createElement('div');
                logEntryDiv.classList.add('log-entry');
                logEntryDiv.dataset.turn = turn; // Store turn number for potential updates

                // Turn Number Span
                const turnSpan = document.createElement('span');
                turnSpan.classList.add('turn-number');
                turnSpan.textContent = `${turn}.`;
                logEntryDiv.appendChild(turnSpan);

                // Orange Move Span (or placeholder)
                const orangeSpan = document.createElement('span');
                if (orangeMove) {
                    orangeSpan.classList.add('log-orange');
                    orangeSpan.textContent = orangeMove;
                } else {
                    orangeSpan.classList.add('placeholder');
                    orangeSpan.textContent = '...'; // Placeholder if Orange hasn't moved yet
                }
                logEntryDiv.appendChild(orangeSpan);

                // Yellow Move Span (only if Yellow has moved)
                if (yellowMove) {
                    const yellowSpan = document.createElement('span');
                    yellowSpan.classList.add('log-yellow');
                    yellowSpan.textContent = yellowMove;
                    logEntryDiv.appendChild(yellowSpan);
                }
                // If yellowMove is null/undefined, no span is added yet.

                moveLogElement.appendChild(logEntryDiv); // Add the entry to the log panel
                moveLogElement.scrollTop = moveLogElement.scrollHeight; // Scroll to the latest entry
            }

            /**
             * Logs a move to the `gameState.moveHistory` array and updates the visual move log panel.
             * Handles creating new turn entries or updating existing ones.
             * @param {string} notation - The algebraic notation of the move (e.g., "8xg7++s").
             * @param {string} playerWhoMoved - The player who made the move ('orange' or 'yellow').
             */
            function logMove(notation, playerWhoMoved) {
                const turnNum = gameState.turnNumber; // Get the current turn number

                // Find if an entry for this turn already exists in the history
                let currentTurnEntry = gameState.moveHistory.find(entry => entry.turn === turnNum);
                // Find if a DOM element for this turn already exists
                let existingLogDiv = moveLogElement.querySelector(`div.log-entry[data-turn="${turnNum}"]`);

                if (playerWhoMoved === PLAYERS.ORANGE) {
                    // If Orange moves, it's always the start of a new turn entry (or overwriting if undo occurred)
                    if (!currentTurnEntry) {
                        // Create new entry in history
                        currentTurnEntry = { turn: turnNum, orange: notation, yellow: null };
                        gameState.moveHistory.push(currentTurnEntry);
                        // Remove existing DOM element if any (e.g., after undo) and add the new one
                        if (existingLogDiv) existingLogDiv.remove();
                        addLogEntryToDOM(turnNum, notation, null);
                    } else {
                        // This case might occur after an undo/redo sequence. Update the existing entry.
                        console.warn("Updating Orange's move in existing turn entry:", turnNum);
                        currentTurnEntry.orange = notation;
                        // Update the DOM if it exists
                        if (existingLogDiv) {
                            let orangeSpan = existingLogDiv.querySelector('.log-orange, .placeholder');
                            if (orangeSpan) {
                                orangeSpan.textContent = notation;
                                orangeSpan.className = 'log-orange'; // Ensure correct class
                            }
                        } else {
                             // If DOM element missing unexpectedly, recreate it
                            addLogEntryToDOM(turnNum, notation, currentTurnEntry.yellow);
                        }
                    }
                } else { // Yellow moved
                    // Yellow always completes a turn entry initiated by Orange
                    if (currentTurnEntry) {
                        // Update the history entry
                        currentTurnEntry.yellow = notation;
                        // Update the DOM element
                        if (existingLogDiv) {
                            let yellowSpan = existingLogDiv.querySelector('.log-yellow');
                            // If yellow span doesn't exist yet, create it
                            if (!yellowSpan) {
                                yellowSpan = document.createElement('span');
                                existingLogDiv.appendChild(yellowSpan);
                            }
                            yellowSpan.textContent = notation;
                            yellowSpan.className = 'log-yellow'; // Ensure correct class
                        } else {
                            // Log error if DOM element is missing when it shouldn't be
                            console.error("Log div missing for Yellow's move in turn", turnNum);
                            // Attempt to recreate the full log entry
                            addLogEntryToDOM(turnNum, currentTurnEntry.orange || '...', notation);
                        }
                    } else {
                        // Log error if Yellow moves but no history entry exists (shouldn't happen)
                        console.error("Yellow moved but no history entry found for turn", turnNum);
                        // Create a new history entry anyway
                        currentTurnEntry = { turn: turnNum, orange: null, yellow: notation };
                        gameState.moveHistory.push(currentTurnEntry);
                        if (existingLogDiv) existingLogDiv.remove(); // Remove potentially incomplete DOM entry
                        addLogEntryToDOM(turnNum, null, notation); // Add correct entry
                    }
                }
                // Ensure log scrolls to bottom
                moveLogElement.scrollTop = moveLogElement.scrollHeight;
            }


            /**
             * Generates a unique string representation of the current board state.
             * Used for detecting repetitions. Format: "RankCoordsUpper/Lower,RankCoordsUpper/Lower,..." sorted alphabetically.
             * Example: "1a7,1g3,2b2,..." (Upper = Orange, Lower = Yellow)
             * @param {object} [board=gameState.board] - The board state to stringify. Defaults to current game state.
             * @returns {string} The sorted comma-separated string representation.
             */
            function getBoardStateString(board = gameState.board) {
                const pieces = [];
                // Get coordinates and sort them alphabetically/numerically for consistency
                const coordsList = Object.keys(board).sort((a, b) => {
                    // Sort primarily by column, then by row number descending
                    const colA = a.charCodeAt(0);
                    const colB = b.charCodeAt(0);
                    if (colA !== colB) return colA - colB;
                    const rowA = parseInt(a.substring(1));
                    const rowB = parseInt(b.substring(1));
                    return rowB - rowA; // Higher row number (e.g., 9) comes first
                });

                for (const coords of coordsList) {
                    const piece = board[coords];
                    if (piece) {
                        // Format: Rank followed by Coords. Uppercase coords for Orange, lowercase for Yellow.
                        const stateOutput = piece.player === PLAYERS.ORANGE ?
                            `${piece.rank}${coords.toUpperCase()}` : // e.g., 8A3
                            `${piece.rank}${coords.toLowerCase()}`; // e.g., 7a9
                        pieces.push(stateOutput);
                    }
                }
                // Final sort of the generated piece strings ensures the overall string is unique per state
                // pieces.sort(); // This secondary sort might be redundant if coordsList is sorted robustly
                return pieces.join(','); // Join with commas
            }

            /**
             * Parses a board state string into a board object suitable for gameState.board.
             * String format: "RankCoordsUpper/Lower,RankCoordsUpper/Lower,..." (e.g., "8A3,7G1,1a7")
             * Uppercase coords = Orange, Lowercase = Yellow.
             * @param {string} stateString - The board state string to parse.
             * @returns {object|null} A board object { coords: pieceData } or null if parsing fails.
             */
            function parseBoardStateString(stateString) {
                if (!stateString || typeof stateString !== 'string') {
                    console.error("Parse Error: Invalid input string.");
                    return null;
                }

                const parsedBoard = {};
                const pieceStrings = stateString.trim().split(',');
                const pieceRegex = /^([1-8])([a-gA-G][1-9])$/; // Matches Rank (1-8) and Coords (e.g., a1, G9)

                for (const pieceStr of pieceStrings) {
                    if (!pieceStr) continue; // Skip empty parts if trailing comma etc.
                    const match = pieceStr.match(pieceRegex);

                    if (!match) {
                        console.error(`Parse Error: Invalid piece format "${pieceStr}" in state string.`);
                        return null; // Invalid format for a piece
                    }

                    const rank = parseInt(match[1], 10);
                    const coordsRaw = match[2];
                    const coordsLower = coordsRaw.toLowerCase(); // Key for the board object is always lowercase

                    // Validate coordinates range after converting to lowercase
                    const rc = getRowCol(coordsLower);
                    if (!rc) {
                        console.error(`Parse Error: Invalid coordinates "${coordsRaw}" in state string.`);
                        return null;
                    }

                    // Determine player based on original case
                    const player = (coordsRaw === coordsRaw.toUpperCase()) ? PLAYERS.ORANGE : PLAYERS.YELLOW;

                    // Create piece data object
                    const pieceData = {
                        player: player,
                        rank: rank,
                        isHungry: false // Pieces always start not hungry when loading state
                    };

                    // Add special abilities based on rank
                    const abilities = SPECIAL_ABILITIES[rank];
                    if (abilities) {
                        pieceData.swims = abilities.swims || false;
                        pieceData.attacksElephant = abilities.attacksElephant || false;
                        pieceData.jumpH = abilities.jumpH || false;
                        pieceData.jumpV = abilities.jumpV || false;
                    } else {
                        pieceData.swims = false; pieceData.attacksElephant = false;
                        pieceData.jumpH = false; pieceData.jumpV = false;
                    }

                    // Check for duplicate piece placement
                    if (parsedBoard[coordsLower]) {
                         console.error(`Parse Error: Duplicate piece placement at "${coordsLower}" in state string.`);
                         return null;
                    }

                    parsedBoard[coordsLower] = pieceData;
                }

                // Basic sanity check: ensure at least one piece exists? (Optional)
                if (Object.keys(parsedBoard).length === 0 && stateString.length > 0) {
                     console.error("Parse Error: String provided but no valid pieces parsed.");
                     return null;
                }


                console.log("Successfully parsed board state:", parsedBoard);
                return parsedBoard;
            }

            /**
             * Logs the current board state string to the console and the board state log element.
             * Increments the count for this state in `gameState.boardStateHistory` unless restoring.
             * @param {boolean} [isRestoring=false] - If true, logs the state but doesn't increment the history count (used during undo).
             * @returns {string} The generated board state string.
             */
            function logBoardState(isRestoring = false) {
                const stateString = getBoardStateString();
                boardStateLogElement.textContent = stateString; // Display in UI

                if (!isRestoring) {
                    // Increment the count for this state in the history object
                    gameState.boardStateHistory[stateString] = (gameState.boardStateHistory[stateString] || 0) + 1;
                    console.log(`Board State (${gameState.boardStateHistory[stateString]}x):`, stateString);
                } else {
                    // Just log that the state was restored
                    console.log(`Restored Board State:`, stateString);
                }
                return stateString; // Return the generated string
            }

            /**
             * Shows or hides the "(0)" trap rank indicator on a piece's DOM element.
             * Can accept coordinates OR a direct element reference for robustness.
             * @param {string} coords - The coordinates of the piece.
             * @param {boolean} isTrapped - Whether the piece should show the trapped indicator.
             * @param {HTMLElement|null} [element=null] - Optional: Direct reference to the piece element.
             */
            function updateTrapIndicatorVisual(coords, isTrapped, element = null) {
                // Prioritize the passed element reference if available
                const pieceElement = element || document.getElementById(getPieceElementId(coords));
                if (!pieceElement) {
                     // Element might legitimately not exist if piece was captured/starved before update could happen.
                     // console.warn(`updateTrapIndicatorVisual: Element not found for ${coords}.`);
                    return;
                }

                // Find the indicator span within the piece element
                const indicatorSpan = pieceElement.querySelector('.trap-rank-indicator');
                if (!indicatorSpan) {
                    console.warn("Trap indicator span not found for piece at", coords);
                    return;
                }

                // Add or remove the 'visible' class based on the isTrapped flag
                if (isTrapped) {
                    if (!indicatorSpan.classList.contains('visible')) { // Check before adding
                        indicatorSpan.classList.add('visible');
                        // console.log(`Trap Indicator ON for ${coords}`);
                    }
                } else {
                    if (indicatorSpan.classList.contains('visible')) { // Check before removing
                        indicatorSpan.classList.remove('visible');
                        // console.log(`Trap Indicator OFF for ${coords}`);
                    }
                }
            }

            /**
             * Adds or removes the 'hungry' class from a piece's DOM element.
             * Can accept coordinates OR a direct element reference.
             * @param {string} coords - The coordinates of the piece (used if element is not provided).
             * @param {boolean} isHungry - Whether the piece should be marked as hungry.
             * @param {HTMLElement|null} [element=null] - Optional: Direct reference to the piece element.
             */
            function updateHungryVisual(coords, isHungry, element = null) { // Added element parameter
                // Prioritize the passed element reference if available
                const pieceElement = element || document.getElementById(getPieceElementId(coords));

                // console.log(`updateHungryVisual called for ${coords}: isHungry = ${isHungry}`, pieceElement ? '(Element found)' : '(Element NOT found!)');

                if (pieceElement) {
                    if (isHungry) {
                        pieceElement.classList.add('hungry'); // Add red glow
                        // console.log(`   Added .hungry class to ${coords}`);
                    } else {
                        // Use a try-catch just in case something weird happens with the element reference
                        try {
                             pieceElement.classList.remove('hungry'); // Remove red glow
                             // console.log(`   Attempted to remove .hungry class from ${coords}`);
                             // Verify removal (for debugging)
                             // if (pieceElement.classList.contains('hungry')) {
                             //      console.error(`   VERIFICATION FAILED: .hungry class still present on ${coords} immediately after removal attempt!`);
                             // } else {
                             //      console.log(`   VERIFICATION SUCCEEDED: .hungry class removed from ${coords}.`);
                             // }
                        } catch (e) {
                            console.error(`Error removing hungry class from element for ${coords}:`, e, pieceElement);
                        }
                    }
                } else {
                    // Log if element still not found
                     console.warn(`updateHungryVisual: Element not found for ${coords} (even with potential direct reference).`);
                }
            }


            // --- Highlighting & Visual Feedback ---

            /**
             * Highlights valid move and attack squares for a given piece.
             * Adds temporary highlight classes ('valid-move-highlight', 'valid-attack-highlight')
             * and, if `isSelection` is true, applies persistent visual styles ('valid-move', 'valid-attack').
             * Moves blocked by the repetition rule are styled red.
             * @param {string} fromCoords - The coordinates of the piece whose moves to highlight.
             * @param {boolean} [isSelection=true] - If true, apply persistent styles (for click/drag selection).
             *                                      If false, only add highlight classes (for hover).
             */
            function highlightValidMoves(fromCoords, isSelection = true) {
                clearHighlights(); // Clear previous highlights first
                const piece = gameState.board[fromCoords];

                 // Don't highlight if no piece or (if selecting) it's not current player's piece
                if (!piece || (isSelection && piece.player !== gameState.currentPlayer)) return;

                // Get all potential destinations (geometrically possible)
                const destinations = getPotentialMoveDestinations(fromCoords, piece);

                destinations.forEach(toCoords => {
                    const cell = document.getElementById(getCellElementId(toCoords));
                    if (!cell) return; // Skip if cell not found

                    // Validate the move legally, including the NEW repetition check
                    // Pass a copy of piece data to avoid potential side effects during validation
                    const validation = isValidMove(fromCoords, toCoords, { ...piece });

                    // --- START: Updated Highlighting Logic ---
                    if (validation.valid) {
                        // Standard valid move highlighting (Green)
                        cell.classList.add('valid-move-highlight');
                        if (gameState.board[toCoords]) { // Attack move
                            cell.classList.add('valid-attack-highlight');
                            if (isSelection) cell.classList.add('valid-attack'); // Red for attack target
                        } else { // Non-attack move
                            if (isSelection) cell.classList.add('valid-move'); // Green for empty square
                        }
                         // Make valid destination cells focusable via keyboard nav
                         cell.setAttribute('tabindex', '0');
                    } else if (validation.reasonCode === 'REPETITION_RULE') {
                        // Highlight as blocked by repetition (Red)
                         console.log(`Highlighting: ${toCoords} blocked by repetition rule for ${piece.player}.`);
                        cell.classList.add('valid-attack-highlight'); // Use attack class for red border effect
                        if (isSelection) {
                            cell.classList.add('valid-attack'); // Use attack class for red background fill
                        }
                         // Optional: Add a specific class like 'repetition-blocked' for more distinct styling if needed
                         // cell.classList.add('repetition-blocked');

                         // Keep blocked cells non-focusable via keyboard
                         cell.setAttribute('tabindex', '-1');
                    }
                    // else: invalid for other reasons (terrain, jump blocked, etc.) - do nothing, no highlight
                    // --- END: Updated Highlighting Logic ---
                });

                // If this is a selection (not just hover), mark the source piece as selected
                if (isSelection) {
                    const pieceEl = document.getElementById(getPieceElementId(fromCoords));
                    if (pieceEl) pieceEl.classList.add('selected');
                }
            }

            /**
             * Removes all move/attack highlights and selection styles from cells and pieces.
             * Resets cell tabindex attributes.
             */
            function clearHighlights() {
                // Remove highlight classes from all cells
                boardGridWrapper.querySelectorAll('.cell').forEach(cell => {
                    cell.classList.remove('valid-move', 'valid-attack', 'valid-move-highlight', 'valid-attack-highlight');
                     // Reset tabindex for cells (only valid moves should be tabbable temporarily)
                    cell.setAttribute('tabindex', '-1');
                });

                // If no piece is currently selected, remove selection style from any piece that might have it
                if (!selectedPieceCoords) {
                    boardGridWrapper.querySelectorAll('.piece.selected').forEach(p => p.classList.remove('selected'));
                }
                // Ensure pieces' tabindex is correctly set (only current player's pieces should be 0)
                 updateAllPieceAccessibility();

                 // Restore tabindex=0 for the currently focused element if focus wasn't lost
                if (focusedCoords) {
                    let focusedEl = document.getElementById(getCellElementId(focusedCoords)) || document.getElementById(getPieceElementId(focusedCoords));
                     // Check if the focused element should indeed be focusable
                     const shouldBeFocusable = focusedEl?.classList.contains('piece') && focusedEl?.dataset.player === gameState.currentPlayer && !gameState.gameOver;
                    if (focusedEl && shouldBeFocusable) {
                        focusedEl.setAttribute('tabindex', '0');
                    } else if (focusedEl && !focusedEl.classList.contains('piece')) {
                         // Cells generally aren't focusable unless a valid move target
                         focusedEl.setAttribute('tabindex', '-1');
                    }
                }
            }


            /**
             * Briefly flashes the background color of a cell for visual feedback.
             * @param {string} coords - The coordinates of the cell to flash.
             * @param {string} [color='red'] - The color to flash ('red' or 'green').
             * @param {number} [duration=300] - The total duration of the flash in milliseconds.
             */
            function flashCell(coords, color = 'red', duration = 300) {
                const cell = document.getElementById(getCellElementId(coords));
                if (cell) {
                    const originalTransition = cell.style.transition; // Store original transition
                    // Apply flash color quickly
                    cell.style.transition = `background-color ${duration / 2}ms ease-out`;
                    cell.style.backgroundColor = color === 'red' ? 'rgba(255,0,0,0.5)' : 'rgba(0,255,0,0.5)';
                    // After half the duration, start fading back to original
                    setTimeout(() => {
                        cell.style.backgroundColor = ''; // Remove inline style, revert to CSS background
                        // After fade out, restore original transition property
                        setTimeout(() => {
                            cell.style.transition = originalTransition;
                         }, 50); // Small delay to ensure background removal registers before transition change
                    }, duration / 2);
                }
            }

            /**
             * Removes the visual highlighting from the last move squares for a specific player.
             * @param {string} player - The player ('orange' or 'yellow') whose highlights to clear.
             */
            function clearPlayerLastMoveHighlight(player) {
                if (!player || !playerLastMoves[player]) return; // Ensure valid player

                const lastMove = playerLastMoves[player];
                // console.log(`Clearing highlights for ${player}:`, lastMove); // Debug log

                // Function to remove classes from a cell if it exists
                const removeClasses = (coords) => {
                    if (!coords) return;
                    const cell = document.getElementById(getCellElementId(coords));
                    if (cell) {
                        cell.classList.remove('last-move-from', 'last-move-to', `${player}-last-move`);
                    }
                };

                removeClasses(lastMove.from);
                removeClasses(lastMove.to);

                // Clear the stored move for the player AFTER removing classes
                // playerLastMoves[player] = { from: null, to: null }; // Moved clearing state to performMove
            }

            /**
             * Highlights the starting and ending squares of the last known moves for both players.
             */
            function highlightLastMoves() {
                // console.log("Highlighting last moves:", playerLastMoves); // Debug log

                // Clear ALL existing highlights first to prevent conflicts
                 boardGridWrapper.querySelectorAll('.cell.last-move-from, .cell.last-move-to, .cell.orange-last-move, .cell.yellow-last-move').forEach(cell => {
                     cell.classList.remove('last-move-from', 'last-move-to', 'orange-last-move', 'yellow-last-move');
                 });


                // Apply highlights for each player
                for (const player in playerLastMoves) {
                    const move = playerLastMoves[player];
                    if (move.from && move.to) {
                        const fromCell = document.getElementById(getCellElementId(move.from));
                        const toCell = document.getElementById(getCellElementId(move.to));

                        if (fromCell) {
                            fromCell.classList.add('last-move-from');
                            fromCell.classList.add(`${player}-last-move`); // Add player class
                        }
                        if (toCell) {
                            toCell.classList.add('last-move-to');
                            toCell.classList.add(`${player}-last-move`); // Add player class
                        }
                    }
                }
            }


            // --- Event Listeners Setup ---
            resetButton.addEventListener('click', () => initializeGame()); // Reset with default setup
            undoButton.addEventListener('click', undoMove); // Undo move on button click

            // --- Load State Button Listener ---
            const loadStateButton = document.getElementById('load-state-button');
            const boardStateInput = document.getElementById('board-state-input');
            const loadStatusMessage = document.getElementById('load-status-message');

            if (loadStateButton && boardStateInput && loadStatusMessage) {
                loadStateButton.addEventListener('click', () => {
                    // Get the raw value from the input field
                    const rawStateString = boardStateInput.value;

                    if (!rawStateString || rawStateString.trim() === '') {
                        loadStatusMessage.textContent = "Please paste a state string first.";
                        loadStatusMessage.style.color = 'red';
                        return;
                    }

                    // --- START: Clean the input string ---
                    // 1. Split by comma (handles various comma placements)
                    // 2. Trim whitespace from each resulting piece
                    // 3. Filter out any empty strings that might result from extra commas
                    // 4. Join back together with a single comma separator
                    const cleanedStateString = rawStateString
                        .split(',')
                        .map(piece => piece.trim()) // Remove leading/trailing spaces from each part
                        .filter(piece => piece !== '') // Remove empty strings
                        .join(','); // Reconstruct the string
                    // --- END: Clean the input string ---

                    console.log("Raw input:", rawStateString);
                    console.log("Cleaned input for parsing:", cleanedStateString);

                    // Attempt to parse the *cleaned* string
                    const parsedBoard = parseBoardStateString(cleanedStateString);

                    if (parsedBoard) {
                        // --- Pass flag to initializeGame ---
                        initializeGame(parsedBoard, true); // Pass true for isLoadingFromFile
                        loadStatusMessage.textContent = "Board state loaded successfully!";
                        loadStatusMessage.style.color = '#28a745';
                        boardStateInput.value = '';
                    } else {
                        // If parsing failed, show an error message
                        loadStatusMessage.textContent = "Invalid state string format. Please check console for details.";
                        loadStatusMessage.style.color = 'red'; // Red color for error
                        // Optionally flash the input border red
                        boardStateInput.style.borderColor = 'red';
                        setTimeout(() => { boardStateInput.style.borderColor = 'var(--medium-gray)'; }, 2000);
                    }
                });

                // Focus/Blur Listeners (Keep these as they are)
                boardStateInput.addEventListener('focus', () => {
                    isLoadStateInputFocused = true;
                    console.log("Load state input focused, game keyboard shortcuts disabled.");
                });
                boardStateInput.addEventListener('blur', () => {
                    isLoadStateInputFocused = false;
                    console.log("Load state input blurred, game keyboard shortcuts enabled.");
                });

            } else {
                console.error("Could not find Load State button, input field, or status message element.");
            }
            // --- End Load State Button Listener ---

            // --- Accordion Logic ---
            const rulesButton = document.getElementById('rules-toggle-button');
            const rulesContent = document.getElementById('rules-content');

            if (rulesButton && rulesContent) {
                rulesButton.addEventListener('click', () => {
                    const isExpanded = rulesButton.getAttribute('aria-expanded') === 'true';

                    // Toggle ARIA attributes
                    rulesButton.setAttribute('aria-expanded', !isExpanded);
                    rulesContent.setAttribute('aria-hidden', isExpanded);

                    // Toggle visual state (classes and max-height)
                    rulesButton.classList.toggle('active');
                    rulesContent.classList.toggle('expanded'); // Toggle padding via class

                    if (!isExpanded) {
                        // Expand: Set max-height to content's scroll height
                        rulesContent.style.maxHeight = rulesContent.scrollHeight + 'px';
                        rulesButton.querySelector('.rules-button-text').textContent = 'Hide Game Rules';
                    } else {
                        // Collapse: Set max-height back to 0 (or null)
                        rulesContent.style.maxHeight = null; // Use null to revert to CSS value (0)
                        rulesButton.querySelector('.rules-button-text').textContent = 'Show Game Rules';
                    }
                });
            } else {
                console.warn("Rules accordion button or content not found.");
            }
            // --- End Accordion Logic ---

            // --- PvP Toggle Listener ---
            const pvpToggleButton = document.getElementById('pvp-toggle');

            if (pvpToggleButton) {
                pvpToggleButton.addEventListener('change', (event) => {
                    // ... (keep existing mode state update and AI timeout clearing) ...
                    isPlayerVsPlayerMode = event.target.checked;
                    console.log(`Player vs Player mode ${isPlayerVsPlayerMode ? 'ENABLED' : 'DISABLED'}`);
                    if (aiMoveTimeoutId) { clearTimeout(aiMoveTimeoutId); aiMoveTimeoutId = null; }

                    // --- Pause Clocks During Switch ---
                    pauseAllClocks();

                    // Determine required interaction state and resume clock
                    if (isPlayerVsPlayerMode) {
                        // Switching TO PvP: Enable interaction, resume clock for current player
                        console.log("PvP Mode ACTIVE: Ensuring player interaction is enabled.");
                        enablePlayerInteraction();
                        updateStatus(`${gameState.currentPlayer.toUpperCase()}'s turn (PvP Mode)`);
                        resumeClockForCurrentPlayer(); // Start the appropriate clock
                    } else {
                        // Switching TO PvE:
                        if (gameState.currentPlayer === PLAYERS.YELLOW && !gameState.gameOver) {
                            // AI's turn: Disable interaction, start AI clock, schedule AI move.
                            console.log("PvE Mode ACTIVE and Yellow's turn: Disabling interaction, scheduling AI move.");
                            disablePlayerInteraction();
                            undoButton.disabled = true; // Disable undo during AI thinking
                            startClock(PLAYERS.YELLOW); // Start AI clock *before* the delay
                            aiMoveTimeoutId = setTimeout(triggerAIMove, 1500);
                        } else {
                            // Human's turn (Orange): Enable interaction, start Orange clock.
                            console.log("PvE Mode ACTIVE and Orange's turn: Ensuring player interaction is enabled.");
                            enablePlayerInteraction();
                            resumeClockForCurrentPlayer(); // Start Orange's clock
                        }
                    }

                    // Update accessibility and Undo button state
                    updateAllPieceAccessibility();
                    updateUndoButtonState();
                });
            } else {
                console.warn("PvP toggle button not found.");
            }
            // --- End PvP Toggle Listener ---

            // --- Initial Game Setup ---
            console.log("Initializing Clesto Game...");
            initializeGame(); // Start the game when the DOM is ready
            console.log("Game setup complete. Board and UI ready.");

        }); // End DOMContentLoaded event listener
    </script>

</body>

</html>