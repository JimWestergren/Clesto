<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Play Clesto, the Jungle Chess game online. A strategy board game with unique animal movements and rules.">
    <title>CLESTO: The Jungle Chess Game</title>

    <!-- Preload key visual assets -->
    <link rel="preload" as="image" href="https://staticjw.com/clesto/board.png">
    <link rel="preload" as="image" href="https://staticjw.com/clesto/animals/elephant-orange.png">
    <link rel="preload" as="image" href="https://staticjw.com/clesto/animals/lion-orange.png">
    <link rel="preload" as="image" href="https://staticjw.com/clesto/animals/elephant-yellow.png">
    <link rel="preload" as="image" href="https://staticjw.com/clesto/animals/lion-yellow.png">

    <style>
        /* --- Global Variables & Basic Setup --- */
        :root {
            /* Player Colors */
            --orange-color: #E67E22;
            --yellow-color: #F1C40F;
            --dark-orange: #D35400;
            --dark-yellow: #F39C12;

            /* UI Colors */
            --light-gray: #f8f9fa;
            --medium-gray: #dee2e6;
            --dark-gray: #343a40;

            /* Highlight & Feedback Colors */
            --cell-highlight-move: rgba(0, 255, 0, 0.7);
            /* Green for valid move */
            --cell-highlight-attack: rgba(255, 0, 0, 0.7);
            /* Red for valid attack */
            --piece-select-glow: rgba(0, 191, 255, 0.9);
            /* Blue glow for selected piece */
            --hungry-outline: rgba(255, 0, 0, 0.8);
            /* Dashed red outline for hungry pieces */
            --ai-move-from-bg: rgba(0, 0, 255, 0.15);
            /* Light blue for AI's previous move start */
            --ai-move-to-bg: rgba(0, 0, 255, 0.3);
            /* Darker blue for AI's previous move end */
            --focus-outline: 2px solid #007bff;
            /* Standard focus indicator */

            /* Layout Dimensions */
            --board-max-width: 490px;
            --ui-max-width: 300px;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: var(--light-gray);
            color: var(--dark-gray);
            padding: 10px;
            margin: 0;
            box-sizing: border-box;
            width: 100%;
            min-height: 100vh;
        }

        h1 {
            margin-top: 10px;
            margin-bottom: 15px;
            color: var(--dark-gray);
            font-weight: 300;
            border-bottom: 1px solid var(--medium-gray);
            padding-bottom: 10px;
            font-size: 1.8em;
            text-align: center;
            width: 100%;
            /* Max width matches the combined width of board and UI */
            max-width: calc(var(--board-max-width) + var(--ui-max-width) + 40px);
        }

        main {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            margin-top: 10px;
            width: 100%;
            max-width: calc(var(--board-max-width) + var(--ui-max-width) + 40px);
            box-sizing: border-box;
        }

        /* --- Board Styling --- */
        #board {
            /* Outer container: Sets dimensions, background image, and padding */
            width: var(--board-max-width);
            max-width: 100%;
            /* Responsive width */
            aspect-ratio: 7 / 9;
            /* Maintain board proportions */
            height: auto;
            border: none;
            position: relative;
            background-image: url('https://staticjw.com/clesto/board.png');
            background-size: cover;
            background-position: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
            border-radius: 5px;
            outline: none;
            /* For custom focus */
            box-sizing: border-box;
            padding: 21px 17px;
            /* Adjust padding to align grid with background */
            overflow: hidden;
            /* Clip any potential overflow */
        }

        #board-grid-wrapper {
            /* Inner container: Holds the grid cells and pieces */
            width: 100%;
            height: 100%;
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            grid-template-rows: repeat(9, 1fr);
            position: relative;
            outline: none;
        }

        #board:focus {
            /* Custom focus style for the board */
            box-shadow: 0 0 0 3px var(--focus-outline);
        }

        .cell {
            /* Individual grid cells */
            width: 100%;
            height: 100%;
            border: none;
            box-sizing: border-box;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.6em;
            /* For coordinate display (optional) */
            color: rgba(0, 0, 0, 0.3);
            user-select: none;
            background-clip: padding-box;
            /* Ensure background doesn't overlap borders */
            transition: background-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            outline: none;
            /* For custom focus */
        }

        .cell:focus {
            /* Custom focus style for cells */
            box-shadow: inset 0 0 0 3px var(--focus-outline);
            z-index: 5;
            /* Bring focus outline above other elements */
        }

        .cell::before {
            /* Pseudo-element for styling special terrain (water, traps, dens) */
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            /* Doesn't interfere with clicks/drags */
            box-sizing: border-box;
            border-radius: inherit;
            opacity: 0.8;
            /* Slightly transparent overlay */
        }

        /* Specific terrain styles using the ::before pseudo-element */
        .water::before {
            background-color: rgba(100, 150, 255, 0.3);
        }

        .trap-orange::before {
            /* Trap in Orange's starting area (affects Yellow) */
            background-color: rgba(255, 150, 150, 0.3);
            border: 2px dashed var(--hungry-outline);
            /* Red dashed border */
        }

        .trap-yellow::before {
            /* Trap in Yellow's starting area (affects Orange) */
            background-color: rgba(255, 255, 150, 0.3);
            border: 2px dashed var(--dark-yellow);
            /* Yellow dashed border */
        }

        .den-orange::before {
            background-color: rgba(255, 100, 0, 0.4);
            border: 3px solid var(--dark-orange);
        }

        .den-yellow::before {
            background-color: rgba(255, 255, 0, 0.4);
            border: 3px solid var(--dark-yellow);
        }

        /* Highlighting for AI's last move */
        .ai-move-from {
            background-color: var(--ai-move-from-bg) !important;
        }

        .ai-move-to {
            background-color: var(--ai-move-to-bg) !important;
        }

        /* --- Piece Styling --- */
        .piece {
            /* Width calculated as a percentage of the GRID WRAPPER */
            /* Cell Width = 100% / 7 columns ≈ 14.2857% */
            /* Piece Width = 84.5% of Cell Width */
            /* Piece % of Wrapper = (100/7) * 0.845 ≈ 12.07% */
            width: 12.07%;
            aspect-ratio: 1 / 1;
            /* Make piece square relative to its width */
            height: auto;
            /* Height is automatically determined by width + aspect ratio */

            position: absolute;
            /* Positioned relative to #board-grid-wrapper */
            left: 0;
            /* Left position set by JavaScript */
            top: 0;
            /* Top position set by JavaScript */

            cursor: grab;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.25);
            z-index: 10;
            /* Pieces sit above cells */
            /* Smooth transitions for movement, scaling, and effects */
            transition: transform 0.3s ease-in-out, box-shadow 0.2s ease, outline 0.2s ease, left 0.3s ease-in-out, top 0.3s ease-in-out;
            user-select: none;
            /* Prevent text selection */
            overflow: visible;
            /* Allow outlines/glows to extend slightly */
            background: none;
            border: none;
            border-radius: 50%;
            /* Circular pieces */
            outline: none;
            /* Custom focus/selection */
            touch-action: none;
            /* Improve touch interactions */
        }

        .piece img {
            /* Styling for the animal image inside the piece div */
            width: 100%;
            height: 100%;
            display: block;
            object-fit: contain;
            /* Scale image while preserving aspect ratio */
            pointer-events: none;
            /* Image doesn't interfere with events on the parent div */
            border-radius: 50%;
        }

        .piece:focus {
            /* Custom focus style for pieces */
            outline: 3px solid var(--focus-outline);
            outline-offset: 1px;
            z-index: 15;
            /* Bring focused piece above others */
        }

        .piece.dragging {
            /* Style applied when a piece is being dragged */
            opacity: 0.6;
            cursor: grabbing;
            z-index: 100;
            /* Ensure dragged piece is on top */
            transform: scale(1.1);
            /* Slightly enlarge */
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            /* Enhance shadow */
            transition: transform 0.15s ease-out, box-shadow 0.2s ease, outline 0.2s ease;
            /* Faster transition while dragging */
        }

        .piece.captured {
            /* Animation for captured pieces */
            animation: capture-animation 0.4s ease-out forwards;
        }

        /* --- Trap Rank Indicator Styling --- */
        .trap-rank-indicator {
            position: absolute;
            top: -2px; /* Position slightly above the piece image */
            left: 0;
            width: 100%;
            text-align: center;
            font-size: 0.75em; /* Smaller font size */
            font-weight: bold;
            color: white; /* White text */
            background-color: rgba(200, 0, 0, 0.75); /* Reddish semi-transparent background */
            border-radius: 3px;
            padding: 0 2px;
            z-index: 1; /* Above the image (z-index 0 default) but below selection/hungry (z-index > 1) */
            pointer-events: none; /* So it doesn't interfere with clicks/drags */
            display: none; /* Hidden by default */
            box-sizing: border-box;
            user-select: none; /* Prevent text selection */
        }

        .trap-rank-indicator.visible {
            display: block; /* Show the indicator when this class is added */
        }

        @keyframes capture-animation {
            0% {
                transform: scale(1);
                opacity: 1;
            }

            100% {
                transform: scale(0.5);
                opacity: 0;
            }
        }

        /* --- Visual Feedback --- */
        .valid-move {
            /* Style for cells representing a valid non-attack move */
            box-shadow: inset 0 0 0 3px var(--cell-highlight-move);
            background-color: rgba(0, 255, 0, 0.1);
        }

        .valid-attack {
            /* Style for cells representing a valid attack move */
            box-shadow: inset 0 0 0 3px var(--cell-highlight-attack);
            background-color: rgba(255, 0, 0, 0.1);
        }

        .selected {
            /* Outline for the currently selected piece */
            outline: 3px solid var(--piece-select-glow); /* Blue solid */
            outline-offset: 1px;
            z-index: 16; /* Ensure selected outline is visually prominent */
        }

        .hungry {
            /* Box-shadow glow for pieces that must attack if possible */
            /* outline: 3px dashed var(--hungry-outline); */ /* Keep old style commented */
            /* outline-offset: 2px; */
            box-shadow: 0 0 0 3px var(--hungry-outline); /* Red 'glow' effect */
             /* Optional: Add a subtle animation */
            /* animation: hungry-pulse 1.5s infinite ease-in-out; */
        }

        /* Optional pulse animation for hungry pieces */
        @keyframes hungry-pulse {
            0% { box-shadow: 0 0 0 3px var(--hungry-outline); }
            50% { box-shadow: 0 0 0 5px rgba(255, 0, 0, 0.5); } /* Slightly wider, semi-transparent */
            100% { box-shadow: 0 0 0 3px var(--hungry-outline); }
        }

        /* --- UI Info Panel Styling --- */
        #ui-info-section {
            width: var(--ui-max-width);
            max-width: 100%;
            /* Responsive width */
            border: none;
            padding: 20px;
            background-color: #ffffff;
            height: fit-content;
            /* Adjust height based on content */
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
        }

        #ui-info-section h2,
        #ui-info-section h3 {
            margin-top: 0;
            margin-bottom: 15px;
            border-bottom: 1px solid var(--medium-gray);
            padding-bottom: 8px;
            font-weight: 400;
            color: var(--dark-gray);
        }

        #ui-info-section h3 {
            margin-top: 15px;
            /* Space above subheadings */
        }

        #ui-info-section p {
            margin: 10px 0;
            line-height: 1.5;
        }

        #turn-indicator {
            font-weight: 600;
            padding: 3px 6px;
            border-radius: 4px;
            color: white;
        }

        /* Player-specific turn indicator colors */
        #turn-indicator.orange {
            background-color: var(--orange-color);
        }

        #turn-indicator.yellow {
            background-color: var(--yellow-color);
            color: var(--dark-gray);
            /* Better contrast */
        }

        #turn-indicator.game-over {
            background-color: #dc3545;
            /* Red for game over */
        }

        #status-message {
            min-height: 1.5em;
            /* Prevent layout shifts */
        }

        /* --- Buttons --- */
        .button-container {
            margin-top: auto;
            /* Pushes buttons to the bottom of the UI panel */
            padding-top: 20px;
            display: flex;
            gap: 10px;
            justify-content: space-around;
            flex-wrap: wrap;
        }

        .game-button {
            padding: 10px 18px;
            cursor: pointer;
            border-radius: 5px;
            border: none;
            font-size: 0.95em;
            transition: background-color 0.2s ease, box-shadow 0.2s ease;
            background-color: #6c757d;
            /* Default gray */
            color: white;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            outline: none;
            /* Custom focus */
            margin-bottom: 5px;
            /* Spacing when wrapping */
        }

        .game-button:hover {
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.15);
        }

        .game-button:focus-visible {
            /* Style for keyboard focus */
            box-shadow: 0 0 0 3px var(--focus-outline);
        }

        /* Specific button colors */
        #reset-button {
            background-color: #007bff;
            /* Blue */
        }

        #reset-button:hover {
            background-color: #0056b3;
        }

        #undo-button {
            background-color: #ffc107;
            /* Yellow */
            color: var(--dark-gray);
        }

        #undo-button:hover {
            background-color: #e0a800;
        }

        #undo-button:disabled {
            background-color: #adb5bd;
            cursor: not-allowed;
            box-shadow: none;
        }

        /* --- Logs --- */
        #move-log {
            height: 220px;
            /* Fixed height with scrolling */
            overflow-y: auto;
            border: 1px solid var(--medium-gray);
            border-radius: 5px;
            padding: 8px 10px;
            margin-top: 10px;
            font-size: 0.9em;
            background-color: #ffffff;
            line-height: 1.6;
        }

        .log-entry {
            padding: 3px 0;
            border-bottom: 1px dashed var(--medium-gray);
        }

        .log-entry:last-child {
            border-bottom: none;
        }

        .log-entry .turn-number {
            display: inline-block;
            width: 25px;
            font-weight: bold;
            color: #6c757d;
            margin-right: 5px;
        }

        .log-entry .log-orange,
        .log-entry .log-yellow {
            display: inline-block;
            min-width: 60px;
            padding: 2px 5px;
            border-radius: 3px;
            margin: 0 3px;
            text-align: center;
        }

        /* Move log colors matching player colors */
        .log-entry .log-orange {
            background-color: rgba(230, 126, 34, 0.15);
            color: var(--dark-orange);
            border: 1px solid rgba(230, 126, 34, 0.3);
        }

        .log-entry .log-yellow {
            background-color: rgba(241, 196, 15, 0.15);
            color: #c78b02;
            /* Darker yellow for text */
            border: 1px solid rgba(241, 196, 15, 0.3);
        }

        .log-entry .placeholder {
            /* Style for when a player hasn't moved yet in the current turn */
            color: #adb5bd;
            font-style: italic;
            display: inline-block;
            min-width: 60px;
            text-align: center;
        }

        #board-state-log {
            /* Displays a string representation of the board state (for debugging/repetition check) */
            margin-top: 10px;
            border: 1px solid var(--medium-gray);
            border-radius: 5px;
            padding: 10px;
            font-size: 0.75em;
            font-family: monospace;
            word-wrap: break-word;
            background-color: #ffffff;
            max-height: 90px;
            overflow-y: auto;
            line-height: 1.4;
        }

        /* --- Debug Log Section Styling (Optional) --- */
        #debug-log-container {
            width: 100%;
            max-width: calc(var(--board-max-width) + var(--ui-max-width) + 40px);
            margin-top: 20px;
            padding: 15px;
            background-color: #f1f3f5;
            border: 1px solid var(--medium-gray);
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            box-sizing: border-box;
        }

        #debug-log-container h2 {
            margin-top: 0;
            margin-bottom: 10px;
            font-weight: 400;
            border-bottom: 1px solid var(--medium-gray);
            padding-bottom: 5px;
            font-size: 1.2em;
        }

        #debug-log-output {
            height: 200px;
            max-height: 40vh;
            /* Limit height relative to viewport */
            overflow-y: auto;
            background-color: #ffffff;
            border: 1px solid var(--medium-gray);
            border-radius: 3px;
            padding: 8px;
            font-family: monospace;
            font-size: 0.8em;
            white-space: pre-wrap;
            /* Wrap long lines */
            word-break: break-word;
            line-height: 1.4;
        }

        .debug-log-entry {
            padding: 2px 0;
            border-bottom: 1px dashed #e9ecef;
        }

        .debug-log-entry:last-child {
            border-bottom: none;
        }

        .debug-log-timestamp {
            color: #6c757d;
            margin-right: 8px;
        }

        /* Color coding for debug levels */
        .debug-log-warn {
            color: #fd7e14;
        }

        .debug-log-error {
            color: #dc3545;
            font-weight: bold;
        }

        .debug-hidden {
            /* Class to hide the debug section */
            display: none;
        }

        /* --- Rules Accordion Styling --- */
        #rules-accordion-container {
            width: 100%;
            max-width: calc(var(--board-max-width) + var(--ui-max-width) + 40px); /* Match main content width */
            margin: 15px auto 15px auto; /* Add some space around it */
            border: 1px solid var(--medium-gray);
            border-radius: 5px;
            overflow: hidden; /* Clip content during transition */
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            box-sizing: border-box;
            background-color: #f8f9fa; /* Light background */
        }

        .rules-toggle-button {
            background-color: #e9ecef; /* Slightly darker header background */
            color: var(--dark-gray);
            cursor: pointer;
            padding: 12px 18px;
            width: 100%;
            border: none;
            text-align: left;
            outline: none;
            font-size: 1.1em;
            transition: background-color 0.3s ease;
            display: flex;
            justify-content: space-between; /* Space between text and icon */
            align-items: center;
            font-weight: 500;
        }

        .rules-toggle-button:hover,
        .rules-toggle-button.active {
            background-color: #dee2e6; /* Darker on hover/active */
        }

        .rules-toggle-button:focus-visible {
             box-shadow: 0 0 0 3px var(--focus-outline);
             z-index: 1; /* Ensure focus outline is visible */
             position: relative; /* Needed for z-index */
        }

        .rules-icon {
            font-size: 1.2em;
            font-weight: bold;
            transition: transform 0.3s ease;
        }

        .rules-toggle-button.active .rules-icon {
            transform: rotate(45deg); /* Rotate '+' to 'x' */
        }

        .rules-content {
            padding: 0 18px; /* Add padding only when open */
            background-color: white;
            max-height: 0; /* Initially collapsed */
            overflow: hidden;
            transition: max-height 0.3s ease-out, padding 0.3s ease-out; /* Smooth transition */
            border-top: 1px solid var(--medium-gray); /* Separator line */
        }

        .rules-content.expanded {
             padding: 15px 18px; /* Padding when expanded */
             /* max-height is set by JS */
        }


        .rules-content h3 {
            margin-top: 15px;
            margin-bottom: 8px;
            color: var(--dark-orange);
            border-bottom: 1px solid var(--medium-gray);
            padding-bottom: 4px;
        }
         .rules-content h3:first-child {
            margin-top: 0;
         }

        .rules-content h4 {
            margin-top: 12px;
            margin-bottom: 5px;
            color: var(--dark-gray);
        }


        .rules-content p,
        .rules-content ul,
        .rules-content ol {
            margin-bottom: 10px;
            line-height: 1.6;
        }

        .rules-content ul,
        .rules-content ol {
            padding-left: 25px; /* Indent lists */
        }
         .rules-content ul ul,
         .rules-content ol ol,
         .rules-content ul ol,
         .rules-content ol ul {
             margin-bottom: 5px; /* Less space for nested lists */
         }

        .rules-content li {
            margin-bottom: 5px;
        }

        .rules-content strong {
            font-weight: 600; /* Make bold text stand out */
        }

        /* --- Mobile Responsiveness --- */
        @media (max-width: 850px) {

            /* Adjust layout for smaller screens */
            body {
                padding: 5px;
            }

            h1 {
                font-size: 1.5em;
                margin-bottom: 10px;
            }

            main {
                flex-direction: column;
                align-items: center;
                gap: 15px;
                padding: 0 5px;
                max-width: 100%;
            }

            /* Stack board and UI vertically */
            #board {
                width: 95vw;
                /* Use viewport width */
                max-width: var(--board-max-width);
                /* Still respect max width */
                padding: 10px 8px;
                /* Slightly reduce padding */
                order: 1;
                /* Place board first */
            }

            #ui-info-section {
                width: 95vw;
                max-width: var(--board-max-width);
                /* Match board max width */
                order: 2;
                /* Place UI below board */
            }

            /* Reduce log heights */
            #move-log {
                height: 150px;
            }

            #board-state-log {
                max-height: 60px;
            }

            .button-container {
                padding-top: 10px;
            }

            .game-button {
                padding: 8px 12px;
                font-size: 0.9em;
            }

            #debug-log-container {
                margin-top: 15px;
                width: 95vw;
                max-width: var(--board-max-width);
            }

            #debug-log-output {
                height: 150px;
            }
        }
    </style>
</head>

<body>

    <h1>CLESTO: The Jungle Chess Game</h1>

    <main id="game-container" role="main">
        <!-- Game Board Section -->
        <section aria-labelledby="board-label">
            <h2 id="board-label" class="visually-hidden">Game Board</h2>
            <div id="board" tabindex="0"> <!-- Outer container for board background/focus -->
                <div id="board-grid-wrapper"> <!-- Inner container for grid layout and pieces -->
                    <!-- Cells will be generated by JavaScript here -->
                </div>
            </div>
        </section>

        <!-- UI and Information Section -->
        <section id="ui-info-section" role="region" aria-labelledby="ui-info-heading">
            <h2 id="ui-info-heading">Game Info</h2>
            <p>Turn: <span id="turn-indicator">Orange</span></p>
            <p>Status: <span id="status-message" aria-live="polite">Loading...</span></p>

            <h3>Move Log</h3>
            <div id="move-log" role="log" aria-live="polite" aria-atomic="false">
                <!-- Log entries will be added by JavaScript here -->
            </div>

            <h3>Board State</h3>
            <div id="board-state-log">
                <!-- Board state string for debugging/repetition check -->
            </div>

            <!-- Load From State Section -->
            <div style="margin-top: 15px; border-top: 1px solid var(--medium-gray); padding-top: 10px;">
                <label for="board-state-input" style="display: block; margin-bottom: 5px; font-weight: bold;">Load From State String:</label>
                <input type="text" id="board-state-input" placeholder="Paste state string (e.g., 8G7,7A9,...)" style="width: calc(100% - 12px); padding: 6px; margin-bottom: 8px; border: 1px solid var(--medium-gray); border-radius: 3px;">
                <button id="load-state-button" class="game-button" style="background-color: #28a745;">Load State</button> <!-- Green button -->
                <p id="load-status-message" style="font-size: 0.85em; color: #6c757d; min-height: 1.2em; margin-top: 5px;"></p>
            </div>
            <!-- End Load From State Section -->

            <div class="button-container">
                <button id="undo-button" class="game-button" disabled>Undo Turn</button>
                <button id="reset-button" class="game-button">Reset Game</button>
            </div>
        </section>
    </main>

    <!-- Rules Accordion Section -->
    <section id="rules-accordion-container" aria-labelledby="rules-heading">
        <button id="rules-toggle-button" class="rules-toggle-button" aria-expanded="false" aria-controls="rules-content">
            <span class="rules-button-text">Show Game Rules</span>
            <span class="rules-icon" aria-hidden="true">+</span>
        </button>
        <div id="rules-content" class="rules-content" role="region" aria-hidden="true">
            <h2 id="rules-heading" class="visually-hidden">Game Rules</h2>

            <h3>Objective</h3>
            <p>Be the first player to move any of your animals into the opponent's <strong>Den</strong> square.</p>
            <ul>
                <li>Orange's Den: <strong>d1</strong></li>
                <li>Yellow's Den: <strong>d9</strong></li>
            </ul>

            <h3>Gameplay</h3>
            <ul>
                <li>Orange starts the game.</li>
                <li>Players take turns moving one animal per turn.</li>
                <li>Animals move one square horizontally or vertically (never diagonally).</li>
                <li>You cannot move onto a square occupied by your own animal.</li>
            </ul>

            <h4>Attacking</h4>
            <ul>
                <li>You can move onto a square occupied by an opponent's animal if your animal's rank is <strong>equal to or higher than</strong> the opponent's rank.</li>
                <li>This is an attack, and the opponent's captured animal is removed from the board.</li>
                <li><strong>Exception:</strong> See Special Powers for Rat vs. Elephant.</li>
            </ul>

            <h4>End of Turn Sequence</h4>
            <p>After making your move, the following checks happen automatically:</p>
            <ol>
                <li><strong>Declare Hungry:</strong> Any of the <em>opponent's</em> animals that can now make a valid attack on <em>your</em> next turn are marked as <strong>hungry</strong> (red glow).</li>
                <li><strong>Check Starvation:</strong> If any of <em>your own</em> animals were marked as hungry at the <em>start</em> of your turn, but you did not make an attacking move with any of them, those hungry animals starve and are removed from the board.</li>
            </ol>

            <h4>Special Squares</h4>
            <ul>
                <li><strong>Den:</strong> Your own Den (Orange: d1, Yellow: d9) cannot be entered by your pieces. Reaching the opponent's Den wins the game. A <strong>hungry</strong> animal cannot enter the opponent's Den.</li>
                <li><strong>Water (b4-c6, e4-f6):</strong> Only specific animals can enter or move on water (see Special Powers).</li>
                <li><strong>Traps:</strong>
                    <ul>
                        <li>Orange Traps (affect Yellow): <strong>c1, d2, e1</strong></li>
                        <li>Yellow Traps (affect Orange): <strong>c9, d8, e9</strong></li>
                    </ul>
                    Any animal landing on an opponent's Trap square has its rank effectively reduced to <strong>0</strong> for the purpose of being attacked while on that square. A "(0)" marker appears above trapped animals. However, an animal attacking <em>from</em> a trap square uses its normal rank.
                 </li>
            </ul>

            <h4>Other Rules</h4>
            <ul>
                <li>You must make a move each turn (passing is not allowed).</li>
                <li>The game cannot end in a draw.</li>
            </ul>

            <h3>Special Powers</h3>
            <ul>
                <li><strong>Rat [1]:</strong>
                    <ul>
                        <li>Can enter and move on <strong>Water</strong> squares.</li>
                        <li>Can attack the <strong>Elephant [8]</strong>, but only when attacking from a land square (cannot attack Elephant from Water).</li>
                    </ul>
                 </li>
                 <li><strong>Dog [3]:</strong>
                    <ul>
                         <li>Can enter and move on <strong>Water</strong> squares.</li>
                    </ul>
                 </li>
                 <li><strong>Lion [7] and Tiger [6]:</strong>
                    <ul>
                        <li>Can <strong>jump</strong> horizontally or vertically over <strong>Water</strong> squares.</li>
                        <li>A jump moves from a land square directly across 2 or 3 water squares to another land square.</li>
                        <li>Jumps can be used to move or attack.</li>
                        <li>A jump is blocked if an opponent's swimming animal (Rat or Dog) occupies any water square along the jump path.</li>
                    </ul>
                </li>
                 <li><strong>Leopard [5]:</strong>
                    <ul>
                        <li>Can <strong>jump horizontally</strong> over <strong>Water</strong> squares (across 2 water squares).</li>
                        <li>Cannot jump vertically.</li>
                        <li>Jumps follow the same blocking rules as Lion/Tiger.</li>
                    </ul>
                </li>
                <li><strong>Elephant [8]:</strong> Can attack the Rat [1].</li>
            </ul>

            <h3>Repetition Limit</h3>
            <p>To prevent endless loops and ensure a winner, a repetition rule exists:</p>
            <ul>
                <li>Determine which player currently has more animals on the board. If tied, the starting player (Orange) is considered the "leading player".</li>
                <li>The leading player is <strong>not allowed</strong> to make a move that results in a board position that has already occurred <strong>3 times</strong> previously during the game (with them to move).</li>
                <li>If the leading player makes such a move, they lose, and the opponent wins.</li>
            </ul>
            <p><em>(Board positions are tracked automatically.)</em></p>

        </div><!-- /#rules-content -->
    </section><!-- /#rules-accordion-container -->

    <!-- Debug Log Section (conditionally displayed) -->
    <section id="debug-log-container" aria-labelledby="debug-log-heading">
        <h2 id="debug-log-heading">Debug Log</h2>
        <div id="debug-log-output">
            <!-- Console messages mirrored here if debug = true -->
        </div>
        <button id="clear-debug-log" class="game-button" style="margin-top: 10px; background-color: #dc3545;">Clear Log</button>
    </section>

    <!-- Utility class to visually hide elements but keep them accessible -->
    <style>
        .visually-hidden {
            position: absolute;
            width: 1px;
            height: 1px;
            margin: -1px;
            padding: 0;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            border: 0;
        }
    </style>

    <!-- Hidden container for preloading/caching piece image assets -->
    <div id="piece-assets" style="display: none;">
        <!-- Orange Pieces -->
        <img data-piece="O_8" src="https://staticjw.com/clesto/animals/elephant-orange.png" alt="Orange Elephant (8)" loading="lazy">
        <img data-piece="O_7" src="https://staticjw.com/clesto/animals/lion-orange.png" alt="Orange Lion (7)" loading="lazy">
        <img data-piece="O_6" src="https://staticjw.com/clesto/animals/tiger-orange.png" alt="Orange Tiger (6)" loading="lazy">
        <img data-piece="O_5" src="https://staticjw.com/clesto/animals/leopard-orange.png" alt="Orange Leopard (5)" loading="lazy">
        <img data-piece="O_4" src="https://staticjw.com/clesto/animals/wolf-orange.png" alt="Orange Wolf (4)" loading="lazy">
        <img data-piece="O_3" src="https://staticjw.com/clesto/animals/dog-orange.png" alt="Orange Dog (3)" loading="lazy">
        <img data-piece="O_2" src="https://staticjw.com/clesto/animals/cat-orange.png" alt="Orange Cat (2)" loading="lazy">
        <img data-piece="O_1" src="https://staticjw.com/clesto/animals/rat-orange.png" alt="Orange Rat (1)" loading="lazy">
        <!-- Yellow Pieces -->
        <img data-piece="Y_8" src="https://staticjw.com/clesto/animals/elephant-yellow.png" alt="Yellow Elephant (8)" loading="lazy">
        <img data-piece="Y_7" src="https://staticjw.com/clesto/animals/lion-yellow.png" alt="Yellow Lion (7)" loading="lazy">
        <img data-piece="Y_6" src="https://staticjw.com/clesto/animals/tiger-yellow.png" alt="Yellow Tiger (6)" loading="lazy">
        <img data-piece="Y_5" src="https://staticjw.com/clesto/animals/leopard-yellow.png" alt="Yellow Leopard (5)" loading="lazy">
        <img data-piece="Y_4" src="https://staticjw.com/clesto/animals/wolf-yellow.png" alt="Yellow Wolf (4)" loading="lazy">
        <img data-piece="Y_3" src="https://staticjw.com/clesto/animals/dog-yellow.png" alt="Yellow Dog (3)" loading="lazy">
        <img data-piece="Y_2" src="https://staticjw.com/clesto/animals/cat-yellow.png" alt="Yellow Cat (2)" loading="lazy">
        <img data-piece="Y_1" src="https://staticjw.com/clesto/animals/rat-yellow.png" alt="Yellow Rat (1)" loading="lazy">
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Debug Flag ---
            const debug = true; // SET TO true TO SHOW DEBUG PANEL, false TO HIDE

            // --- DOM Element References ---
            const boardElement = document.getElementById('board');
            const boardGridWrapper = document.getElementById('board-grid-wrapper');
            const turnIndicator = document.getElementById('turn-indicator');
            const statusMessage = document.getElementById('status-message');
            const resetButton = document.getElementById('reset-button');
            const undoButton = document.getElementById('undo-button');
            const moveLogElement = document.getElementById('move-log');
            const boardStateLogElement = document.getElementById('board-state-log');
            const pieceAssetContainer = document.getElementById('piece-assets');
            const debugLogContainer = document.getElementById('debug-log-container');
            const debugLogOutput = document.getElementById('debug-log-output');
            const clearDebugLogButton = document.getElementById('clear-debug-log');

            // --- Console Override & Debug Panel Logic ---
            // Store original console methods
            const originalConsole = {
                log: console.log,
                warn: console.warn,
                error: console.error
            };

            /**
             * Formats console arguments into a single string, handling objects and circular references.
             * @param {Array} args - The arguments passed to the console method.
             * @returns {string} A formatted string representation of the arguments.
             */
            function formatArgs(args) {
                const seen = new Set(); // Used to detect circular references in objects
                return Array.from(args).map(arg => {
                    if (typeof arg === 'object' && arg !== null) {
                        try {
                            // Stringify objects, handling circular references
                            seen.clear(); // Reset for each top-level object
                            return JSON.stringify(arg, (key, value) => {
                                if (typeof value === 'object' && value !== null) {
                                    if (seen.has(value)) {
                                        return '[Circular]'; // Placeholder for circular reference
                                    }
                                    seen.add(value);
                                }
                                return value;
                            }, 2); // Indent with 2 spaces for readability
                        } catch (e) {
                            // Handle potential errors during stringification
                            if (e instanceof TypeError && e.message.includes('circular structure')) {
                                return '[Circular Object]';
                            }
                            return '[Unserializable Object]';
                        }
                    }
                    if (typeof arg === 'function') {
                        return '[Function]';
                    }
                    if (typeof arg === 'undefined') {
                        return 'undefined';
                    }
                    return String(arg); // Convert other types to string
                }).join(' '); // Join arguments with spaces
            }

            /**
             * Logs a message to the debug panel if debugging is enabled.
             * @param {string} level - The log level ('log', 'warn', 'error').
             * @param {Array} args - The original arguments passed to the console method.
             */
            function logToPanel(level, args) {
                if (!debug || !debugLogOutput) return; // Only log if debug is true and panel exists

                const message = formatArgs(args);
                const timestamp = new Date().toLocaleTimeString();
                const entry = document.createElement('div');
                entry.classList.add('debug-log-entry');

                // Add timestamp
                const timeSpan = document.createElement('span');
                timeSpan.classList.add('debug-log-timestamp');
                timeSpan.textContent = `[${timestamp}]`;
                entry.appendChild(timeSpan);

                // Add message content with appropriate styling
                const messageSpan = document.createElement('span');
                messageSpan.textContent = message;
                if (level === 'warn') {
                    messageSpan.classList.add('debug-log-warn');
                } else if (level === 'error') {
                    messageSpan.classList.add('debug-log-error');
                }
                entry.appendChild(messageSpan);

                // Append to panel and scroll to bottom
                debugLogOutput.appendChild(entry);
                debugLogOutput.scrollTop = debugLogOutput.scrollHeight;
            }

            // Override console methods to also log to the panel
            console.log = function(...args) {
                originalConsole.log.apply(console, args); // Call original console.log
                logToPanel('log', args); // Log to panel
            };
            console.warn = function(...args) {
                originalConsole.warn.apply(console, args); // Call original console.warn
                logToPanel('warn', args); // Log to panel
            };
            console.error = function(...args) {
                originalConsole.error.apply(console, args); // Call original console.error
                logToPanel('error', args); // Log to panel
            };

            // Show or hide the debug panel based on the debug flag
            if (!debug && debugLogContainer) {
                debugLogContainer.classList.add('debug-hidden');
            } else if (debugLogContainer) {
                debugLogContainer.classList.remove('debug-hidden');
            }

            // Add event listener for the "Clear Log" button
            if (clearDebugLogButton && debugLogOutput) {
                clearDebugLogButton.addEventListener('click', () => {
                    debugLogOutput.innerHTML = ''; // Clear panel content
                    console.log("Debug log cleared.");
                });
            }
            // --- END Console Override ---


            // --- Game Constants ---
            const ROWS = 9;
            const COLS = 7;
            const PLAYERS = {
                ORANGE: 'orange',
                YELLOW: 'yellow'
            };
            const RANK_TO_NAME = {
                8: 'Elephant',
                7: 'Lion',
                6: 'Tiger',
                5: 'Leopard',
                4: 'Wolf',
                3: 'Dog',
                2: 'Cat',
                1: 'Rat'
            };
            const RANK_TO_CODE = { // Used for move notation
                8: '8',
                7: '7',
                6: '6',
                5: '5',
                4: '4',
                3: '3',
                2: '2',
                1: '1'
            };
            const SPECIAL_ABILITIES = { // Defines unique animal traits
                1: {
                    name: 'Rat',
                    rank: 1,
                    swims: true,
                    attacksElephant: true
                }, // Can swim, attack Elephant (unless Elephant is in water)
                2: {
                    name: 'Cat',
                    rank: 2
                },
                3: {
                    name: 'Dog',
                    rank: 3,
                    swims: true
                }, // Can swim
                4: {
                    name: 'Wolf',
                    rank: 4
                },
                5: {
                    name: 'Leopard',
                    rank: 5,
                    jumpH: true
                }, // Can jump horizontally over water
                6: {
                    name: 'Tiger',
                    rank: 6,
                    jumpH: true,
                    jumpV: true
                }, // Can jump horizontally and vertically over water
                7: {
                    name: 'Lion',
                    rank: 7,
                    jumpH: true,
                    jumpV: true
                }, // Can jump horizontally and vertically over water
                8: {
                    name: 'Elephant',
                    rank: 8
                } // Cannot be attacked by Rat (except special case)
            };
            const INITIAL_SETUP = { // Standard starting positions
                // Orange Pieces (Bottom Row Area) - Sorted Rank 8 to 1
                'a3': { player: PLAYERS.ORANGE, rank: 8 }, // Elephant
                'g1': { player: PLAYERS.ORANGE, rank: 7 }, // Lion
                'a1': { player: PLAYERS.ORANGE, rank: 6 }, // Tiger
                'e3': { player: PLAYERS.ORANGE, rank: 5 }, // Leopard
                'f2': { player: PLAYERS.ORANGE, rank: 4 }, // Wolf
                'c3': { player: PLAYERS.ORANGE, rank: 3 }, // Dog
                'b2': { player: PLAYERS.ORANGE, rank: 2 }, // Cat
                'g3': { player: PLAYERS.ORANGE, rank: 1 }, // Rat
                // Yellow Pieces (Top Row Area) - Sorted Rank 8 to 1
                'g7': { player: PLAYERS.YELLOW, rank: 8 }, // Elephant
                'a9': { player: PLAYERS.YELLOW, rank: 7 }, // Lion
                'g9': { player: PLAYERS.YELLOW, rank: 6 }, // Tiger
                'c7': { player: PLAYERS.YELLOW, rank: 5 }, // Leopard
                'b8': { player: PLAYERS.YELLOW, rank: 4 }, // Wolf
                'e7': { player: PLAYERS.YELLOW, rank: 3 }, // Dog
                'f8': { player: PLAYERS.YELLOW, rank: 2 }, // Cat
                'a7': { player: PLAYERS.YELLOW, rank: 1 }  // Rat
            };
            const WATER_SQUARES = new Set(['b4', 'c4', 'e4', 'f4', 'b5', 'c5', 'e5', 'f5', 'b6', 'c6', 'e6', 'f6']);
            const TRAPS = { // Opponent's pieces lose rank on these squares
                orange: new Set(['c9', 'd8', 'e9']), // Traps near Yellow's Den (affect Yellow pieces)
                yellow: new Set(['c1', 'd2', 'e1']) // Traps near Orange's Den (affect Orange pieces)
            };
            const ALL_TRAP_SQUARES = new Set([...TRAPS.orange, ...TRAPS.yellow]);
            const DENS = { // Winning squares for each player
                orange: 'd1', // Orange's Den
                yellow: 'd9' // Yellow's Den
            };
            const MINIMAX_DEPTH = 3; // Depth for AI search (higher = stronger but slower)


            // --- Game State Variables ---
            let gameState = {}; // Holds current board, player, turn, etc.
            let gameHistory = []; // Stores previous game states for undo functionality
            let draggedPieceElement = null; // Reference to the DOM element being dragged
            let sourceCoords = null; // Coordinates of the piece being dragged/clicked
            let selectedPieceCoords = null; // Coordinates of the piece selected via click/tap
            let focusedCoords = null; // Coordinates of the currently focused cell/piece (for keyboard nav)
            let aiLastMove = { from: null, to: null }; // Stores AI's last move for highlighting
            let isDragging = false; // Flag to track if a drag operation is in progress


            // --- Utility Functions ---
            /**
             * Converts zero-based row and column indices to algebraic notation (e.g., 0,0 -> 'a9').
             * @param {number} row - The row index (0-8).
             * @param {number} col - The column index (0-6).
             * @returns {string|null} The algebraic coordinates (e.g., 'a1', 'g9') or null if invalid.
             */
            function getCoords(row, col) {
                if (row < 0 || row >= ROWS || col < 0 || col >= COLS) return null;
                // Column 'a' is ASCII 97. Row 9 is at index 0.
                return `${String.fromCharCode(97 + col)}${ROWS - row}`;
            }

            /**
             * Converts algebraic notation coordinates to zero-based row and column indices.
             * @param {string} coords - The algebraic coordinates (e.g., 'a1').
             * @returns {{row: number, col: number}|null} An object with row and col indices, or null if invalid.
             */
            function getRowCol(coords) {
                if (!coords || coords.length < 2) return null;
                const col = coords.charCodeAt(0) - 97; // 'a' -> 0, 'b' -> 1, ...
                const rowNum = parseInt(coords.substring(1));
                if (isNaN(rowNum)) return null;
                const row = ROWS - rowNum; // '9' -> 0, '8' -> 1, ...
                if (row < 0 || row >= ROWS || col < 0 || col >= COLS) return null;
                return { row, col };
            }

            /**
             * Retrieves the data object for a piece at the given coordinates from the current game state.
             * @param {string} coords - The algebraic coordinates (e.g., 'a1').
             * @returns {object|null} The piece data object ({player, rank, ...}) or null if the square is empty.
             */
            function getPieceData(coords) {
                return gameState.board[coords] || null;
            }

            /**
             * Generates the DOM ID for a piece element based on its coordinates.
             * @param {string} coords - The coordinates (e.g., 'a1').
             * @returns {string} The DOM ID string (e.g., 'piece-a1').
             */
            function getPieceElementId(coords) {
                return `piece-${coords}`;
            }

            /**
             * Generates the DOM ID for a cell element based on coordinates.
             * @param {string} coords - The coordinates (e.g., 'a1').
             * @returns {string} The DOM ID string (e.g., 'cell-a1').
             */
            function getCellElementId(coords) {
                return `cell-${coords}`;
            }

            /**
             * Gets orthogonal adjacent coordinates for a given square.
             * @param {string} coords - The algebraic coordinates (e.g., 'd9').
             * @returns {string[]} An array of valid adjacent coordinate strings.
             */
            function getAdjacentCoords(coords) {
                const adjacent = [];
                const rc = getRowCol(coords);
                if (!rc) return [];
                const { row, col } = rc;
                const potential = [
                    getCoords(row + 1, col), // Down
                    getCoords(row - 1, col), // Up
                    getCoords(row, col + 1), // Right
                    getCoords(row, col - 1)  // Left
                ];
                potential.forEach(c => {
                    if (c) adjacent.push(c); // Add if valid coords
                });
                return adjacent;
            }

            /**
             * Gets a set of unique adjacent coordinates for a given set of starting coordinates.
             * @param {Set<string>} coordsSet - A Set of algebraic coordinates (e.g., trap squares).
             * @returns {Set<string>} A Set of unique, valid adjacent coordinate strings.
             */
            function getAdjacentCoordsSet(coordsSet) {
                const allAdjacent = new Set();
                if (!coordsSet) return allAdjacent;

                coordsSet.forEach(coord => {
                    const adjacent = getAdjacentCoords(coord); // Use existing helper
                    adjacent.forEach(adjCoord => {
                        if (adjCoord) allAdjacent.add(adjCoord);
                    });
                });
                return allAdjacent;
            }

            /**
             * Checks if a piece at given coordinates is on an opponent's trap square.
             * @param {object} pieceData - The piece data object ({ player, rank, ... }).
             * @param {string} coords - The algebraic coordinates to check.
             * @returns {boolean} True if the piece is on an opponent's trap, false otherwise.
             */
            function isPieceTrapped(pieceData, coords) {
                if (!pieceData || !coords) return false;
                // Orange piece is trapped if on a TRAPS.yellow square
                if (pieceData.player === PLAYERS.ORANGE && TRAPS.yellow.has(coords)) {
                    return true;
                }
                // Yellow piece is trapped if on a TRAPS.orange square
                if (pieceData.player === PLAYERS.YELLOW && TRAPS.orange.has(coords)) {
                    return true;
                }
                // Otherwise, not trapped
                return false;
            }


            // --- Board Creation and Setup ---

            /**
             * Creates the grid of cell elements and appends them to the board wrapper.
             * Assigns IDs, data attributes, classes for terrain, and event listeners.
             */
            function createBoard() {
                boardGridWrapper.innerHTML = ''; // Clear existing board elements
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        const cell = document.createElement('div');
                        const coords = getCoords(r, c);
                        cell.id = getCellElementId(coords);
                        cell.classList.add('cell');
                        cell.dataset.coords = coords; // Store coords for easy access
                        cell.dataset.row = r;
                        cell.dataset.col = c;
                        cell.setAttribute('role', 'gridcell'); // Accessibility
                        cell.setAttribute('tabindex', '-1'); // Make focusable via script/keyboard nav

                        // Add terrain classes based on coordinates
                        if (WATER_SQUARES.has(coords)) cell.classList.add('water');
                        if (TRAPS.orange.has(coords)) cell.classList.add('trap-yellow'); // Trap in Yellow's area
                        if (TRAPS.yellow.has(coords)) cell.classList.add('trap-orange'); // Trap in Orange's area
                        if (DENS.orange === coords) cell.classList.add('den-orange');
                        if (DENS.yellow === coords) cell.classList.add('den-yellow');

                        boardGridWrapper.appendChild(cell);

                        // Add event listeners for drag & drop and clicks
                        cell.addEventListener('dragover', handleDragOver);
                        cell.addEventListener('dragenter', handleDragEnter);
                        cell.addEventListener('dragleave', handleDragLeave);
                        cell.addEventListener('drop', handleDrop);
                        cell.addEventListener('click', handleCellClick);
                        cell.addEventListener('focus', () => focusedCoords = coords); // Track focus for keyboard nav
                    }
                }
            }

            /**
             * Creates a DOM element for a game piece.
             * @param {object} pieceData - The piece data ({ player, rank, ... }).
             * @param {string} coords - The algebraic coordinates where the piece is located.
             * @returns {HTMLElement} The created piece div element.
             */
            function createPieceElement(pieceData, coords) {
                const pieceElement = document.createElement('div');
                pieceElement.id = getPieceElementId(coords);
                pieceElement.classList.add('piece');
                pieceElement.dataset.rank = pieceData.rank;
                pieceElement.dataset.player = pieceData.player;
                pieceElement.dataset.coords = coords;
                pieceElement.setAttribute('role', 'button'); // Treat piece like a button for accessibility
                pieceElement.setAttribute('aria-label', `${pieceData.player} ${RANK_TO_NAME[pieceData.rank]} at ${coords}`);
                pieceElement.setAttribute('tabindex', '-1'); // Make focusable conditionally

                // Find and clone the corresponding image from the hidden asset container
                const pieceKey = `${pieceData.player === PLAYERS.ORANGE ? 'O' : 'Y'}_${pieceData.rank}`;
                const asset = pieceAssetContainer.querySelector(`[data-piece="${pieceKey}"]`);

                if (asset && asset.tagName === 'IMG') {
                    const img = asset.cloneNode(true); // Clone the preloaded image
                    pieceElement.appendChild(img);
                } else {
                    // Fallback if image asset is missing
                    console.warn("Image asset not found for:", pieceKey);
                    pieceElement.textContent = `${pieceData.player === PLAYERS.ORANGE ? 'O' : 'Y'}${pieceData.rank}`; // Display text
                    pieceElement.classList.add(pieceData.player); // Add player color class
                }

                // Add event listeners for interactions
                pieceElement.addEventListener('dragstart', handleDragStart);
                pieceElement.addEventListener('dragend', handleDragEnd);
                pieceElement.addEventListener('touchstart', handleTouchStart, { passive: false }); // Need preventDefault
                pieceElement.addEventListener('touchmove', handleTouchMove, { passive: false }); // Need preventDefault
                pieceElement.addEventListener('touchend', handleTouchEnd);
                pieceElement.addEventListener('click', handlePieceClick);
                pieceElement.addEventListener('mouseover', handlePieceMouseOver); // For hover effects
                pieceElement.addEventListener('mouseout', handlePieceMouseOut);
                pieceElement.addEventListener('focus', () => focusedCoords = coords); // Track focus

                // Allow pieces to be drop targets (for captures)
                pieceElement.addEventListener('drop', handleDrop);
                pieceElement.addEventListener('dragover', handleDragOver);
                pieceElement.addEventListener('dragenter', handleDragEnterPiece);
                pieceElement.addEventListener('dragleave', handleDragLeavePiece);
                // Add the trap indicator span (initially hidden)
                const indicatorSpan = document.createElement('span');
                indicatorSpan.classList.add('trap-rank-indicator'); // Base class for styling
                indicatorSpan.textContent = '(0)'; // The text content
                pieceElement.appendChild(indicatorSpan); // Append it inside the piece div

                return pieceElement;
            }

            /**
             * Clears existing pieces from the board and places new ones based on the current game state.
             */
            function placePieces() {
                clearAILastMoveHighlight(); // Remove highlights from previous AI move
                // Remove all existing piece elements from the board
                boardGridWrapper.querySelectorAll('.piece').forEach(p => p.remove());

                // Iterate through the board state and create/place pieces
                for (const coords in gameState.board) {
                    if (gameState.board.hasOwnProperty(coords)) {
                        const pieceData = gameState.board[coords];
                        if (!pieceData) { // Safety check
                            console.warn(`Attempted to place null piece at ${coords}`);
                            continue;
                        }
                        // Create the piece element
                        const pieceElement = createPieceElement(pieceData, coords);
                        // Position it correctly on the grid
                        positionElementOnBoard(pieceElement, coords);
                        // Add it to the board
                        boardGridWrapper.appendChild(pieceElement);
                        // Apply 'hungry' visual if needed
                        updateHungryVisual(coords, pieceData.isHungry || false);
                        // Set initial accessibility (draggable/focusable)
                        updatePieceAccessibility(pieceElement);
                        // Check and apply trap indicator visual
                        const isTrapped = isPieceTrapped(pieceData, coords);
                        updateTrapIndicatorVisual(coords, isTrapped);
                    }
                }
            }

            /**
             * Calculates and sets the absolute CSS position (left, top percentages) for a piece element
             * within the board grid wrapper, ensuring it's centered within its target cell.
             * Also ensures the piece maintains its aspect ratio.
             * @param {HTMLElement} element - The piece element to position.
             * @param {string} coords - The algebraic coordinates of the target cell.
             */
             function positionElementOnBoard(element, coords) {
                 const rc = getRowCol(coords);
                 if (!rc) {
                     console.error("Cannot position element, invalid coords:", coords);
                     return;
                 }
                 const { row, col } = rc;

                 // Calculate cell dimensions as percentages of the grid wrapper
                 const cellWidthPercent = 100 / COLS; // e.g., 100 / 7 ≈ 14.28%
                 const cellHeightPercent = 100 / ROWS; // e.g., 100 / 9 ≈ 11.11%

                 // Get the piece's width as a percentage of the wrapper (must match CSS)
                 const pieceWidthPercent = parseFloat(element.style.width || '12.07'); // Use CSS value or default

                 // Calculate piece height percentage to maintain 1:1 aspect ratio based on actual pixel dimensions
                 const wrapperWidth = boardGridWrapper.offsetWidth;
                 const wrapperHeight = boardGridWrapper.offsetHeight;
                 let pieceHeightPercent = pieceWidthPercent * (wrapperWidth / wrapperHeight); // Initial calculation based on width %

                 // If wrapper dimensions are available, refine the height percentage calculation
                 if (wrapperHeight > 0 && wrapperWidth > 0) {
                     const pieceWidthPx = wrapperWidth * (pieceWidthPercent / 100);
                     // Calculate the height % needed to make pixel height equal to pixel width
                     pieceHeightPercent = (pieceWidthPx / wrapperHeight) * 100;
                     // Explicitly set height style to ensure consistency if calculated
                     element.style.height = `${pieceHeightPercent}%`;
                 } else {
                    // Fallback if dimensions aren't ready - rely on aspect-ratio CSS
                    element.style.height = 'auto'; // Let CSS aspect-ratio handle height
                 }
                 // Ensure width is set (might have been auto initially)
                 element.style.width = `${pieceWidthPercent}%`;


                 // Calculate the top-left corner of the target cell (relative to the wrapper)
                 const cellLeftPercent = col * cellWidthPercent;
                 const cellTopPercent = row * cellHeightPercent;

                 // Calculate the offset needed to center the piece within the cell
                 const offsetXPercent = (cellWidthPercent - pieceWidthPercent) / 2;
                 const offsetYPercent = (cellHeightPercent - pieceHeightPercent) / 2; // Use the calculated piece height %

                 // Calculate the final top-left position for the piece element
                 const finalLeftPercent = cellLeftPercent + offsetXPercent;
                 const finalTopPercent = cellTopPercent + offsetYPercent;

                 // Apply the calculated position
                 element.style.left = `${finalLeftPercent}%`;
                 element.style.top = `${finalTopPercent}%`;

                 // Reset any transform applied during dragging/animations
                 element.style.transform = '';
                 // Update the element's coordinate data attribute
                 element.dataset.coords = coords;
             }


            /**
             * Updates the tabindex and draggable attributes of a piece element based on the current game state.
             * Pieces are only interactive (focusable, draggable) for the current player during their turn.
             * @param {HTMLElement} pieceElement - The piece element to update.
             */
            function updatePieceAccessibility(pieceElement) {
                if (!pieceElement) return;
                const piecePlayer = pieceElement.dataset.player;
                // Enable interaction if it's this piece's player's turn and game isn't over
                if (piecePlayer === gameState.currentPlayer && !gameState.gameOver) {
                    pieceElement.setAttribute('tabindex', '0'); // Allow focus
                    pieceElement.draggable = true; // Allow dragging
                } else {
                    pieceElement.setAttribute('tabindex', '-1'); // Disallow focus
                    pieceElement.draggable = false; // Disallow dragging
                }
            }

            /**
             * Updates accessibility attributes for all piece elements on the board.
             * Typically called after a turn change or game state load.
             */
            function updateAllPieceAccessibility() {
                boardGridWrapper.querySelectorAll('.piece').forEach(p => updatePieceAccessibility(p));
            }


            // --- Game State Management ---

            /**
             * Creates a deep copy of the current game state and pushes it onto the history stack.
             * Used before making a move to enable undo functionality.
             */
            function saveGameState() {
                // Create a deep copy of the relevant parts of the gameState
                const stateToSave = {
                    board: JSON.parse(JSON.stringify(gameState.board)), // Deep copy board
                    currentPlayer: gameState.currentPlayer,
                    turnNumber: gameState.turnNumber,
                    moveHistory: JSON.parse(JSON.stringify(gameState.moveHistory)), // Deep copy move log
                    boardStateHistory: JSON.parse(JSON.stringify(gameState.boardStateHistory)), // Deep copy repetition counts
                    gameOver: gameState.gameOver,
                    winner: gameState.winner,
                    aiLastMove: JSON.parse(JSON.stringify(aiLastMove)) // Copy AI move highlight info
                };
                gameHistory.push(stateToSave);
                updateUndoButtonState(); // Update button based on history length
                console.log(`Game state saved. History length: ${gameHistory.length}`);
            }

            /**
             * Restores the game state to a previous state from the history.
             * Used by the undo functionality.
             * @param {object} stateToLoad - The game state object retrieved from `gameHistory`.
             */
            function loadGameState(stateToLoad) {
                if (!stateToLoad) return;
                console.log("Loading game state (for Undo)...");

                // Restore state properties
                gameState.board = stateToLoad.board;
                gameState.currentPlayer = stateToLoad.currentPlayer;
                gameState.turnNumber = stateToLoad.turnNumber;
                gameState.moveHistory = stateToLoad.moveHistory;
                gameState.boardStateHistory = stateToLoad.boardStateHistory;
                gameState.gameOver = stateToLoad.gameOver;
                gameState.winner = stateToLoad.winner;
                aiLastMove = stateToLoad.aiLastMove; // Restore AI highlight info

                // Update the UI and board to reflect the loaded state
                placePieces(); // Redraw pieces based on loaded board
                rebuildMoveLog(); // Redraw the move log
                highlightAILastMove(); // Re-apply AI move highlight if applicable
                updateUI(); // Update turn indicator, status, etc.
                logBoardState(true); // Log the restored board state without incrementing count
                updateStatus(gameState.gameOver ? `Game Over: ${gameState.winner} wins!` : `${gameState.currentPlayer.toUpperCase()}'s turn.`);

                // Enable/disable interaction based on game over status
                if (!gameState.gameOver) {
                    enablePlayerInteraction();
                } else {
                    disablePlayerInteraction();
                }

                updateUndoButtonState(); // Update undo button status
                clearHighlights(); // Remove any move highlights
                selectedPieceCoords = null; // Deselect any selected piece
                console.log("Game state loaded (Undo).");
            }

            /**
             * Clears and rebuilds the visual move log based on the `gameState.moveHistory`.
             * Necessary after loading a previous game state.
             */
            function rebuildMoveLog() {
                moveLogElement.innerHTML = ''; // Clear the current log display
                // Add each entry from the history back to the DOM
                gameState.moveHistory.forEach(entry => {
                    addLogEntryToDOM(entry.turn, entry.orange, entry.yellow);
                });
                // Scroll to the bottom of the log
                moveLogElement.scrollTop = moveLogElement.scrollHeight;
            }

            /**
             * Handles the Undo button click. Reverts the game to the previous state(s).
             * If the AI (Yellow) just moved, it undoes both the AI's move and the player's preceding move.
             * If the Player (Orange) just moved, it undoes only the player's move.
             */
            function undoMove() {
                // Prevent undo while AI is processing its turn
                if (gameState.currentPlayer === PLAYERS.YELLOW && boardGridWrapper.style.pointerEvents === 'none') {
                    console.log("Cannot undo while AI is thinking.");
                    updateStatus("Cannot undo while AI is thinking.");
                    return;
                }

                if (gameHistory.length === 0) {
                    console.log("Nothing to undo.");
                    return;
                }

                // --- Determine how many states to undo (Always 1 for this new logic) ---
                const statesToUndo = 1;
                // --- End determination ---


                // Ensure we don't try to undo more states than exist (this check is slightly redundant now but safe)
                if (gameHistory.length < statesToUndo) {
                    console.log(`Cannot undo ${statesToUndo} state, only ${gameHistory.length} available.`);
                    // This should ideally not be reached if the initial length check passed.
                    return; // Exit if somehow history became empty unexpectedly
                }

                console.log(`Undoing last ${statesToUndo} state...`); // Log message updated
                // Pop the required number of states (always 1) from the history
                for (let i = 0; i < statesToUndo; i++) {
                    gameHistory.pop();
                }

                // The state to restore is now the last one remaining in the history (or null if history is empty)
                const stateToRestore = gameHistory.length > 0 ? gameHistory[gameHistory.length - 1] : null;

                if (stateToRestore) {
                    loadGameState(stateToRestore); // Load the restored state
                    updateStatus(`Undo successful. ${gameState.currentPlayer.toUpperCase()}'s turn.`);
                } else {
                    // If history is empty after undo, reset the game
                    console.log("History empty after undo, resetting game.");
                    initializeGame();
                }
                updateUndoButtonState(); // Update button based on new history length
            }

            /**
             * Enables or disables the Undo button based on the game history length and AI thinking state.
             */
            function updateUndoButtonState() {
                // Disable if history is empty OR if it's AI's turn and interaction is disabled
                undoButton.disabled = gameHistory.length === 0 ||
                    (gameState.currentPlayer === PLAYERS.YELLOW && boardGridWrapper.style.pointerEvents === 'none');
            }


            // --- Game Initialization ---

            /**
             * Sets up the initial game state, creates the board, places pieces, and updates the UI.
             * Accepts an optional custom board state object to load from.
             * Called when the page loads, the Reset button is clicked, or Load State is used.
             * @param {object|null} [customBoard=null] - A board object ({ coords: pieceData }) to load instead of INITIAL_SETUP.
             */
            function initializeGame(customBoard = null) { // <-- Added parameter with default null
                console.log("Initializing game..." + (customBoard ? " with custom state." : ""));

                // Reset core game state variables
                gameState = {
                    // Use customBoard if provided and valid, otherwise use INITIAL_SETUP
                    board: customBoard ? customBoard : JSON.parse(JSON.stringify(INITIAL_SETUP)), // <-- Modified this line
                    currentPlayer: PLAYERS.ORANGE, // Always start with Orange after reset/load
                    turnNumber: 1,             // Always reset turn number
                    moveHistory: [],           // Clear move log history
                    boardStateHistory: {},     // Clear board state repetition counts
                    gameOver: false,
                    winner: null
                };
                gameHistory = []; // Clear undo history
                aiLastMove = { from: null, to: null }; // Clear AI move highlight

                // Add special abilities and initial 'hungry' status if NOT using custom board
                // If using customBoard, parseBoardStateString should have already added abilities.
                if (!customBoard) {
                    Object.keys(gameState.board).forEach(coords => {
                        const piece = gameState.board[coords];
                        if (!piece) return;
                        piece.isHungry = false; // No pieces start hungry
                        const abilities = SPECIAL_ABILITIES[piece.rank];
                        if (abilities) {
                            piece.swims = abilities.swims || false;
                            piece.attacksElephant = abilities.attacksElephant || false;
                            piece.jumpH = abilities.jumpH || false;
                            piece.jumpV = abilities.jumpV || false;
                        } else {
                            piece.swims = false; piece.attacksElephant = false;
                            piece.jumpH = false; piece.jumpV = false;
                        }
                    });
                } else {
                     // If loading custom board, ensure all pieces have isHungry set to false initially.
                     // parseBoardStateString already does this, but double-check for safety.
                     Object.values(gameState.board).forEach(piece => {
                         if(piece) piece.isHungry = false;
                     });
                }

                // Set up the visual board
                createBoard(); // Create cell elements
                placePieces(); // Create and position piece elements

                // Reset UI elements
                moveLogElement.innerHTML = ''; // Clear visual move log
                boardStateLogElement.textContent = ''; // Clear board state display
                updateStatus("Game Ready. Orange to move."); // Initial status message
                updateUI(); // Set turn indicator, etc.
                clearHighlights(); // Remove any residual highlights
                logBoardState(); // Log the initial/loaded board state
                enablePlayerInteraction(); // Allow Orange player to move
                updateUndoButtonState(); // Disable undo button initially
                selectedPieceCoords = null; // Ensure no piece is selected

                console.log("Game Initialized. Orange starts.");
            }


            // --- Input Handling (Drag & Drop, Touch, Click, Keyboard) ---

            /**
             * Handles the start of a drag operation on a piece.
             * Sets up data transfer, highlights valid moves, and applies dragging styles.
             * @param {DragEvent} e - The drag event object.
             */
            function handleDragStart(e) {
                const pieceDiv = e.target.closest('.piece');
                // Only allow dragging current player's pieces when game is active
                if (!pieceDiv || pieceDiv.dataset.player !== gameState.currentPlayer || gameState.gameOver) {
                    e.preventDefault(); // Prevent drag if not allowed
                    return;
                }
                isDragging = true;
                draggedPieceElement = pieceDiv; // Store reference to the dragged element
                sourceCoords = draggedPieceElement.dataset.coords; // Store starting position

                // Apply dragging style slightly after drag starts to avoid flicker
                setTimeout(() => {
                    if (draggedPieceElement) draggedPieceElement.classList.add('dragging');
                 }, 0);

                e.dataTransfer.effectAllowed = 'move'; // Indicate a move operation
                e.dataTransfer.setData('text/plain', sourceCoords); // Store source coords for drop handler

                highlightValidMoves(sourceCoords); // Show potential destinations
                draggedPieceElement.classList.add('selected'); // Visually mark the dragged piece
                selectedPieceCoords = sourceCoords; // Track selection
                console.log(`Drag Start: ${sourceCoords}`);
            }

            /**
             * Handles the end of a drag operation (whether successful drop or cancelled).
             * Cleans up dragging styles and resets related state variables.
             * @param {DragEvent} e - The drag event object.
             */
            function handleDragEnd(e) {
                isDragging = false;
                if (draggedPieceElement) {
                    // Remove visual styles associated with dragging/selection
                    draggedPieceElement.classList.remove('dragging', 'selected');
                }
                // Reset drag-related variables
                draggedPieceElement = null;
                sourceCoords = null;
                clearHighlights(); // Remove valid move highlights
                // Note: selectedPieceCoords is reset in handleDrop or if move fails
                console.log("Drag End");
            }

            /**
             * Handles the drag over event on potential drop targets (cells, pieces).
             * Prevents the default behavior to allow dropping.
             * @param {DragEvent} e - The drag event object.
             */
            function handleDragOver(e) {
                e.preventDefault(); // Necessary to allow dropping
                e.dataTransfer.dropEffect = 'move'; // Indicate that a move is possible
            }

            /**
             * Helper function to apply hover styling during drag based on the target element.
             * Adds 'valid-move' or 'valid-attack' class to the underlying cell if it's a valid target.
             * @param {HTMLElement} targetElement - The element being dragged over (cell or piece).
             */
            function handleDragEnterAny(targetElement) {
                if (!targetElement || !isDragging) return; // Only act if dragging
                const targetCoords = getCoordsFromElement(targetElement);
                const cellElement = targetCoords ? document.getElementById(getCellElementId(targetCoords)) : null;

                // Check if the underlying cell was highlighted as a potential move/attack
                if (cellElement && cellElement.classList.contains('valid-move-highlight')) {
                    // Apply the appropriate hover style based on whether it's an attack or move square
                    if (cellElement.classList.contains('valid-attack-highlight')) {
                        cellElement.classList.add('valid-attack'); // Red highlight
                    } else {
                        cellElement.classList.add('valid-move'); // Green highlight
                    }
                }
            }

            /**
             * Helper function to remove hover styling when the dragged piece leaves an element.
             * @param {HTMLElement} targetElement - The element being left.
             */
            function handleDragLeaveAny(targetElement) {
                if (!targetElement) return;
                const targetCoords = getCoordsFromElement(targetElement);
                const cellElement = targetCoords ? document.getElementById(getCellElementId(targetCoords)) : null;
                // Remove the temporary hover styles
                if (cellElement) {
                    cellElement.classList.remove('valid-move', 'valid-attack');
                }
            }

            /**
             * Handles drag enter event specifically for cell elements.
             * @param {DragEvent} e - The drag event object.
             */
            function handleDragEnter(e) {
                e.preventDefault();
                const targetCell = e.target.closest('.cell');
                handleDragEnterAny(targetCell); // Use helper for styling
            }

            /**
             * Handles drag leave event specifically for cell elements.
             * @param {DragEvent} e - The drag event object.
             */
            function handleDragLeave(e) {
                const targetCell = e.target.closest('.cell');
                handleDragLeaveAny(targetCell); // Use helper for styling
            }

            /**
             * Handles drag enter event specifically for piece elements (potential capture targets).
             * @param {DragEvent} e - The drag event object.
             */
            function handleDragEnterPiece(e) {
                e.preventDefault();
                e.stopPropagation(); // Prevent event bubbling to the underlying cell
                const targetPiece = e.target.closest('.piece');
                handleDragEnterAny(targetPiece); // Use helper for styling
            }

            /**
             * Handles drag leave event specifically for piece elements.
             * @param {DragEvent} e - The drag event object.
             */
            function handleDragLeavePiece(e) {
                const targetPiece = e.target.closest('.piece');
                handleDragLeaveAny(targetPiece); // Use helper for styling
            }

            /**
             * Utility function to extract coordinates from a DOM element (cell or piece).
             * @param {HTMLElement} element - The DOM element.
             * @returns {string|null} The algebraic coordinates or null if not found.
             */
            function getCoordsFromElement(element) {
                if (!element) return null;
                // Check if the element itself is a piece or cell
                if (element.classList.contains('piece') || element.classList.contains('cell')) {
                    return element.dataset.coords;
                }
                // Check if the element is inside a piece or cell
                const piece = element.closest('.piece');
                if (piece) return piece.dataset.coords;
                const cell = element.closest('.cell');
                if (cell) return cell.dataset.coords;
                return null; // Coordinates not found
            }

            /**
             * Handles the drop event when a piece is released over a target.
             * Validates the move and calls performMove if valid.
             * @param {DragEvent} e - The drop event object.
             */
            function handleDrop(e) {
                e.preventDefault();
                if (!draggedPieceElement) { // Should not happen if dragstart fired correctly
                    clearHighlights();
                    isDragging = false;
                    return;
                }

                const targetElement = e.target; // The element directly under the cursor on drop
                let targetCoords = null;
                let targetCell = null;

                // Determine the target coordinates based on what was dropped onto
                const droppedOnPiece = targetElement.closest('.piece');
                // Case 1: Dropped onto another piece (potential capture)
                if (droppedOnPiece && droppedOnPiece !== draggedPieceElement && droppedOnPiece.dataset.player !== gameState.currentPlayer) {
                    targetCoords = droppedOnPiece.dataset.coords;
                    targetCell = document.getElementById(getCellElementId(targetCoords));
                }
                // Case 2: Dropped onto a cell
                else {
                    targetCell = targetElement.closest('.cell');
                    if (targetCell) {
                        targetCoords = targetCell.dataset.coords;
                    }
                    // Case 3: Dropped back onto the original piece (treat as drop on original cell)
                    else if (targetElement === draggedPieceElement) {
                        targetCoords = draggedPieceElement.dataset.coords;
                        targetCell = document.getElementById(getCellElementId(targetCoords));
                    }
                }

                // Retrieve the source coordinates (stored during dragstart)
                const dragSourceCoords = draggedPieceElement.dataset.coords || sourceCoords || e.dataTransfer.getData('text/plain');
                clearHighlights(); // Clean up highlights immediately after drop

                // Check if drop target is valid
                if (!targetCell || !targetCoords) {
                    console.log("Drop outside valid target.");
                    updateStatus("Invalid drop location.");
                    selectedPieceCoords = null; // Deselect if drop is invalid
                    isDragging = false;
                    // Snap piece back to original position if drop is invalid
                    if(draggedPieceElement && dragSourceCoords) positionElementOnBoard(draggedPieceElement, dragSourceCoords);
                    return;
                }

                // Validate the move using game logic
                const validationResult = isValidMove(dragSourceCoords, targetCoords, getPieceData(dragSourceCoords));

                if (!validationResult.valid) {
                    // If move is invalid, log reason, update status, and snap piece back
                    console.log(`Drop on invalid target: ${targetCoords}. Reason: ${validationResult.reason}`);
                    updateStatus(`Invalid move: ${validationResult.reason}`);
                    selectedPieceCoords = null; // Deselect
                    if(draggedPieceElement && dragSourceCoords) positionElementOnBoard(draggedPieceElement, dragSourceCoords);
                } else {
                    // If move is valid, perform the move
                    console.log(`Performing move via drop from ${dragSourceCoords} to ${targetCoords}`);
                    performMove(dragSourceCoords, targetCoords);
                    selectedPieceCoords = null; // Deselect after successful move
                }
                isDragging = false; // Reset dragging flag
            }


            // --- Touch Handlers ---
            let touchStartX, touchStartY; // Store initial touch coordinates

            /**
             * Handles the start of a touch interaction on a piece.
             * Initiates potential drag, stores start position, highlights moves.
             * @param {TouchEvent} e - The touch event object.
             */
            function handleTouchStart(e) {
                if (gameState.gameOver) return; // Ignore touches if game is over
                const pieceElement = e.target.closest('.piece');
                // Only handle touches on the current player's pieces
                if (!pieceElement || pieceElement.dataset.player !== gameState.currentPlayer) return;

                e.preventDefault(); // Prevent default touch behavior like scrolling
                draggedPieceElement = pieceElement; // Reference the touched piece
                sourceCoords = draggedPieceElement.dataset.coords; // Store start position
                selectedPieceCoords = sourceCoords; // Select the piece

                // Store initial touch coordinates for calculating movement delta
                const touch = e.changedTouches[0];
                touchStartX = touch.clientX;
                touchStartY = touch.clientY;

                isDragging = false; // Not dragging yet, could be a tap
                // Temporarily disable smooth transition for direct manipulation
                draggedPieceElement.style.transition = 'none';
                draggedPieceElement.style.zIndex = '100'; // Bring to front

                highlightValidMoves(sourceCoords); // Show valid moves
                draggedPieceElement.classList.add('selected'); // Mark as selected
                console.log(`Touch Start: ${sourceCoords}`);
            }

            /**
             * Handles touch movement while holding a piece.
             * Updates the piece's position visually and detects if it's a drag vs. tap.
             * @param {TouchEvent} e - The touch event object.
             */
            function handleTouchMove(e) {
                if (!draggedPieceElement || !sourceCoords) return; // Only if a piece touch is active
                e.preventDefault(); // Prevent scrolling during piece drag

                const touch = e.changedTouches[0];
                const deltaX = touch.clientX - touchStartX; // Horizontal movement
                const deltaY = touch.clientY - touchStartY; // Vertical movement

                // Define a threshold to distinguish between a tap and a drag
                const touchDragThreshold = 10; // Pixels

                // If not already dragging, check if threshold is exceeded
                if (!isDragging && (Math.abs(deltaX) > touchDragThreshold || Math.abs(deltaY) > touchDragThreshold)) {
                    isDragging = true; // It's now officially a drag
                    draggedPieceElement.classList.add('dragging'); // Apply dragging style
                    console.log("Touch drag initiated");
                }

                // If dragging, update the element's visual position using transform
                if (isDragging) {
                    // Get the element currently under the touch point
                    const elementUnderTouch = document.elementFromPoint(touch.clientX, touch.clientY);

                    // Preserve scaling if already applied (e.g., dragging style)
                    const currentTransform = draggedPieceElement.style.transform.match(/scale\(([^)]+)\)/);
                    const currentScale = currentTransform ? parseFloat(currentTransform[1]) : 1;
                    // Apply translation based on touch movement and maintain scale
                    draggedPieceElement.style.transform = `translate(${deltaX}px, ${deltaY}px) scale(${currentScale})`;

                    // Update cell highlighting based on where the finger is hovering
                    // First, remove hover highlights from all cells
                    document.querySelectorAll('.cell.valid-move, .cell.valid-attack').forEach(c => c.classList.remove('valid-move', 'valid-attack'));
                    // Then, find the cell under the touch
                    const targetCoords = getCoordsFromElement(elementUnderTouch);
                    const cellUnderTouch = targetCoords ? document.getElementById(getCellElementId(targetCoords)) : null;
                    // If over a valid move cell, apply the appropriate hover highlight
                    if (cellUnderTouch && cellUnderTouch.classList.contains('valid-move-highlight')) {
                        if (cellUnderTouch.classList.contains('valid-attack-highlight')) {
                            cellUnderTouch.classList.add('valid-attack'); // Red highlight
                        } else {
                            cellUnderTouch.classList.add('valid-move'); // Green highlight
                        }
                    }
                }
            }

            /**
             * Handles the end of a touch interaction (lifting the finger).
             * Determines if it was a tap (treated like click) or a drag (treated like drop).
             * @param {TouchEvent} e - The touch event object.
             */
            function handleTouchEnd(e) {
                if (!draggedPieceElement || !sourceCoords) return; // Only if a piece touch was active
                e.preventDefault();

                const wasDragging = isDragging; // Store whether a drag occurred
                isDragging = false; // Reset dragging flag
                draggedPieceElement.classList.remove('dragging'); // Remove dragging style
                draggedPieceElement.style.zIndex = '10'; // Restore default z-index
                draggedPieceElement.style.transform = ''; // Reset translation

                // Restore smooth CSS transition after a short delay
                setTimeout(() => {
                    if (draggedPieceElement) {
                        draggedPieceElement.style.transition = 'transform 0.3s ease-in-out, box-shadow 0.2s ease, outline 0.2s ease, left 0.3s ease-in-out, top 0.3s ease-in-out';
                    }
                 }, 0);

                 // If it wasn't a drag, treat it as a tap/click (handled by handlePieceClick)
                 if (!wasDragging) {
                     console.log("TouchEnd: Detected as tap/click. Handled by click listener.");
                     // Let the click handler manage selection/deselection
                     // Resetting here might interfere with the click handler logic
                     // We still need to nullify draggedPieceElement and sourceCoords eventually
                     // to prevent issues if another touch starts immediately.
                     // Consider if handlePieceClick should nullify these.
                      draggedPieceElement = null;
                      sourceCoords = null;
                     return;
                 }

                // If it was a drag, determine the drop target
                const touch = e.changedTouches[0];
                // Find element at the touch release point
                const elementUnderTouch = document.elementFromPoint(touch.clientX, touch.clientY);
                let targetCoords = null;
                let targetCell = null;

                // Determine target similar to handleDrop
                const droppedOnPiece = elementUnderTouch?.closest('.piece');
                if (droppedOnPiece && droppedOnPiece !== draggedPieceElement && droppedOnPiece.dataset.player !== gameState.currentPlayer) {
                    targetCoords = droppedOnPiece.dataset.coords;
                    targetCell = document.getElementById(getCellElementId(targetCoords));
                } else {
                    targetCell = elementUnderTouch?.closest('.cell');
                    if (targetCell) {
                        targetCoords = targetCell.dataset.coords;
                    }
                }

                clearHighlights(); // Remove move highlights

                // If a valid target cell was found
                if (targetCell && targetCoords) {
                    const validationResult = isValidMove(sourceCoords, targetCoords, getPieceData(sourceCoords));
                    if (validationResult.valid) {
                        // Perform move if valid
                        console.log(`Performing move via touch from ${sourceCoords} to ${targetCoords}`);
                        performMove(sourceCoords, targetCoords);
                        selectedPieceCoords = null; // Deselect after move
                    } else {
                        // If invalid, snap piece back
                        console.log("Touch end on invalid target:", validationResult.reason);
                        updateStatus(`Invalid move: ${validationResult.reason}`);
                        positionElementOnBoard(draggedPieceElement, sourceCoords);
                        selectedPieceCoords = null; // Deselect
                    }
                } else {
                    // If dropped outside a valid target, snap piece back
                    console.log("Touch end outside valid target");
                    positionElementOnBoard(draggedPieceElement, sourceCoords);
                    selectedPieceCoords = null; // Deselect
                }

                // Clean up touch state variables
                draggedPieceElement = null;
                sourceCoords = null;
                console.log("Touch End (Drag)");
            }


            // --- Click Handlers ---

            /**
             * Handles clicking on a piece. Selects/deselects the piece and highlights valid moves.
             * Ignored if a drag operation is currently happening.
             * @param {MouseEvent} e - The click event object.
             */
            function handlePieceClick(e) {
                // Ignore clicks that might happen at the end of a drag/touch interaction
                if (isDragging) {
                    console.log("Piece click ignored during drag.");
                    return;
                }
                const pieceElement = e.target.closest('.piece');
                if (!pieceElement || gameState.gameOver) return; // Ignore if game over or not a piece

                const coords = pieceElement.dataset.coords;
                const pieceData = getPieceData(coords);

                // Handle clicks on opponent's pieces OR empty space where piece was (edge case)
                if (!pieceData || pieceData.player !== gameState.currentPlayer) {
                    // --- MODIFIED ---
                    // If a friendly piece IS selected, clicking an opponent piece might be
                    // an attempt to capture. Let the handleCellClick deal with it.
                    // Only clear selection/highlights if NO friendly piece is currently selected.
                    if (!selectedPieceCoords) {
                        clearHighlights();
                        // deselectPiece() implicitly called by clearHighlights if needed,
                        // but calling it explicitly when selectedPieceCoords is null is safe.
                        deselectPiece();
                    }
                    // If selectedPieceCoords IS set, do nothing here. The event will bubble
                    // to the cell, and handleCellClick will check if it's a valid move/capture.
                    return;
                    // --- END MODIFICATION ---
                }

                // --- If clicking on a friendly piece ---

                // If clicking the already selected piece, deselect it
                if (selectedPieceCoords === coords) {
                    deselectPiece(); // Also clears highlights
                }
                // Otherwise, select the clicked piece
                else {
                    selectPiece(coords); // Selects and highlights moves
                }
                console.log(`Piece Click: ${coords}, Selected: ${selectedPieceCoords}`);
            }

            /**
             * Handles clicking on a cell. If a piece is selected, attempts to move it to the clicked cell.
             * Ignored if a drag operation is currently happening or no piece is selected.
             * @param {MouseEvent} e - The click event object.
             */
            function handleCellClick(e) {
                 // Ignore clicks that might happen at the end of a drag/touch interaction
                if (isDragging) {
                    console.log("Cell click ignored during drag.");
                    return;
                }
                const targetCell = e.target.closest('.cell');
                // Ignore if game over, no cell clicked, or no piece selected
                if (!targetCell || gameState.gameOver || !selectedPieceCoords) return;

                const targetCoords = targetCell.dataset.coords;
                const pieceToMove = getPieceData(selectedPieceCoords);

                // Safety check: Should have a piece selected if selectedPieceCoords is set
                if (!pieceToMove) {
                    console.warn("Cell clicked but selected piece data not found for:", selectedPieceCoords);
                    deselectPiece(); // Clean up selection state
                    clearHighlights();
                    return;
                }

                // Validate the move from the selected piece to the clicked cell
                const validationResult = isValidMove(selectedPieceCoords, targetCoords, pieceToMove);

                if (validationResult.valid) {
                    // Perform the move if valid
                    console.log(`Performing move via click from ${selectedPieceCoords} to ${targetCoords}`);
                    performMove(selectedPieceCoords, targetCoords);
                    // performMove handles deselecting
                } else {
                    // If invalid, provide feedback (flash cell red) and update status
                    console.log(`Invalid click move to ${targetCoords}: ${validationResult.reason}`);
                    flashCell(targetCoords, 'red', 300); // Visual feedback for invalid click
                    updateStatus(`Invalid move: ${validationResult.reason}`);
                    // Do not deselect here - allow player to try clicking another valid cell
                }
            }

            /**
             * Handles mouse entering a piece element. Shows potential moves if it's the player's piece
             * and no other piece is currently selected or being dragged. (Hover effect)
             * @param {MouseEvent} e - The mouse event object.
             */
            function handlePieceMouseOver(e) {
                const pieceElement = e.target.closest('.piece');
                // Ignore if game over, another piece is selected, dragging, or not a piece
                if (!pieceElement || gameState.gameOver || selectedPieceCoords || isDragging) return;

                const coords = pieceElement.dataset.coords;
                const pieceData = getPieceData(coords);

                // Only highlight moves on hover for the current player's pieces
                if (pieceData && pieceData.player === gameState.currentPlayer) {
                    // Highlight moves but don't mark the piece as 'selected' (isSelection = false)
                    highlightValidMoves(coords, false);
                }
            }

            /**
             * Handles mouse leaving a piece element. Clears temporary hover highlights
             * if no piece is actively selected or being dragged.
             * @param {MouseEvent} e - The mouse event object.
             */
            function handlePieceMouseOut(e) {
                // If no piece is selected and not dragging, clear any highlights shown on hover
                if (!selectedPieceCoords && !isDragging) {
                    clearHighlights();
                }
            }


            // --- Keyboard Handlers ---

            /**
             * Handles keyboard navigation (arrow keys) and actions (Enter/Space, Escape)
             * for moving focus, selecting/deselecting pieces, and making moves.
             * @param {KeyboardEvent} e - The keyboard event object.
             */
            function handleKeyDown(e) {
                // Ignore keyboard input if game is over or it's AI's turn
                if (gameState.gameOver || (gameState.currentPlayer === PLAYERS.YELLOW)) return;

                const { key } = e;
                let newRow, newCol, targetCoords, currentElement;

                // If no element currently has focus, set initial focus
                if (!focusedCoords) {
                    // Try focusing the first available piece of the current player
                    const firstPiece = boardGridWrapper.querySelector(`.piece[data-player="${gameState.currentPlayer}"][tabindex="0"]`);
                    if (firstPiece) {
                        focusedCoords = firstPiece.dataset.coords;
                        firstPiece.focus();
                    } else {
                        // Fallback: focus the board container itself or a central cell
                        boardElement.focus();
                        focusedCoords = getCoords(Math.floor(ROWS/2), Math.floor(COLS/2)) || 'd5'; // Focus center-ish
                        focusOn(focusedCoords);
                    }
                    if (!focusedCoords) return; // Still no focus target, exit
                }

                const currentRC = getRowCol(focusedCoords);
                // Safety check for valid focused coordinates
                if (!currentRC) {
                    console.warn("Keyboard nav: Invalid focusedCoords", focusedCoords);
                     // Attempt to refocus on the first piece if current focus is lost/invalid
                    const firstPiece = boardGridWrapper.querySelector(`.piece[data-player="${gameState.currentPlayer}"][tabindex="0"]`);
                    if (firstPiece) {
                        focusedCoords = firstPiece.dataset.coords;
                        firstPiece.focus();
                    }
                    return;
                }

                // Handle Arrow Key navigation
                switch (key) {
                    case 'ArrowUp':
                        newRow = currentRC.row - 1; newCol = currentRC.col;
                        break;
                    case 'ArrowDown':
                        newRow = currentRC.row + 1; newCol = currentRC.col;
                        break;
                    case 'ArrowLeft':
                        newRow = currentRC.row; newCol = currentRC.col - 1;
                        break;
                    case 'ArrowRight':
                        newRow = currentRC.row; newCol = currentRC.col + 1;
                        break;
                    // Handle Action Keys (Enter/Space)
                    case 'Enter':
                    case ' ': // Treat spacebar like Enter
                        e.preventDefault(); // Prevent default spacebar scroll/button activation
                        currentElement = document.getElementById(getPieceElementId(focusedCoords)) || document.getElementById(getCellElementId(focusedCoords));

                        // Action 1: Focused on own piece -> Select/Deselect
                        if (currentElement?.classList.contains('piece')) {
                            const pieceData = getPieceData(focusedCoords);
                            if (pieceData?.player === gameState.currentPlayer) {
                                if (selectedPieceCoords === focusedCoords) {
                                    deselectPiece(); // If already selected, deselect
                                } else {
                                    selectPiece(focusedCoords); // Otherwise, select
                                }
                            }
                        }
                        // Action 2: Focused on a cell AND a piece is selected -> Attempt move
                        else if (currentElement?.classList.contains('cell') && selectedPieceCoords) {
                            const pieceToMove = getPieceData(selectedPieceCoords);
                            if (pieceToMove) {
                                const validationResult = isValidMove(selectedPieceCoords, focusedCoords, pieceToMove);
                                if (validationResult.valid) {
                                    console.log(`Performing move via keyboard from ${selectedPieceCoords} to ${focusedCoords}`);
                                    performMove(selectedPieceCoords, focusedCoords);
                                } else {
                                    // Invalid move: Flash cell red, update status
                                    flashCell(focusedCoords, 'red', 300);
                                    updateStatus(`Invalid move: ${validationResult.reason}`);
                                }
                            }
                        }
                        return; // End processing after action key

                    // Handle Escape Key
                    case 'Escape':
                        e.preventDefault();
                        // If a piece is selected, deselect it
                        if (selectedPieceCoords) {
                            deselectPiece();
                            clearHighlights(); // Ensure highlights are cleared
                        }
                        return; // End processing after Escape

                    default:
                        return; // Ignore other keys
                }

                // If an arrow key was pressed, calculate the target coordinates
                targetCoords = getCoords(newRow, newCol);
                if (targetCoords) {
                    e.preventDefault(); // Prevent default arrow key scrolling
                    focusOn(targetCoords); // Move focus to the new cell/piece
                }
            }

            /**
             * Programmatically sets focus on a specific cell or piece element.
             * @param {string} coords - The algebraic coordinates of the target element.
             */
            function focusOn(coords) {
                if (!coords) return;
                // Find the target element (piece first, then cell)
                let targetElement = document.getElementById(getPieceElementId(coords)) || document.getElementById(getCellElementId(coords));
                if (targetElement) {
                    targetElement.focus(); // Set browser focus
                    // focusedCoords is updated by the 'focus' event listener on cells/pieces
                }
            }


            // --- Selection and Interaction State ---

            /**
             * Selects a piece at the given coordinates.
             * Updates the selectedPieceCoords state, applies visual selection style,
             * highlights valid moves, and sets focus.
             * @param {string} coords - The algebraic coordinates of the piece to select.
             */
            function selectPiece(coords) {
                deselectPiece(); // Ensure only one piece is selected at a time
                const pieceElement = document.getElementById(getPieceElementId(coords));
                // Only select if it's the current player's piece
                if (pieceElement?.dataset.player === gameState.currentPlayer) {
                    selectedPieceCoords = coords; // Update state
                    pieceElement.classList.add('selected'); // Apply visual style
                    highlightValidMoves(coords); // Show valid moves for this piece
                    focusOn(coords); // Move focus to the selected piece
                    console.log(`Selected piece at ${coords}`);
                }
            }

            /**
             * Deselects the currently selected piece.
             * Clears the selectedPieceCoords state, removes visual selection style,
             * and clears move highlights.
             */
            function deselectPiece() {
                if (selectedPieceCoords) {
                    const pieceElement = document.getElementById(getPieceElementId(selectedPieceCoords));
                    if (pieceElement) {
                        pieceElement.classList.remove('selected'); // Remove visual style
                    }
                    console.log(`Deselected piece at ${selectedPieceCoords}`);
                    selectedPieceCoords = null; // Clear state
                    clearHighlights(); // Remove move highlights
                }
            }

            /**
             * Enables user interaction with the board (dragging, clicking, keyboard).
             * Sets pointer-events, adds keydown listener, and updates piece accessibility.
             */
            function enablePlayerInteraction() {
                boardGridWrapper.style.pointerEvents = 'auto'; // Allow clicks/drags on the grid
                document.addEventListener('keydown', handleKeyDown); // Enable keyboard controls
                updateAllPieceAccessibility(); // Make current player's pieces draggable/focusable
                console.log("Player interaction enabled.");
            }

            /**
             * Disables user interaction with the board.
             * Used during AI's turn or when the game is over.
             */
            function disablePlayerInteraction() {
                boardGridWrapper.style.pointerEvents = 'none'; // Prevent clicks/drags on the grid
                document.removeEventListener('keydown', handleKeyDown); // Disable keyboard controls
                updateAllPieceAccessibility(); // Make all pieces non-interactive
                console.log("Player interaction disabled.");
            }


            // --- Move Logic & Validation ---

            /**
             * Executes a validated move, updating the game state, moving the piece element,
             * handling captures, checking for win/loss conditions, managing hungry/starve rules,
             * logging the move, checking for repetition/stalemate, switching the player,
             * and potentially triggering the AI.
             * @param {string} fromCoords - The starting coordinates of the move.
             * @param {string} toCoords - The ending coordinates of the move.
             */
            function performMove(fromCoords, toCoords) {
                const piece = getPieceData(fromCoords);

                // --- Pre-move validation and setup ---
                // Basic checks: piece exists, belongs to current player, game not over
                if (!piece || piece.player !== gameState.currentPlayer || gameState.gameOver) {
                    console.error("Invalid move attempt condition in performMove.");
                    updateStatus("Cannot move now.");
                    return;
                }

                // Double-check move validity (should already be validated by caller, but good safety)
                const validationResult = isValidMove(fromCoords, toCoords, piece);
                if (!validationResult.valid) {
                    console.log(`Invalid move attempt in performMove: ${validationResult.reason}`);
                    updateStatus(`Invalid move: ${validationResult.reason}`);
                    flashCell(toCoords, 'red'); // Indicate invalid target
                    // Do NOT proceed with the move
                    // Consider deselecting here or letting the user try again
                    // deselectPiece(); // Optional: force deselect on invalid performMove call
                    return;
                }

                // Save the state BEFORE making changes, for undo
                saveGameState();

                // Clear visual feedback from previous interactions
                clearHighlights();
                clearAILastMoveHighlight();
                deselectPiece(); // Ensure no piece remains visually selected

                // --- Execute the move ---
                const targetPiece = getPieceData(toCoords); // Check if destination is occupied
                const isAttack = !!targetPiece; // Boolean flag for capture
                const playerWhoMoved = gameState.currentPlayer; // Store who made this move
                let notation = `${RANK_TO_CODE[piece.rank]}`; // Start building move notation (e.g., "8")
                let statusAction = ""; // String to append to status message (e.g., " captures Lion at g7")

                // --- Handle Starvation BEFORE the move ---
                // Check if any of the current player's hungry pieces *failed* to make a capturing move
                const starvedPiecesCoords = checkAndApplyStarvation(fromCoords, isAttack);

                // --- Handle Capture (if applicable) ---
                if (isAttack) {
                    console.log(`${piece.player} ${RANK_TO_NAME[piece.rank]} at ${fromCoords} captures ${targetPiece.player} ${RANK_TO_NAME[targetPiece.rank]} at ${toCoords}`);
                    notation += 'x'; // Add 'x' to notation for capture
                    statusAction = ` captures ${RANK_TO_NAME[targetPiece.rank]} at ${toCoords}`;
                    // Animate and remove the captured piece's DOM element
                    const capturedElement = document.getElementById(getPieceElementId(toCoords));
                    if (capturedElement) {
                        capturedElement.classList.add('captured'); // Trigger capture animation
                        setTimeout(() => { capturedElement.remove(); }, 400); // Remove after animation
                    }
                    // Remove captured piece from board state (done implicitly below by overwriting)
                }

                // --- Update Game State Board ---
                gameState.board[toCoords] = piece; // Move piece data to the new location
                delete gameState.board[fromCoords]; // Remove piece data from the old location

                // --- Update Piece DOM Element ---
                const pieceElement = document.getElementById(getPieceElementId(fromCoords));
                if (pieceElement) {
                    // Update the element's ID and position data
                    pieceElement.id = getPieceElementId(toCoords);
                    pieceElement.setAttribute('aria-label', `${piece.player} ${RANK_TO_NAME[piece.rank]} at ${toCoords}`);
                    // Visually move the piece on the board
                    positionElementOnBoard(pieceElement, toCoords);
                    // Update its accessibility (it might become non-interactive if turn changes)
                    updatePieceAccessibility(pieceElement); // Important AFTER position update

                    // --- IMMEDIATELY Update Attacker's Hungry Status After Capture ---
                    if (isAttack) {
                        // Update the game state for the piece that just attacked
                        // 'piece' variable still holds the reference to the moved piece data
                        piece.isHungry = false; // The piece is no longer hungry after capturing
                        // Update the visual marker immediately at its new location
                        updateHungryVisual(toCoords, false);
                        console.log(`Attacker ${RANK_TO_NAME[piece.rank]}@${toCoords} is no longer hungry after capture.`);
                    }
                    // --- End Immediate Update ---
                    // --- Update Trap Indicator for Moved Piece ---
                    // Check the piece's status at its NEW location
                    const movedPieceData = gameState.board[toCoords]; // Get data from the destination
                    if (movedPieceData) { // Check piece still exists (wasn't captured/starved in the interim)
                        const isNowTrapped = isPieceTrapped(movedPieceData, toCoords);
                        updateTrapIndicatorVisual(toCoords, isNowTrapped);
                    }
                    // Note: If a piece moved *off* a trap, the indicator is removed here.
                    // If a piece was captured *on* a trap, its element is removed, so no update needed.
                    // --- End Trap Indicator Update ---

                    } else {
                        // Fallback if element somehow missing - redraw all pieces
                        console.error(`!!! Piece element not found at ${fromCoords}! Could not update DOM element. Re-placing all pieces.`);
                        placePieces(); // Less efficient, but ensures consistency
                    }

                // Complete move notation (e.g., "8xg7")
                notation += toCoords;

                // --- Check Win Conditions ---
                // 1. Reaching opponent's den
                const opponentDen = playerWhoMoved === PLAYERS.ORANGE ? DENS.yellow : DENS.orange;
                if (toCoords === opponentDen) {
                    gameState.winner = playerWhoMoved;
                    gameState.gameOver = true;
                    updateStatus(`${playerWhoMoved.toUpperCase()} wins by reaching the den!${statusAction}`); // Append capture info if any
                    logMove(notation, playerWhoMoved);
                    logBoardState();
                    updateUI();
                    disablePlayerInteraction();
                    updateUndoButtonState();
                    return; // Game over
                }

                // 2. Eliminating all opponent pieces
                const opponent = playerWhoMoved === PLAYERS.ORANGE ? PLAYERS.YELLOW : PLAYERS.ORANGE;
                let opponentPieceCount = 0;
                for (const coords in gameState.board) {
                    if (gameState.board[coords]?.player === opponent) {
                        opponentPieceCount++;
                    }
                }
                if (opponentPieceCount === 0) {
                    gameState.winner = playerWhoMoved;
                    gameState.gameOver = true;
                    updateStatus(`${playerWhoMoved.toUpperCase()} wins by eliminating all opponent pieces!${statusAction}`);
                    logMove(notation, playerWhoMoved);
                    logBoardState();
                    updateUI();
                    disablePlayerInteraction();
                    updateUndoButtonState();
                    return; // Game over
                }

                // --- Declare Hungry Animals for the *Next* Player ---
                // Determine which of the opponent's pieces can now attack
                const { hungryCount, hungryPiecesMap } = declareHungryAnimals(opponent);
                // Update the isHungry status in the board state and apply visual cues
                Object.keys(gameState.board).forEach(coords => {
                    const p = gameState.board[coords];
                    if (p) {
                        p.isHungry = !!hungryPiecesMap[coords]; // Update state
                        updateHungryVisual(coords, p.isHungry); // Update DOM
                    }
                });
                // Add '+' to notation for each hungry animal declared
                if (hungryCount > 0) {
                    notation += '+'.repeat(hungryCount); // e.g., "8xg7++" if 2 animals became hungry
                }

                let starvationOccurred = starvedPiecesCoords.length > 0;

                // Add starvation info to the status message BEFORE modifying notation for 's' rule
                if (starvationOccurred) {
                    statusAction += ` (${starvedPiecesCoords.length} animal${starvedPiecesCoords.length > 1 ? 's' : ''} starved)`;
                }

                // Tentatively add 's' if starvation occurred (to check if it happened)
                // We will correct this right after according to the Clesto rule.
                if (starvationOccurred) {
                    notation += 's'; // Add a single 's' marker temporarily if *any* starvation happened
                }

                // --- Apply Clesto Notation Rule: ending 's' becomes 'x' ---
                if (notation.endsWith('s')) { // Check if starvation marker was added
                    // Remove the trailing 's'
                    notation = notation.slice(0, -1);
                    // Ensure the notation ends with 'x' if it doesn't already (e.g., from a normal capture)
                    if (!notation.endsWith('x')) {
                        notation += 'x';
                    }
                    console.log(`Applying Clesto rule: Starvation occurred, notation corrected to end with 'x': ${notation}`);
                }
                // --- End Clesto Notation Rule ---


                // --- Log the Move & Board State ---
                logMove(notation, playerWhoMoved); // Add move to visual log and history using the CORRECTED notation
                const boardStateString = logBoardState(); // Log state for repetition check

                // --- Check Draw Conditions ---
                // 1. Repetition Rule (Simplified: 3 repetitions by player with more pieces)
                 // Count pieces after the move and potential starvation
                const orangeCount = Object.values(gameState.board).filter(p => p?.player === PLAYERS.ORANGE).length;
                const yellowCount = Object.values(gameState.board).filter(p => p?.player === PLAYERS.YELLOW).length;
                let restrictedPlayer = null; // Player who loses if they repeat
                if (orangeCount > yellowCount) restrictedPlayer = PLAYERS.ORANGE;
                else if (yellowCount > orangeCount) restrictedPlayer = PLAYERS.YELLOW;

                // If the current board state has occurred >= 3 times AND the player who just moved is the restricted one
                if (gameState.boardStateHistory[boardStateString] >= 3 && playerWhoMoved === restrictedPlayer) {
                    gameState.winner = opponent; // The *other* player wins
                    gameState.gameOver = true;
                    updateStatus(`${opponent.toUpperCase()} wins! ${playerWhoMoved.toUpperCase()} forced repetition while having more pieces.`);
                    disablePlayerInteraction();
                    updateUI();
                    updateUndoButtonState();
                    console.log("Repetition rule invoked! Player lost.");
                    return; // Game over (Draw condition resulting in a loss for the repeater)
                }

                // 2. Stalemate Check (Check if the *next* player has any valid moves)
                if (checkForStalemate(opponent)) {
                    gameState.winner = null; // No winner in stalemate
                    gameState.gameOver = true;
                    updateStatus(`Stalemate! ${opponent.toUpperCase()} has no valid moves. Game is a draw.`);
                    disablePlayerInteraction();
                    updateUI();
                    updateUndoButtonState();
                    console.log("Stalemate detected!");
                    return; // Game over (Draw)
                }

                // --- Switch Player and Update UI ---
                gameState.currentPlayer = opponent; // Switch turn to the opponent
                // Increment turn number only after Yellow (AI) moves
                if (playerWhoMoved === PLAYERS.YELLOW) {
                    gameState.turnNumber++;
                    console.log("Incrementing turn number to:", gameState.turnNumber);
                }
                updateStatus(`${opponent.toUpperCase()}'s turn.${statusAction}`); // Update status for the next player
                updateUI(); // Update turn indicator, buttons
                updateUndoButtonState(); // Reflect change in who's turn it is
                updateAllPieceAccessibility(); // Update which pieces are interactive

                // Store AI's last move for highlighting (if Yellow just moved)
                if (playerWhoMoved === PLAYERS.YELLOW) {
                    aiLastMove = { from: fromCoords, to: toCoords };
                    highlightAILastMove();
                }

                // --- Trigger AI if it's now Yellow's turn ---
                if (gameState.currentPlayer === PLAYERS.YELLOW && !gameState.gameOver) {
                    disablePlayerInteraction(); // Prevent player moves during AI thinking
                    undoButton.disabled = true; // Prevent undo during AI thinking
                    // Add a delay before starting AI calculation
                    console.log("AI Turn: Waiting 2 seconds before thinking..."); // Optional: log the delay start
                    setTimeout(triggerAIMove, 2000); // 2000ms (2 second) delay
                } else if (!gameState.gameOver) {
                    // If it's Orange's turn, ensure interaction is enabled
                    enablePlayerInteraction();
                }
            }

            /**
             * Checks if the specified player has any valid moves available in the current board state.
             * @param {string} playerToCheck - The player ('orange' or 'yellow') to check for stalemate.
             * @returns {boolean} True if the player has no valid moves (stalemate), false otherwise.
             */
            function checkForStalemate(playerToCheck) {
                // Iterate through all pieces belonging to the player
                for (const fromCoords in gameState.board) {
                    const piece = gameState.board[fromCoords];
                    if (piece?.player === playerToCheck) {
                        // Get all potential destination squares for this piece
                        const destinations = getPotentialMoveDestinations(fromCoords, piece);
                        // Check if *any* of these potential destinations result in a valid move
                        for (const toCoords of destinations) {
                            if (isValidMove(fromCoords, toCoords, piece).valid) {
                                // Found at least one valid move, so it's not stalemate
                                console.log(`Stalemate check: Found valid move for ${playerToCheck}: ${fromCoords} to ${toCoords}`);
                                return false;
                            }
                        }
                    }
                }
                // If the loop completes without finding any valid moves, it's stalemate
                console.log(`Stalemate check: No valid moves found for ${playerToCheck}.`);
                return true;
            }

            /**
             * Determines if a move from `fromCoords` to `toCoords` is legal according to game rules.
             * Checks terrain, piece abilities, capture rules, and jump paths.
             * @param {string} fromCoords - Starting algebraic coordinates.
             * @param {string} toCoords - Ending algebraic coordinates.
             * @param {object} piece - The data object of the piece attempting the move (the ATTACKER).
             * @param {object} [currentBoardState=gameState.board] - Optional board state for simulation.
             * @returns {{valid: boolean, reason: string}} An object indicating if the move is valid and the reason if not.
             */
            function isValidMove(fromCoords, toCoords, piece, currentBoardState = gameState.board) {
                // --- Basic Checks ---
                if (!piece) return { valid: false, reason: "No piece selected." };
                if (fromCoords === toCoords) return { valid: false, reason: "Cannot move to the same square." };

                const fromRC = getRowCol(fromCoords);
                const toRC = getRowCol(toCoords);
                if (!fromRC || !toRC) return { valid: false, reason: "Invalid coordinates." };

                const targetPieceData = currentBoardState[toCoords] || null; // The DEFENDER
                const pieceRank = piece.rank; // Attacker rank
                const pieceAbilities = SPECIAL_ABILITIES[pieceRank] || {};

                // --- Rule: Cannot capture own piece ---
                if (targetPieceData?.player === piece.player) {
                    return { valid: false, reason: "Cannot capture your own piece." };
                }

                // --- Rule: Cannot move into own Den ---
                const ownDen = piece.player === PLAYERS.ORANGE ? DENS.orange : DENS.yellow;
                if (toCoords === ownDen) {
                    return { valid: false, reason: "Cannot enter your own den." };
                }

                // --- Rule: Hungry animal cannot enter opponent's den ---
                if (piece.isHungry) { // Check only if the piece is currently hungry
                    const opponentDen = piece.player === PLAYERS.ORANGE ? DENS.yellow : DENS.orange;
                    if (toCoords === opponentDen) {
                        return { valid: false, reason: "Hungry animal cannot enter the den to win." };
                    }
                }

                // --- Movement Type and Distance Calculation ---
                const dr = Math.abs(fromRC.row - toRC.row);
                const dc = Math.abs(fromRC.col - toRC.col);
                const isOrthogonal = (dr === 1 && dc === 0) || (dr === 0 && dc === 1);

                // --- Water Movement Rules ---
                const isMovingToWater = WATER_SQUARES.has(toCoords);
                const isMovingFromWater = WATER_SQUARES.has(fromCoords);

                if (isMovingToWater && !pieceAbilities.swims) {
                    return { valid: false, reason: "This animal cannot enter water." };
                }
                 // Check rules for moves starting AND ending in water
                 if (isMovingFromWater && isMovingToWater) {
                     // Check if attacking within water
                     if (targetPieceData) { // Is there a piece at the destination?
                        if (pieceAbilities.swims) {
                            // Swimmers (Rat/Dog) can attack other pieces within water
                            // (Capture validity based on rank etc. is checked later)
                        } else {
                            // Non-swimmers cannot attack into/within water
                            return { valid: false, reason: "Cannot attack into water (unless Rat/Dog)." };
                        }
                     }
                     // Implicitly allow movement between empty water squares for swimmers here
                     // because the blocking 'else if (!targetPieceData)' was removed.
                 }
                // Rule: Rat cannot attack Elephant if Rat is in the water
                if (pieceRank === 1 && targetPieceData?.rank === 8 && isMovingFromWater) {
                     return { valid: false, reason: "Rat cannot attack Elephant from water."};
                }
                // Rule: Cannot attack land from water
                if (isMovingFromWater && !isMovingToWater && targetPieceData) { // Added targetPieceData check - only relevant for attacks
                     return { valid: false, reason: "Cannot attack land from water." };
                }
                // Note: Exiting water to empty land is handled implicitly later by checking orthogonal/jump validity


                // --- Jump Movement Rules ---
                let isJumpValid = false;
                 if (!isMovingFromWater && !isMovingToWater) {
                     const isVerticalJump = dc === 0 && dr === 4 && (fromRC.col === 1 || fromRC.col === 2 || fromRC.col === 4 || fromRC.col === 5);
                     const isHorizontalJump = dr === 0 && dc === 3 && (fromRC.row >= 3 && fromRC.row <= 5);

                     if (isVerticalJump || isHorizontalJump) {
                         if ((isVerticalJump && !pieceAbilities.jumpV) || (isHorizontalJump && !pieceAbilities.jumpH)) {
                             return { valid: false, reason: "This animal cannot jump that way." };
                         }
                         if (!checkJumpPathClear(fromRC, toRC, piece.player, currentBoardState)) {
                             return { valid: false, reason: "Jump path blocked by opponent in water." };
                         }
                         isJumpValid = true;
                     }
                 }


                if (!isOrthogonal && !isJumpValid) {
                    return { valid: false, reason: "Invalid move distance or type (not 1 square orthogonal or valid jump)." };
                }

                // --- Capture Rules (if moving to an occupied square) ---
                if (targetPieceData) { // If there is a defender
                    let attackerRank = pieceRank;
                    let defenderRank = targetPieceData.rank; // Defender's original rank

                    // --- CORRECTED Trap Rule ---
                    // Check if the DEFENDER is on a trap located in the ATTACKER'S territory
                    // (i.e., near the attacker's den)
                    let defenderIsOnAttackerTerritoryTrap = false;
                    if (targetPieceData.player === PLAYERS.ORANGE) { // If the defender is Orange...
                        // Check if they are on a trap near Yellow's den (TRAPS.orange)
                        if (TRAPS.orange.has(toCoords)) {
                            defenderIsOnAttackerTerritoryTrap = true;
                        }
                    } else if (targetPieceData.player === PLAYERS.YELLOW) { // If the defender is Yellow...
                        // Check if they are on a trap near Orange's den (TRAPS.yellow)
                        if (TRAPS.yellow.has(toCoords)) {
                            defenderIsOnAttackerTerritoryTrap = true;
                        }
                    }

                    if (defenderIsOnAttackerTerritoryTrap) {
                        defenderRank = 0; // Defender is weakened when on an opponent's trap square
                        if (typeof console !== 'undefined' && console.log) {
                            console.log(`Trap Rule Applied: Defender ${targetPieceData.player} ${RANK_TO_NAME[targetPieceData.rank]}@${toCoords} is on opponent's trap. Defender rank set to 0.`);
                        }
                    }
                    // --- End CORRECTED Trap Rule ---


                    // Rule: Rat (1) can capture Elephant (8) - UNLESS Rat attacks from water
                    const isRatAttackElephant = pieceRank === 1 && targetPieceData.rank === 8;
                    if (isRatAttackElephant && !isMovingFromWater) {
                        return { valid: true }; // Special case: Valid capture
                    }

                    // REMOVED: Rule preventing Elephant (8) from capturing Rat (1)
                    // The general capture rule below will now handle this.

                    // General Rule: Higher or equal rank captures lower rank (unless Rat vs Elephant or trap involved)
                    // Compare attacker rank against the potentially modified defenderRank
                    if (attackerRank < defenderRank && defenderRank !== 0) { // defenderRank 0 means weakened by trap
                        // Corrected reason message formatting
                        return { valid: false, reason: `Cannot attack higher-ranked animal (${attackerRank} vs ${targetPieceData.rank}${defenderIsOnAttackerTerritoryTrap ? ' [Trap->0]' : ''}).` };
                    }
                }

                // If all checks passed
                return { valid: true };
            }


            /**
             * Checks if the path for a Lion/Tiger jump over water is clear of opponent swimming pieces (Rat/Dog).
             * @param {{row: number, col: number}} fromRC - Start row/col indices.
             * @param {{row: number, col: number}} toRC - End row/col indices.
             * @param {string} attackerPlayer - The player making the jump ('orange' or 'yellow').
             * @returns {boolean} True if the path is clear, false otherwise.
             */
            function checkJumpPathClear(fromRC, toRC, attackerPlayer) {
                const opponent = attackerPlayer === PLAYERS.ORANGE ? PLAYERS.YELLOW : PLAYERS.ORANGE;
                const startRow = Math.min(fromRC.row, toRC.row);
                const endRow = Math.max(fromRC.row, toRC.row);
                const startCol = Math.min(fromRC.col, toRC.col);
                const endCol = Math.max(fromRC.col, toRC.col);

                // Vertical Jump Check (column is the same)
                if (fromRC.col === toRC.col) {
                    // Check the 2 or 3 water squares between start and end row
                    for (let r = startRow + 1; r < endRow; r++) {
                        const coords = getCoords(r, fromRC.col);
                        // All squares in the path must be water (this should always be true for valid jump coords)
                        if (!WATER_SQUARES.has(coords)) {
                            console.warn(`Jump path check anomaly: ${coords} in vertical jump path is not water.`);
                            return false; // Should not happen with correct jump logic
                        }
                        // Check if an opponent's piece occupies a water square in the path
                        const blockingPiece = getPieceData(coords);
                        // Only opponent's pieces block the jump
                        if (blockingPiece?.player === opponent) {
                            console.log(`Jump blocked by opponent ${RANK_TO_NAME[blockingPiece.rank]} at ${coords}`);
                            return false; // Path is blocked
                        }
                    }
                }
                // Horizontal Jump Check (row is the same)
                else if (fromRC.row === toRC.row) {
                     // Check the 1 or 2 water squares between start and end col
                    for (let c = startCol + 1; c < endCol; c++) {
                        const coords = getCoords(fromRC.row, c);
                        // All squares must be water
                        if (!WATER_SQUARES.has(coords)) {
                             console.warn(`Jump path check anomaly: ${coords} in horizontal jump path is not water.`);
                            return false;
                        }
                        // Check for opponent's blocking piece
                        const blockingPiece = getPieceData(coords);
                        if (blockingPiece?.player === opponent) {
                            console.log(`Jump blocked by opponent ${RANK_TO_NAME[blockingPiece.rank]} at ${coords}`);
                            return false; // Path is blocked
                        }
                    }
                } else {
                    // If not purely vertical or horizontal, it's not a valid jump path
                    console.error("checkJumpPathClear called with non-orthogonal jump coordinates.");
                    return false;
                }

                // If loop completes without finding blockers, the path is clear
                return true;
            }


            // --- Hungry/Starve Logic ---

            /**
             * Identifies all pieces for the specified player that are currently "hungry"
             * (i.e., have a valid capturing move available against an opponent piece).
             * Updates the `isHungry` property on the piece data in `gameState.board`.
             * @param {string} playerToDeclareFor - The player ('orange' or 'yellow') whose pieces should be checked.
             * @returns {{hungryCount: number, hungryPiecesMap: object}} An object containing the count of hungry pieces
             *          and a map `{ coords: true }` for each hungry piece.
             */
            function declareHungryAnimals(playerToDeclareFor) {
                let hungryCount = 0;
                const hungryPiecesMap = {}; // Stores coords of hungry pieces: { 'a1': true, 'c3': true }
                const opponent = playerToDeclareFor === PLAYERS.ORANGE ? PLAYERS.YELLOW : PLAYERS.ORANGE;

                // Check each piece belonging to the specified player
                for (const coords in gameState.board) {
                    const piece = gameState.board[coords];
                    if (piece?.player === playerToDeclareFor) {
                        // Get potential move destinations for this piece
                        const destinations = getPotentialMoveDestinations(coords, piece);
                        // Check each destination
                        for (const targetCoords of destinations) {
                            const targetPiece = gameState.board[targetCoords];
                            // Is there an opponent piece at the destination?
                            if (targetPiece?.player === opponent) {
                                // Is the capture move valid according to rules?
                                if (isValidMove(coords, targetCoords, piece).valid) {
                                    // If yes, this piece is hungry. Mark it and break inner loop.
                                    hungryPiecesMap[coords] = true;
                                    hungryCount++;
                                    break; // No need to check other destinations for this piece
                                }
                            }
                        }
                    }
                }

                if (hungryCount > 0) {
                    console.log(`${playerToDeclareFor.toUpperCase()} has ${hungryCount} hungry animal(s): ${Object.keys(hungryPiecesMap).join(', ')}`);
                }
                return { hungryCount, hungryPiecesMap };
            }


            /**
             * Checks if any hungry pieces of the current player failed to make a capture
             * during the move that just occurred. Removes starved pieces from the board state and DOM.
             * Called *before* the piece is moved in `performMove`.
             * @param {string} movedPieceCoords - The starting coordinates of the piece that is *about* to be moved.
             * @param {boolean} wasAttack - Indicates if the move being performed *is* a capture.
             * @returns {string[]} An array of coordinates of the pieces that starved.
             */
            function checkAndApplyStarvation(movedPieceCoords, wasAttack) {
                const currentPlayer = gameState.currentPlayer; // Player whose turn it *was*
                const starvedPiecesCoords = []; // Store coords of pieces to remove

                // Iterate through all pieces on the board
                for (const coords in gameState.board) {
                    const piece = gameState.board[coords];
                    // Check if it's the current player's piece AND it was marked as hungry *before* this move started
                    if (piece?.player === currentPlayer && piece.isHungry) {
                        // Did *this specific piece* make the capturing move?
                        const didThisPieceAttack = (coords === movedPieceCoords) && wasAttack;

                        if (!didThisPieceAttack) {
                            // If this hungry piece did NOT make a capturing move, it starves
                            console.log(`STARVE: ${currentPlayer} ${RANK_TO_NAME[piece.rank]}@${coords} was hungry but did not attack. Starved.`);
                            starvedPiecesCoords.push(coords);
                        } else {
                            // If this hungry piece *did* make the attack, it's saved
                            console.log(`SAVED: ${currentPlayer} ${RANK_TO_NAME[piece.rank]}@${coords} attacked and is no longer hungry (for now).`);
                            // Note: Its isHungry status will be recalculated for the opponent's turn anyway.
                        }
                    }
                }

                // Remove starved pieces from the board state and DOM
                starvedPiecesCoords.forEach(coords => {
                    const starvedElement = document.getElementById(getPieceElementId(coords));
                    const pieceData = gameState.board[coords]; // Get data before deleting
                    if (pieceData) { // Ensure piece still exists (should always be true here)
                        console.log(`Removing starved piece ${RANK_TO_NAME[pieceData.rank]}@${coords}`);
                        delete gameState.board[coords]; // Remove from board state
                        // Animate and remove DOM element
                        if (starvedElement) {
                            starvedElement.classList.add('captured'); // Use capture animation for removal
                            setTimeout(() => starvedElement.remove(), 400);
                        }
                    }
                });

                return starvedPiecesCoords; // Return list of starved piece coordinates for logging/notation
            }


            /**
             * Gets all geometrically possible destination squares for a piece, considering orthogonal moves and jumps.
             * Does not validate the move legality (terrain, captures), only potential squares.
             * @param {string} fromCoords - The starting coordinates.
             * @param {object} piece - The piece data object.
             * @returns {string[]} An array of potential destination coordinate strings.
             */
            function getPotentialMoveDestinations(fromCoords, piece) {
                const destinations = new Set(); // Use a Set to avoid duplicate coordinates
                const rc = getRowCol(fromCoords);
                if (!rc || !piece) return [];

                const { row, col } = rc;
                const abilities = SPECIAL_ABILITIES[piece.rank] || {};

                // 1. Orthogonal Moves (adjacent squares)
                const orthMoves = [
                    getCoords(row + 1, col), // Down
                    getCoords(row - 1, col), // Up
                    getCoords(row, col + 1), // Right
                    getCoords(row, col - 1)  // Left
                ];
                orthMoves.forEach(c => {
                    if (c) destinations.add(c); // Add if valid coords
                });

                // 2. Jump Moves (Lion/Tiger/Leopard)
                // Vertical jumps (over cols 1, 2, 4, 5 river sections)
                if (abilities.jumpV && (col === 1 || col === 2 || col === 4 || col === 5)) {
                    // Check jump up (possible from rows 3 to 8)
                    if (row >= 3) { // Need 3 rows of water + 1 landing row above
                        const destUp = getCoords(row - 4, col); // 4 rows difference
                        if (destUp) destinations.add(destUp);
                    }
                    // Check jump down (possible from rows 0 to 5)
                    if (row <= 5) { // Need 3 rows of water + 1 landing row below
                        const destDown = getCoords(row + 4, col);
                        if (destDown) destinations.add(destDown);
                    }
                }
                // Horizontal jumps (over rows 3, 4, 5 river sections)
                if (abilities.jumpH && (row >= 3 && row <= 5)) { // Must be in a river row
                    // Check jump left (possible from cols 3 to 6)
                    if (col >= 3) { // Need 2 cols of water + 1 landing col left
                        const destLeft = getCoords(row, col - 3); // 3 cols difference
                        if (destLeft) destinations.add(destLeft);
                    }
                     // Check jump right (possible from cols 0 to 3)
                    if (col <= 3) { // Need 2 cols of water + 1 landing col right
                        const destRight = getCoords(row, col + 3);
                        if (destRight) destinations.add(destRight);
                    }
                }

                return [...destinations]; // Convert Set back to an array
            }


            // --- AI Logic (Minimax) ---

            /**
             * Initiates the AI's move calculation process.
             * Calls the Minimax function to find the best move.
             * Performs the chosen move or handles game end if no moves are possible.
             */
            function triggerAIMove() {
                console.log("AI (Yellow) is thinking...");
                // Find the best move using Minimax with alpha-beta pruning
                const bestMoveResult = findBestMoveMinimax(MINIMAX_DEPTH, gameState, PLAYERS.YELLOW);

                if (bestMoveResult?.move) {
                    // If a best move is found, perform it
                    console.log(`AI chooses move: ${bestMoveResult.move.from} to ${bestMoveResult.move.to} (Score: ${bestMoveResult.score})`);
                    performMove(bestMoveResult.move.from, bestMoveResult.move.to);
                } else {
                    // If AI has no valid moves (should be caught by stalemate check earlier, but as a fallback)
                    console.log("AI has no valid moves! Checking game end conditions.");
                    if (!gameState.gameOver) {
                        if (checkForStalemate(PLAYERS.YELLOW)) {
                            // If it's genuinely stalemate
                            gameState.winner = null;
                            gameState.gameOver = true;
                            updateStatus("Stalemate! AI (Yellow) has no valid moves. Game is a draw.");
                        } else {
                            // If not stalemate but AI failed to find a move (error or unexpected state)
                            gameState.winner = PLAYERS.ORANGE; // Opponent wins
                            gameState.gameOver = true;
                            updateStatus("AI Error or No Moves Found! Orange wins!");
                        }
                        disablePlayerInteraction();
                        updateUI();
                        updateUndoButtonState();
                    }
                }
            }

            /**
             * Finds the best move for the AI using the Minimax algorithm at the root level.
             * Considers hungry piece obligations.
             * @param {number} depth - The maximum search depth for Minimax.
             * @param {object} currentGameState - The current state of the game.
             * @param {string} playerForMax - The player the AI is playing as (always YELLOW here).
             * @returns {{move: object, score: number}|null} The best move found ({from, to}) and its score, or null if no moves.
             */
            function findBestMoveMinimax(depth, currentGameState, playerForMax) {
                let bestScore = -Infinity; // Initialize best score for maximizing player
                let bestMove = null;

                // Get all possible valid moves for the AI
                const possibleMoves = getAllValidMoves(currentGameState.board, currentGameState.currentPlayer);
                const opponentDen = playerForMax === PLAYERS.ORANGE ? DENS.yellow : DENS.orange;

                // If no moves are possible, return null
                if (possibleMoves.length === 0) {
                    console.log("AI findBestMove: No possible moves found.");
                    return null;
                }

                // --- Immediate Win Check ---
                // Check if any move leads directly to the opponent's den (instant win)
                for (const move of possibleMoves) {
                    if (move.to === opponentDen) {
                        console.log("AI Found immediate winning move to Den:", move);
                        // Assign a very high score, factoring in depth (faster win is better)
                        return { move: move, score: 10000 + depth };
                    }
                }

                // --- Handle Hungry Pieces Obligation ---
                // Identify which of the possible moves are made by hungry pieces
                const hungryMoves = possibleMoves.filter(move => currentGameState.board[move.from]?.isHungry);
                let movesToConsider = possibleMoves; // Default to considering all moves

                if (hungryMoves.length > 0) {
                    // If there are hungry pieces, check if any of their moves are attacks
                    const attackingHungryMoves = hungryMoves.filter(move => !!currentGameState.board[move.to]);
                    if (attackingHungryMoves.length > 0) {
                        // Rule: If a hungry piece *can* attack, it *must*. Only consider attacking moves by hungry pieces.
                        console.log("AI considering only ATTACKING moves by hungry pieces:", attackingHungryMoves);
                        movesToConsider = attackingHungryMoves;
                    } else {
                        // Rule: If hungry pieces exist but none can attack, they must still move. Consider only moves by hungry pieces.
                        console.log("AI considering only non-attacking moves by hungry pieces:", hungryMoves);
                        movesToConsider = hungryMoves;
                    }
                }
                // If no hungry pieces, movesToConsider remains all possibleMoves.

                // --- Evaluate Moves using Minimax ---
                // Iterate through the prioritized list of moves
                for (const move of movesToConsider) {
                    // Simulate the move to get the resulting board state
                    const nextState = simulateMove(currentGameState, move);
                    // Call minimax for the opponent's turn (minimizing player)
                    // Alpha/Beta are initialized to worst-case values
                    const score = minimax(depth - 1, nextState, false, -Infinity, Infinity, playerForMax);

                    // --- Add Randomness (Tie-breaking) ---
                    // Add a small random value to scores that aren't immediate wins/losses
                    // This prevents the AI from always making the same move in equivalent situations.
                    let currentScore = score;
                    if (Math.abs(score) < 5000) { // Don't add randomness to clear win/loss scores
                        currentScore += Math.random() * 0.1; // Small random factor
                    }

                    // Update best move if current move yields a higher score
                    if (currentScore > bestScore) {
                        bestScore = currentScore;
                        bestMove = move;
                    }
                }

                 // Fallback: If no best move was found among considered moves (e.g., all led to immediate loss)
                 // but there were other possible moves initially, pick a random valid move to avoid crashing.
                 // This should ideally not happen if evaluation/minimax is correct.
                if (!bestMove && possibleMoves.length > 0) {
                    console.warn("Minimax didn't find a best move among 'movesToConsider'. Picking random valid move as fallback.");
                    bestMove = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                    bestScore = -Infinity; // Assign a low score as it's a fallback
                }

                return { move: bestMove, score: bestScore };
            }

            /**
             * The recursive Minimax function with Alpha-Beta Pruning.
             * Explores the game tree to a specified depth, evaluating board states.
             * @param {number} depth - Remaining depth to search.
             * @param {object} nodeGameState - The game state at the current node in the search tree.
             * @param {boolean} isMaximizingPlayer - True if the current node is for the AI (maximizing), false for the opponent (minimizing).
             * @param {number} alpha - The best score found so far for the maximizing player along the current path.
             * @param {number} beta - The best score found so far for the minimizing player along the current path.
             * @param {string} playerForMax - The player the AI controls (YELLOW).
             * @returns {number} The evaluated score for the current node.
             */
            function minimax(depth, nodeGameState, isMaximizingPlayer, alpha, beta, playerForMax) {
                // --- Base Cases for Recursion ---
                // 1. Reached maximum depth or game is over in this simulated state
                if (depth === 0 || nodeGameState.gameOver) {
                    const baseScore = evaluateBoard(nodeGameState.board, playerForMax);
                    // Add/subtract remaining depth to prioritize faster wins/slower losses
                    if (baseScore > 5000) return baseScore + depth; // Faster win is better
                    if (baseScore < -5000) return baseScore - depth; // Slower loss is better
                    return baseScore; // Return static evaluation
                }

                // Get possible moves from the current node state
                const possibleMoves = getAllValidMoves(nodeGameState.board, nodeGameState.currentPlayer);

                // 2. No moves possible (Stalemate or Checkmate in simulation)
                if (possibleMoves.length === 0) {
                    // Check if it's a stalemate (draw = 0) or if the current player lost (win for opponent)
                    return checkForStalemate(nodeGameState.currentPlayer) ? 0 : // Stalemate score
                           (isMaximizingPlayer ? (-10000 - depth) : (10000 + depth)); // Lost score (opponent won)
                }

                // --- Handle Hungry Pieces Obligation (within simulation) ---
                 // Prioritize moves based on hungry rules, same logic as in findBestMoveMinimax
                const hungryMoves = possibleMoves.filter(move => nodeGameState.board[move.from]?.isHungry);
                let movesToConsider = possibleMoves;
                if (hungryMoves.length > 0) {
                    const attackingHungryMoves = hungryMoves.filter(move => !!nodeGameState.board[move.to]);
                    if (attackingHungryMoves.length > 0) {
                        movesToConsider = attackingHungryMoves;
                    } else {
                        movesToConsider = hungryMoves;
                    }
                }

                // --- Recursive Exploration ---
                if (isMaximizingPlayer) { // AI's turn (maximize score)
                    let maxEval = -Infinity;
                    for (const move of movesToConsider) {
                        const nextState = simulateMove(nodeGameState, move); // Simulate the move
                        // Recursive call for the minimizing player's turn
                        const evaluation = minimax(depth - 1, nextState, false, alpha, beta, playerForMax);
                        maxEval = Math.max(maxEval, evaluation); // Update max score found
                        alpha = Math.max(alpha, evaluation); // Update alpha (best for maximizer)
                        if (beta <= alpha) {
                            break; // Beta cutoff (minimizer already found a better option elsewhere)
                        }
                    }
                     // Fallback if all 'movesToConsider' led to immediate loss/bad score
                     // Check if there were *any* possible moves initially. If so, evaluate one as fallback.
                     // This prevents returning -Infinity if only forced bad moves were considered due to hungry rules.
                     if (maxEval === -Infinity && possibleMoves.length > 0 && movesToConsider.length < possibleMoves.length) {
                          console.log(`Minimax Max fallback: Evaluating non-hungry move at depth ${depth}`);
                          const fallbackState = simulateMove(nodeGameState, possibleMoves.find(m => !movesToConsider.includes(m)) || possibleMoves[0]);
                          return minimax(depth -1, fallbackState, false, alpha, beta, playerForMax);
                     }
                    return maxEval;
                } else { // Opponent's turn (minimize score)
                    let minEval = Infinity;
                    for (const move of movesToConsider) {
                        const nextState = simulateMove(nodeGameState, move); // Simulate the move
                        // Recursive call for the maximizing player's turn
                        const evaluation = minimax(depth - 1, nextState, true, alpha, beta, playerForMax);
                        minEval = Math.min(minEval, evaluation); // Update min score found
                        beta = Math.min(beta, evaluation); // Update beta (best for minimizer)
                        if (beta <= alpha) {
                            break; // Alpha cutoff (maximizer already found a better option elsewhere)
                        }
                    }
                     // Similar fallback for minimizer
                     if (minEval === Infinity && possibleMoves.length > 0 && movesToConsider.length < possibleMoves.length) {
                          console.log(`Minimax Min fallback: Evaluating non-hungry move at depth ${depth}`);
                         const fallbackState = simulateMove(nodeGameState, possibleMoves.find(m => !movesToConsider.includes(m)) || possibleMoves[0]);
                         return minimax(depth -1, fallbackState, true, alpha, beta, playerForMax);
                     }
                    return minEval;
                }
            }

            /**
             * Generates a list of all valid moves for a given player in a specific board state.
             * @param {object} boardState - The board state object ({ coords: pieceData }).
             * @param {string} player - The player ('orange' or 'yellow') whose moves to find.
             * @returns {Array<object>} An array of valid move objects [{ from, to }, ...].
             */
            function getAllValidMoves(boardState, player) {
                const validMoves = [];
                if (!boardState) return []; // Safety check

                // Iterate through all squares on the board
                for (const fromCoords in boardState) {
                    const piece = boardState[fromCoords];
                    // Check if the piece belongs to the specified player
                    if (piece?.player === player) {
                        // Get potential destinations (geometric moves)
                        const destinations = getPotentialMoveDestinations(fromCoords, piece);
                        // Validate each potential destination
                        for (const toCoords of destinations) {
                            // Use isValidMove with a copy of piece data to avoid state mutation issues
                            if (isValidMove(fromCoords, toCoords, { ...piece }, boardState).valid) {
                                validMoves.push({ from: fromCoords, to: toCoords });
                            }
                        }
                    }
                }
                return validMoves;
            }

            /**
             * Creates a new game state object representing the result of making a specific move.
             * Does *not* handle hungry/starve rules or complex win conditions, focuses on board changes.
             * Used for AI simulation.
             * @param {object} currentGameState - The game state *before* the move.
             * @param {object} move - The move object { from, to }.
             * @returns {object} A new game state object representing the state *after* the move.
             */
            function simulateMove(currentGameState, move) {
                // Create a deep copy of the board to avoid modifying the original state
                const nextState = {
                    board: JSON.parse(JSON.stringify(currentGameState.board)),
                    currentPlayer: currentGameState.currentPlayer, // Temporarily keep current player
                    gameOver: false, // Assume game not over unless conditions met
                    winner: null
                };

                const piece = nextState.board[move.from];

                // Error handling: If piece doesn't exist at source (shouldn't happen with valid moves)
                if (!piece) {
                    console.error("SimulateMove Error: Piece not found at source", move.from, "Current Board:", currentGameState.board);
                    // Mark game as over, opponent wins (as current player can't move)
                    nextState.gameOver = true;
                    nextState.winner = currentGameState.currentPlayer === PLAYERS.ORANGE ? PLAYERS.YELLOW : PLAYERS.ORANGE;
                    return nextState;
                }

                // Simulate capture by deleting piece at destination (if any)
                const targetPiece = nextState.board[move.to];
                if (targetPiece) {
                    // In simulation, we just remove the piece from the board state
                    delete nextState.board[move.to];
                }

                // Move the piece in the board state
                nextState.board[move.to] = piece;
                delete nextState.board[move.from];

                // --- Simplified Win Condition Checks for Simulation ---
                const opponent = piece.player === PLAYERS.ORANGE ? PLAYERS.YELLOW : PLAYERS.ORANGE;
                const opponentDen = piece.player === PLAYERS.ORANGE ? DENS.yellow : DENS.orange;

                // 1. Reached opponent's den
                if (move.to === opponentDen) {
                    nextState.gameOver = true;
                    nextState.winner = piece.player;
                } else {
                    // 2. Check if opponent has any pieces left (simplified check)
                    let opponentPieceCount = 0;
                    for (const coords in nextState.board) {
                        if (nextState.board[coords]?.player === opponent) {
                            opponentPieceCount++;
                            break; // Found one, no need to count all
                        }
                    }
                    if (opponentPieceCount === 0) {
                        nextState.gameOver = true;
                        nextState.winner = piece.player;
                    }
                }

                // Switch the current player for the next node in the simulation tree
                nextState.currentPlayer = opponent;

                 // Update hungry status for the *next* player in the simulated state
                 // This is crucial for the minimax evaluation to correctly consider forced moves.
                 const { hungryPiecesMap } = declareHungryAnimals(nextState.currentPlayer); // Use the *new* current player
                 Object.keys(nextState.board).forEach(coords => {
                     const p = nextState.board[coords];
                     if (p) {
                         p.isHungry = !!hungryPiecesMap[coords];
                     }
                 });


                return nextState;
            }

            /**
             * Evaluates the static board state from the perspective of the AI player (playerForMax).
             * Assigns scores based on piece values, positional advantage, den/trap threats, and win/loss conditions. // <-- Updated comment
             * @param {object} boardState - The board state to evaluate.
             * @param {string} playerForMax - The player considered "maximizing" (AI, usually Yellow).
             * @returns {number} A numerical score representing the board state's favorability for playerForMax.
             *          Positive scores favor playerForMax, negative scores favor the opponent.
             *          Very large positive/negative scores indicate win/loss.
             */
            function evaluateBoard(boardState, playerForMax) {
                let score = 0;
                const pieceValues = { 1: 35, 2: 10, 3: 40, 4: 30, 5: 50, 6: 70, 7: 80, 8: 75 }; // Rat:35, Cat:10, Dog:40, Wolf:30, Leopard:50, Tiger:70, Lion:80, Elephant:75
                const opponent = playerForMax === PLAYERS.ORANGE ? PLAYERS.YELLOW : PLAYERS.ORANGE;

                // Dens and Traps relative to the player being evaluated (playerForMax)
                const maxDen = playerForMax === PLAYERS.ORANGE ? DENS.orange : DENS.yellow; // playerForMax's own den
                const minDen = playerForMax === PLAYERS.ORANGE ? DENS.yellow : DENS.orange; // Opponent's den (target)
                // Traps near playerForMax's den (where opponent pieces are penalized)
                const maxTraps = playerForMax === PLAYERS.ORANGE ? TRAPS.yellow : TRAPS.orange;
                // Traps near opponent's den (where playerForMax pieces get bonus for proximity)
                const minTraps = playerForMax === PLAYERS.ORANGE ? TRAPS.orange : TRAPS.yellow; // Identify opponent's traps (near AI's den)

                const adjacentToMaxDen = getAdjacentCoords(maxDen); // Squares next to playerForMax's den
                // Calculate squares adjacent to the traps near the opponent's den (using helper)
                const adjacentToMinTraps = getAdjacentCoordsSet(minTraps);

                // --- Evaluation Constants ---
                const IMMEDIATE_THREAT_PENALTY = 750;  // Penalty for opponent near AI den/traps
                const NEAR_OPPONENT_TRAP_BONUS = 50;   // Bonus for AI near opponent's traps (tune if needed)
                const DEN_PROXIMITY_MULTIPLIER = 0.5; // Bonus multiplier for distance to opponent den

                let maxHasWon = false;
                let minHasWon = false;
                let maxPieceCount = 0;
                let minPieceCount = 0;

                for (const coords in boardState) {
                    const piece = boardState[coords];
                    if (!piece) continue;

                    let pieceScore = pieceValues[piece.rank] || 0;
                    const rc = getRowCol(coords);

                    // --- Evaluate based on player ---
                    if (piece.player === playerForMax) { // Piece belongs to the AI (maximizing player)
                        maxPieceCount++;
                        // --- Positional Bonuses for playerForMax ---
                        // 1. Proximity to opponent's den (the target)
                        const targetDenRC = getRowCol(minDen);
                        if (rc && targetDenRC) {
                            const dist = Math.abs(rc.row - targetDenRC.row) + Math.abs(rc.col - targetDenRC.col);
                            // Bonus increases as distance decreases (16 is roughly max possible distance)
                            pieceScore += (16 - dist) * DEN_PROXIMITY_MULTIPLIER;
                        }
                        // 2. Proximity to opponent's traps (near AI's own den - defensive bonus)
                        if (adjacentToMinTraps.has(coords)) {
                            console.log(`--- AI Bonus: ${RANK_TO_NAME[piece.rank]}@${coords} is adjacent to opponent trap (near own den). Applying bonus: +${NEAR_OPPONENT_TRAP_BONUS}`);
                            pieceScore += NEAR_OPPONENT_TRAP_BONUS;
                        }

                        score += pieceScore; // Add piece value and bonuses to total score

                        // Check if playerForMax reached opponent's den (win condition)
                        if (coords === minDen) maxHasWon = true;

                    } else { // Piece belongs to the opponent (minimizing player)
                        minPieceCount++;
                        // --- Penalties based on opponent's position ---
                        // 1. Opponent reached playerForMax's den (loss condition)
                        if (coords === maxDen) minHasWon = true;

                        // 2. Check for Immediate Threats to playerForMax's Den
                        const isOnMaxTrap = maxTraps.has(coords); // Opponent is on a trap near AI's den
                        const isAdjacentToMaxDen = adjacentToMaxDen.includes(coords); // Opponent is next to AI's den

                        if (isOnMaxTrap || isAdjacentToMaxDen) {
                             // Apply large penalty if opponent is on AI's trap OR adjacent to AI's den
                             console.log(`!!! Immediate threat detected: Opponent ${RANK_TO_NAME[piece.rank]} at ${coords} (Trap: ${isOnMaxTrap}, Adjacent: ${isAdjacentToMaxDen}). Applying penalty: -${IMMEDIATE_THREAT_PENALTY}`);
                             score -= IMMEDIATE_THREAT_PENALTY;
                        }

                        score -= pieceScore; // Subtract opponent's piece value from total score
                    }
                }

                // --- Check for Win/Loss by Den or Elimination ---
                if (maxHasWon || minPieceCount === 0) return 10000; // Maximizing player wins
                if (minHasWon || maxPieceCount === 0) return -10000; // Minimizing player wins

                return score;
            }


            // --- UI Update & Logging ---

            /**
             * Updates the main UI elements (turn indicator, button states) based on the current game state.
             */
            function updateUI() {
                if (gameState.gameOver) {
                    // Display Game Over message and winner
                    turnIndicator.textContent = `Game Over - ${gameState.winner ? gameState.winner.toUpperCase() : 'DRAW'} Wins!`;
                    turnIndicator.className = 'game-over'; // Apply game over style
                } else {
                    // Display current player's turn
                    turnIndicator.textContent = gameState.currentPlayer.toUpperCase();
                    turnIndicator.className = gameState.currentPlayer; // Apply player color style
                }
                updateUndoButtonState(); // Enable/disable undo button
                updateAllPieceAccessibility(); // Update piece interactivity based on current player/game state
            }

            /**
             * Updates the status message display area and logs the message to the console.
             * @param {string} message - The message to display.
             */
            function updateStatus(message) {
                statusMessage.textContent = message; // Update the DOM element
                console.log("Status:", message); // Also log to console (and potentially debug panel)
            }

            /**
             * Creates and appends a log entry element to the visual move log panel.
             * @param {number} turn - The turn number.
             * @param {string|null} orangeMove - The notation for Orange's move this turn, or null.
             * @param {string|null} yellowMove - The notation for Yellow's move this turn, or null.
             */
            function addLogEntryToDOM(turn, orangeMove, yellowMove) {
                const logEntryDiv = document.createElement('div');
                logEntryDiv.classList.add('log-entry');
                logEntryDiv.dataset.turn = turn; // Store turn number for potential updates

                // Turn Number Span
                const turnSpan = document.createElement('span');
                turnSpan.classList.add('turn-number');
                turnSpan.textContent = `${turn}.`;
                logEntryDiv.appendChild(turnSpan);

                // Orange Move Span (or placeholder)
                const orangeSpan = document.createElement('span');
                if (orangeMove) {
                    orangeSpan.classList.add('log-orange');
                    orangeSpan.textContent = orangeMove;
                } else {
                    orangeSpan.classList.add('placeholder');
                    orangeSpan.textContent = '...'; // Placeholder if Orange hasn't moved yet
                }
                logEntryDiv.appendChild(orangeSpan);

                // Yellow Move Span (only if Yellow has moved)
                if (yellowMove) {
                    const yellowSpan = document.createElement('span');
                    yellowSpan.classList.add('log-yellow');
                    yellowSpan.textContent = yellowMove;
                    logEntryDiv.appendChild(yellowSpan);
                }
                // If yellowMove is null/undefined, no span is added yet.

                moveLogElement.appendChild(logEntryDiv); // Add the entry to the log panel
                moveLogElement.scrollTop = moveLogElement.scrollHeight; // Scroll to the latest entry
            }

            /**
             * Logs a move to the `gameState.moveHistory` array and updates the visual move log panel.
             * Handles creating new turn entries or updating existing ones.
             * @param {string} notation - The algebraic notation of the move (e.g., "8xg7++s").
             * @param {string} playerWhoMoved - The player who made the move ('orange' or 'yellow').
             */
            function logMove(notation, playerWhoMoved) {
                const turnNum = gameState.turnNumber; // Get the current turn number

                // Find if an entry for this turn already exists in the history
                let currentTurnEntry = gameState.moveHistory.find(entry => entry.turn === turnNum);
                // Find if a DOM element for this turn already exists
                let existingLogDiv = moveLogElement.querySelector(`div.log-entry[data-turn="${turnNum}"]`);

                if (playerWhoMoved === PLAYERS.ORANGE) {
                    // If Orange moves, it's always the start of a new turn entry (or overwriting if undo occurred)
                    if (!currentTurnEntry) {
                        // Create new entry in history
                        currentTurnEntry = { turn: turnNum, orange: notation, yellow: null };
                        gameState.moveHistory.push(currentTurnEntry);
                        // Remove existing DOM element if any (e.g., after undo) and add the new one
                        if (existingLogDiv) existingLogDiv.remove();
                        addLogEntryToDOM(turnNum, notation, null);
                    } else {
                        // This case might occur after an undo/redo sequence. Update the existing entry.
                        console.warn("Updating Orange's move in existing turn entry:", turnNum);
                        currentTurnEntry.orange = notation;
                        // Update the DOM if it exists
                        if (existingLogDiv) {
                            let orangeSpan = existingLogDiv.querySelector('.log-orange, .placeholder');
                            if (orangeSpan) {
                                orangeSpan.textContent = notation;
                                orangeSpan.className = 'log-orange'; // Ensure correct class
                            }
                        } else {
                             // If DOM element missing unexpectedly, recreate it
                            addLogEntryToDOM(turnNum, notation, currentTurnEntry.yellow);
                        }
                    }
                } else { // Yellow moved
                    // Yellow always completes a turn entry initiated by Orange
                    if (currentTurnEntry) {
                        // Update the history entry
                        currentTurnEntry.yellow = notation;
                        // Update the DOM element
                        if (existingLogDiv) {
                            let yellowSpan = existingLogDiv.querySelector('.log-yellow');
                            // If yellow span doesn't exist yet, create it
                            if (!yellowSpan) {
                                yellowSpan = document.createElement('span');
                                existingLogDiv.appendChild(yellowSpan);
                            }
                            yellowSpan.textContent = notation;
                            yellowSpan.className = 'log-yellow'; // Ensure correct class
                        } else {
                            // Log error if DOM element is missing when it shouldn't be
                            console.error("Log div missing for Yellow's move in turn", turnNum);
                            // Attempt to recreate the full log entry
                            addLogEntryToDOM(turnNum, currentTurnEntry.orange || '...', notation);
                        }
                    } else {
                        // Log error if Yellow moves but no history entry exists (shouldn't happen)
                        console.error("Yellow moved but no history entry found for turn", turnNum);
                        // Create a new history entry anyway
                        currentTurnEntry = { turn: turnNum, orange: null, yellow: notation };
                        gameState.moveHistory.push(currentTurnEntry);
                        if (existingLogDiv) existingLogDiv.remove(); // Remove potentially incomplete DOM entry
                        addLogEntryToDOM(turnNum, null, notation); // Add correct entry
                    }
                }
                // Ensure log scrolls to bottom
                moveLogElement.scrollTop = moveLogElement.scrollHeight;
            }


            /**
             * Generates a unique string representation of the current board state.
             * Used for detecting repetitions. Format: "RankCoordsUpper/Lower,RankCoordsUpper/Lower,..." sorted alphabetically.
             * Example: "1a7,1g3,2b2,..." (Upper = Orange, Lower = Yellow)
             * @param {object} [board=gameState.board] - The board state to stringify. Defaults to current game state.
             * @returns {string} The sorted comma-separated string representation.
             */
            function getBoardStateString(board = gameState.board) {
                const pieces = [];
                // Get coordinates and sort them alphabetically/numerically for consistency
                const coordsList = Object.keys(board).sort((a, b) => {
                    // Sort primarily by column, then by row number descending
                    const colA = a.charCodeAt(0);
                    const colB = b.charCodeAt(0);
                    if (colA !== colB) return colA - colB;
                    const rowA = parseInt(a.substring(1));
                    const rowB = parseInt(b.substring(1));
                    return rowB - rowA; // Higher row number (e.g., 9) comes first
                });

                for (const coords of coordsList) {
                    const piece = board[coords];
                    if (piece) {
                        // Format: Rank followed by Coords. Uppercase coords for Orange, lowercase for Yellow.
                        const stateOutput = piece.player === PLAYERS.ORANGE ?
                            `${piece.rank}${coords.toUpperCase()}` : // e.g., 8A3
                            `${piece.rank}${coords.toLowerCase()}`; // e.g., 7a9
                        pieces.push(stateOutput);
                    }
                }
                // Final sort of the generated piece strings ensures the overall string is unique per state
                // pieces.sort(); // This secondary sort might be redundant if coordsList is sorted robustly
                return pieces.join(','); // Join with commas
            }

            /**
             * Parses a board state string into a board object suitable for gameState.board.
             * String format: "RankCoordsUpper/Lower,RankCoordsUpper/Lower,..." (e.g., "8A3,7G1,1a7")
             * Uppercase coords = Orange, Lowercase = Yellow.
             * @param {string} stateString - The board state string to parse.
             * @returns {object|null} A board object { coords: pieceData } or null if parsing fails.
             */
            function parseBoardStateString(stateString) {
                if (!stateString || typeof stateString !== 'string') {
                    console.error("Parse Error: Invalid input string.");
                    return null;
                }

                const parsedBoard = {};
                const pieceStrings = stateString.trim().split(',');
                const pieceRegex = /^([1-8])([a-gA-G][1-9])$/; // Matches Rank (1-8) and Coords (e.g., a1, G9)

                for (const pieceStr of pieceStrings) {
                    if (!pieceStr) continue; // Skip empty parts if trailing comma etc.
                    const match = pieceStr.match(pieceRegex);

                    if (!match) {
                        console.error(`Parse Error: Invalid piece format "${pieceStr}" in state string.`);
                        return null; // Invalid format for a piece
                    }

                    const rank = parseInt(match[1], 10);
                    const coordsRaw = match[2];
                    const coordsLower = coordsRaw.toLowerCase(); // Key for the board object is always lowercase

                    // Validate coordinates range after converting to lowercase
                    const rc = getRowCol(coordsLower);
                    if (!rc) {
                        console.error(`Parse Error: Invalid coordinates "${coordsRaw}" in state string.`);
                        return null;
                    }

                    // Determine player based on original case
                    const player = (coordsRaw === coordsRaw.toUpperCase()) ? PLAYERS.ORANGE : PLAYERS.YELLOW;

                    // Create piece data object
                    const pieceData = {
                        player: player,
                        rank: rank,
                        isHungry: false // Pieces always start not hungry when loading state
                    };

                    // Add special abilities based on rank
                    const abilities = SPECIAL_ABILITIES[rank];
                    if (abilities) {
                        pieceData.swims = abilities.swims || false;
                        pieceData.attacksElephant = abilities.attacksElephant || false;
                        pieceData.jumpH = abilities.jumpH || false;
                        pieceData.jumpV = abilities.jumpV || false;
                    } else {
                        pieceData.swims = false; pieceData.attacksElephant = false;
                        pieceData.jumpH = false; pieceData.jumpV = false;
                    }

                    // Check for duplicate piece placement
                    if (parsedBoard[coordsLower]) {
                         console.error(`Parse Error: Duplicate piece placement at "${coordsLower}" in state string.`);
                         return null;
                    }

                    parsedBoard[coordsLower] = pieceData;
                }

                // Basic sanity check: ensure at least one piece exists? (Optional)
                if (Object.keys(parsedBoard).length === 0 && stateString.length > 0) {
                     console.error("Parse Error: String provided but no valid pieces parsed.");
                     return null;
                }


                console.log("Successfully parsed board state:", parsedBoard);
                return parsedBoard;
            }

            /**
             * Logs the current board state string to the console and the board state log element.
             * Increments the count for this state in `gameState.boardStateHistory` unless restoring.
             * @param {boolean} [isRestoring=false] - If true, logs the state but doesn't increment the history count (used during undo).
             * @returns {string} The generated board state string.
             */
            function logBoardState(isRestoring = false) {
                const stateString = getBoardStateString();
                boardStateLogElement.textContent = stateString; // Display in UI

                if (!isRestoring) {
                    // Increment the count for this state in the history object
                    gameState.boardStateHistory[stateString] = (gameState.boardStateHistory[stateString] || 0) + 1;
                    console.log(`Board State (${gameState.boardStateHistory[stateString]}x):`, stateString);
                } else {
                    // Just log that the state was restored
                    console.log(`Restored Board State:`, stateString);
                }
                return stateString; // Return the generated string
            }

            /**
             * Shows or hides the "(0)" trap rank indicator on a piece's DOM element.
             * @param {string} coords - The coordinates of the piece.
             * @param {boolean} isTrapped - Whether the piece should show the trapped indicator.
             */
            function updateTrapIndicatorVisual(coords, isTrapped) {
                const pieceElement = document.getElementById(getPieceElementId(coords));
                if (!pieceElement) return; // Piece element might not exist (e.g., captured)

                // Find the indicator span within the piece element
                const indicatorSpan = pieceElement.querySelector('.trap-rank-indicator');
                if (!indicatorSpan) {
                    // This shouldn't happen if createPieceElement worked correctly, but add a safeguard
                    console.warn("Trap indicator span not found for piece at", coords);
                    return;
                }

                // Add or remove the 'visible' class based on the isTrapped flag
                if (isTrapped) {
                    indicatorSpan.classList.add('visible');
                } else {
                    indicatorSpan.classList.remove('visible');
                }
            }

            /**
             * Adds or removes the 'hungry' class from a piece's DOM element.
             * @param {string} coords - The coordinates of the piece.
             * @param {boolean} isHungry - Whether the piece should be marked as hungry.
             */
            function updateHungryVisual(coords, isHungry) {
                const pieceElement = document.getElementById(getPieceElementId(coords));
                if (pieceElement) {
                    if (isHungry) {
                        pieceElement.classList.add('hungry'); // Add dashed red outline
                    } else {
                        pieceElement.classList.remove('hungry'); // Remove outline
                    }
                }
            }


            // --- Highlighting & Visual Feedback ---

            /**
             * Highlights valid move and attack squares for a given piece.
             * Adds temporary highlight classes ('valid-move-highlight', 'valid-attack-highlight')
             * and, if `isSelection` is true, applies persistent visual styles ('valid-move', 'valid-attack').
             * @param {string} fromCoords - The coordinates of the piece whose moves to highlight.
             * @param {boolean} [isSelection=true] - If true, apply persistent styles (for click/drag selection).
             *                                      If false, only add highlight classes (for hover).
             */
            function highlightValidMoves(fromCoords, isSelection = true) {
                clearHighlights(); // Clear previous highlights first
                const piece = gameState.board[fromCoords];

                 // Don't highlight if no piece or (if selecting) it's not current player's piece
                if (!piece || (isSelection && piece.player !== gameState.currentPlayer)) return;

                // Get all potential destinations (geometrically possible)
                const destinations = getPotentialMoveDestinations(fromCoords, piece);

                destinations.forEach(toCoords => {
                    // Validate each potential move legally
                    const validation = isValidMove(fromCoords, toCoords, piece);
                    if (validation.valid) {
                        const cell = document.getElementById(getCellElementId(toCoords));
                        if (cell) {
                            // Add base highlight class (used by drag enter/touch move)
                            cell.classList.add('valid-move-highlight');
                            // Check if it's an attack
                            if (gameState.board[toCoords]) { // Is there an opponent piece?
                                cell.classList.add('valid-attack-highlight'); // Mark as potential attack
                                if (isSelection) cell.classList.add('valid-attack'); // Apply red style if selecting
                            } else {
                                // It's a non-attack move
                                if (isSelection) cell.classList.add('valid-move'); // Apply green style if selecting
                            }
                            // Make valid destination cells focusable via keyboard nav
                             cell.setAttribute('tabindex', '0');
                        }
                    }
                });

                // If this is a selection (not just hover), mark the source piece as selected
                if (isSelection) {
                    const pieceEl = document.getElementById(getPieceElementId(fromCoords));
                    if (pieceEl) pieceEl.classList.add('selected');
                }
            }

            /**
             * Removes all move/attack highlights and selection styles from cells and pieces.
             * Resets cell tabindex attributes.
             */
            function clearHighlights() {
                // Remove highlight classes from all cells
                boardGridWrapper.querySelectorAll('.cell').forEach(cell => {
                    cell.classList.remove('valid-move', 'valid-attack', 'valid-move-highlight', 'valid-attack-highlight');
                     // Reset tabindex for cells (only valid moves should be tabbable temporarily)
                    cell.setAttribute('tabindex', '-1');
                });

                // If no piece is currently selected, remove selection style from any piece that might have it
                if (!selectedPieceCoords) {
                    boardGridWrapper.querySelectorAll('.piece.selected').forEach(p => p.classList.remove('selected'));
                }
                // Ensure pieces' tabindex is correctly set (only current player's pieces should be 0)
                 updateAllPieceAccessibility();

                 // Restore tabindex=0 for the currently focused element if focus wasn't lost
                if (focusedCoords) {
                    let focusedEl = document.getElementById(getCellElementId(focusedCoords)) || document.getElementById(getPieceElementId(focusedCoords));
                     // Check if the focused element should indeed be focusable
                     const shouldBeFocusable = focusedEl?.classList.contains('piece') && focusedEl?.dataset.player === gameState.currentPlayer && !gameState.gameOver;
                    if (focusedEl && shouldBeFocusable) {
                        focusedEl.setAttribute('tabindex', '0');
                    } else if (focusedEl && !focusedEl.classList.contains('piece')) {
                         // Cells generally aren't focusable unless a valid move target
                         focusedEl.setAttribute('tabindex', '-1');
                    }
                }
            }


            /**
             * Briefly flashes the background color of a cell for visual feedback.
             * @param {string} coords - The coordinates of the cell to flash.
             * @param {string} [color='red'] - The color to flash ('red' or 'green').
             * @param {number} [duration=300] - The total duration of the flash in milliseconds.
             */
            function flashCell(coords, color = 'red', duration = 300) {
                const cell = document.getElementById(getCellElementId(coords));
                if (cell) {
                    const originalTransition = cell.style.transition; // Store original transition
                    // Apply flash color quickly
                    cell.style.transition = `background-color ${duration / 2}ms ease-out`;
                    cell.style.backgroundColor = color === 'red' ? 'rgba(255,0,0,0.5)' : 'rgba(0,255,0,0.5)';
                    // After half the duration, start fading back to original
                    setTimeout(() => {
                        cell.style.backgroundColor = ''; // Remove inline style, revert to CSS background
                        // After fade out, restore original transition property
                        setTimeout(() => {
                            cell.style.transition = originalTransition;
                         }, 50); // Small delay to ensure background removal registers before transition change
                    }, duration / 2);
                }
            }

            /**
             * Highlights the starting and ending squares of the AI's last move.
             */
            function highlightAILastMove() {
                clearAILastMoveHighlight(); // Clear previous highlights first
                if (aiLastMove.from && aiLastMove.to) {
                    const fromCell = document.getElementById(getCellElementId(aiLastMove.from));
                    const toCell = document.getElementById(getCellElementId(aiLastMove.to));
                    if (fromCell) fromCell.classList.add('ai-move-from'); // Apply light blue bg
                    if (toCell) toCell.classList.add('ai-move-to'); // Apply darker blue bg
                }
            }

            /**
             * Removes the visual highlighting from the AI's last move squares.
             */
            function clearAILastMoveHighlight() {
                boardGridWrapper.querySelectorAll('.cell.ai-move-from, .cell.ai-move-to').forEach(cell => {
                    cell.classList.remove('ai-move-from', 'ai-move-to');
                });
            }


            // --- Event Listeners Setup ---
            resetButton.addEventListener('click', () => initializeGame()); // Reset with default setup
            undoButton.addEventListener('click', undoMove); // Undo move on button click

            // --- Load State Button Listener ---
            const loadStateButton = document.getElementById('load-state-button');
            const boardStateInput = document.getElementById('board-state-input');
            const loadStatusMessage = document.getElementById('load-status-message');

            if (loadStateButton && boardStateInput && loadStatusMessage) {
                loadStateButton.addEventListener('click', () => {
                    const stateString = boardStateInput.value.trim();
                    if (!stateString) {
                        loadStatusMessage.textContent = "Please paste a state string first.";
                        loadStatusMessage.style.color = 'red';
                        return;
                    }

                    // Attempt to parse the string
                    const parsedBoard = parseBoardStateString(stateString);

                    if (parsedBoard) {
                        // If parsing successful, initialize the game with this board
                        initializeGame(parsedBoard); // Pass the parsed board to initializeGame
                        loadStatusMessage.textContent = "Board state loaded successfully!";
                        loadStatusMessage.style.color = '#28a745'; // Green color for success
                        boardStateInput.value = ''; // Clear the input field on success
                        updateStatus("Loaded custom state. Orange to move."); // Update main status
                    } else {
                        // If parsing failed, show an error message
                        loadStatusMessage.textContent = "Invalid state string format. Please check console for details.";
                        loadStatusMessage.style.color = 'red'; // Red color for error
                        // Optionally flash the input border red
                        boardStateInput.style.borderColor = 'red';
                        setTimeout(() => { boardStateInput.style.borderColor = 'var(--medium-gray)'; }, 2000);
                    }
                });
            } else {
                console.error("Could not find Load State button, input field, or status message element.");
            }
            // --- End Load State Button Listener ---

            // --- Accordion Logic ---
            const rulesButton = document.getElementById('rules-toggle-button');
            const rulesContent = document.getElementById('rules-content');

            if (rulesButton && rulesContent) {
                rulesButton.addEventListener('click', () => {
                    const isExpanded = rulesButton.getAttribute('aria-expanded') === 'true';

                    // Toggle ARIA attributes
                    rulesButton.setAttribute('aria-expanded', !isExpanded);
                    rulesContent.setAttribute('aria-hidden', isExpanded);

                    // Toggle visual state (classes and max-height)
                    rulesButton.classList.toggle('active');
                    rulesContent.classList.toggle('expanded'); // Toggle padding via class

                    if (!isExpanded) {
                        // Expand: Set max-height to content's scroll height
                        rulesContent.style.maxHeight = rulesContent.scrollHeight + 'px';
                        rulesButton.querySelector('.rules-button-text').textContent = 'Hide Game Rules';
                    } else {
                        // Collapse: Set max-height back to 0 (or null)
                        rulesContent.style.maxHeight = null; // Use null to revert to CSS value (0)
                        rulesButton.querySelector('.rules-button-text').textContent = 'Show Game Rules';
                    }
                });
            } else {
                console.warn("Rules accordion button or content not found.");
            }
            // --- End Accordion Logic ---

            // --- Initial Game Setup ---
            console.log("Initializing Clesto Game...");
            initializeGame(); // Start the game when the DOM is ready
            console.log("Game setup complete. Board and UI ready.");

        }); // End DOMContentLoaded event listener
    </script>

</body>

</html>