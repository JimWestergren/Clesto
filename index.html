<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CLESTO: The Jungle Chess Game</title>
    <style>
        /* --- General Styling --- */
        :root {
            --orange-color: #E67E22;
            --yellow-color: #F1C40F;
            --dark-orange: #D35400;
            --dark-yellow: #F39C12;
            --light-gray: #f8f9fa;
            --medium-gray: #dee2e6;
            --dark-gray: #343a40;
            --cell-highlight-move: rgba(0, 255, 0, 0.7);
            --cell-highlight-attack: rgba(255, 0, 0, 0.7);
            --piece-select-glow: rgba(0, 191, 255, 0.9);
            --hungry-outline: rgba(255, 0, 0, 0.8);
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: var(--light-gray);
            color: var(--dark-gray);
            padding: 20px;
            margin: 0;
        }

        h1 {
            margin-bottom: 20px;
            color: var(--dark-gray);
            font-weight: 300;
            border-bottom: 1px solid var(--medium-gray);
            padding-bottom: 10px;
        }

        #game-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 30px; /* Increased gap */
            margin-top: 10px;
        }

        /* --- Board Styling --- */
        #board {
            width: 490px; /* 70px * 7 columns */
            height: 630px; /* 70px * 9 rows */
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            grid-template-rows: repeat(9, 1fr);
            border: none;
            position: relative;
            background-image: url('https://staticjw.com/clesto/board.png');
            background-size: cover;
            background-position: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15); /* Added shadow */
            border-radius: 5px; /* Slight rounding */
        }

        .cell {
            width: 70px;
            height: 70px;
            border: none;
            box-sizing: border-box;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.6em; /* Smaller coordinates */
            color: rgba(0, 0, 0, 0.3); /* Darker faint coordinates */
            user-select: none;
            background-clip: padding-box;
            /* transition for highlight effects */
            transition: background-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }

        /* --- Special Cell Styling (Overlays with ::before) --- */
        .cell::before {
             content: ''; position: absolute; top:0; left:0; width: 100%; height: 100%;
             pointer-events: none; box-sizing: border-box; border-radius: inherit;
             opacity: 0.8; /* Slightly reduce overlay opacity */
        }
        .water::before { background-color: rgba(100, 150, 255, 0.3); }
        .trap-orange::before { background-color: rgba(255, 150, 150, 0.3); border: 2px dashed var(--hungry-outline); }
        .trap-yellow::before { background-color: rgba(255, 255, 150, 0.3); border: 2px dashed var(--dark-yellow); }
        .den-orange::before { background-color: rgba(255, 100, 0, 0.4); border: 3px solid var(--dark-orange); }
        .den-yellow::before { background-color: rgba(255, 255, 0, 0.4); border: 3px solid var(--dark-yellow); }


        /* --- Piece Styling (for Image Tokens) --- */
        .piece {
            width: 55px;
            height: 55px;
            position: absolute;
            cursor: grab;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.25); /* Softer shadow */
            z-index: 10;
            transition: transform 0.15s ease-out, box-shadow 0.2s ease, outline 0.2s ease; /* Smooth transitions */
            user-select: none;
            overflow: hidden;
            background: none;
            border: none;
            border-radius: 50%; /* Make pieces circular */
        }

        .piece img {
            max-width: 100%;
            max-height: 100%;
            display: block;
            pointer-events: none;
            border-radius: 50%; /* Ensure image inside is also round */
        }

        .piece.dragging {
            opacity: 0.6;
            cursor: grabbing;
            z-index: 100;
            transform: scale(1.1); /* Slightly enlarge while dragging */
             box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        /* --- Visual Feedback on Cells and Pieces --- */
        .valid-move {
            box-shadow: inset 0 0 0 3px var(--cell-highlight-move);
            background-color: rgba(0, 255, 0, 0.1); /* Subtler tint */
        }
        .valid-attack {
            box-shadow: inset 0 0 0 3px var(--cell-highlight-attack);
            background-color: rgba(255, 0, 0, 0.1); /* Subtler tint */
        }
        .selected {
            box-shadow: 0 0 0 4px var(--piece-select-glow); /* Use border-like shadow */
            /* border: 1px solid var(--piece-select-glow); REMOVED */
        }
        .hungry {
             outline: 3px dashed var(--hungry-outline);
             outline-offset: 2px; /* More offset */
        }

        /* --- UI Info Panel --- */
        #ui-info {
            width: 300px; /* Wider */
            border: none; /* Remove border */
            padding: 20px;
            background-color: #ffffff; /* White background */
            height: fit-content;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1); /* Consistent shadow */
            border-radius: 8px; /* More rounded */
            display: flex;
            flex-direction: column;
        }
        #ui-info h2, #ui-info h3 {
            margin-top: 0;
            margin-bottom: 15px; /* Increased spacing */
            border-bottom: 1px solid var(--medium-gray);
            padding-bottom: 8px;
            font-weight: 400; /* Lighter headings */
            color: var(--dark-gray);
        }
         #ui-info h3 {
             margin-top: 15px; /* Add space above logs */
         }
        #ui-info p {
            margin: 10px 0;
            line-height: 1.5;
        }
        #turn-indicator {
            font-weight: 600; /* Bold */
            padding: 3px 6px;
            border-radius: 4px;
            color: white;
        }
        #turn-indicator.orange { background-color: var(--orange-color); }
        #turn-indicator.yellow { background-color: var(--yellow-color); color: var(--dark-gray);}
        #turn-indicator.game-over { background-color: #dc3545; } /* Red for game over */

        /* Buttons */
         .button-container {
             margin-top: auto; /* Push buttons to bottom */
             padding-top: 20px; /* Space above buttons */
             display: flex;
             gap: 10px; /* Space between buttons */
             justify-content: space-around;
         }
        .game-button { /* Common style for buttons */
            padding: 10px 18px;
            cursor: pointer;
            border-radius: 5px;
            border: none;
            font-size: 0.95em;
            transition: background-color 0.2s ease, box-shadow 0.2s ease;
            background-color: #6c757d; /* Default gray */
            color: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .game-button:hover {
             box-shadow: 0 3px 6px rgba(0,0,0,0.15);
        }
        #reset-button {
            background-color: #007bff; /* Blue */
        }
        #reset-button:hover { background-color: #0056b3; }
        #undo-button {
            background-color: #ffc107; /* Yellow/Amber */
            color: var(--dark-gray);
        }
        #undo-button:hover { background-color: #e0a800; }
        #undo-button:disabled {
             background-color: #adb5bd; /* Disabled gray */
             cursor: not-allowed;
             box-shadow: none;
        }


        /* Move Log Styling */
        #move-log {
            height: 220px; /* Slightly taller */
            overflow-y: auto; /* Use auto instead of scroll */
            border: 1px solid var(--medium-gray);
            border-radius: 5px; /* Rounded log */
            padding: 8px 10px;
            margin-top: 10px;
            font-size: 0.9em;
            background-color: #ffffff;
            line-height: 1.6; /* Better readability */
        }
        .log-entry {
             padding: 3px 0;
             border-bottom: 1px dashed var(--medium-gray); /* Separator */
        }
         .log-entry:last-child {
             border-bottom: none;
         }
         .log-entry .turn-number {
             display: inline-block;
             width: 25px; /* Align turn numbers */
             font-weight: bold;
             color: #6c757d;
             margin-right: 5px;
         }
         .log-entry .log-orange,
         .log-entry .log-yellow {
             display: inline-block;
             min-width: 60px; /* Ensure some space */
             padding: 2px 5px;
             border-radius: 3px;
             margin: 0 3px;
             text-align: center;
         }
         .log-entry .log-orange {
             background-color: rgba(230, 126, 34, 0.15); /* Light orange bg */
             color: var(--dark-orange);
             border: 1px solid rgba(230, 126, 34, 0.3);
         }
         .log-entry .log-yellow {
             background-color: rgba(241, 196, 15, 0.15); /* Light yellow bg */
             color: #c78b02; /* Darker yellow text */
              border: 1px solid rgba(241, 196, 15, 0.3);
         }
         .log-entry .placeholder { /* Style for '...' */
             color: #adb5bd;
             font-style: italic;
             display: inline-block;
             min-width: 60px;
             text-align: center;
         }

        /* Board State Log */
        #board-state-log {
            margin-top: 10px;
            border: 1px solid var(--medium-gray);
            border-radius: 5px;
            padding: 10px;
            font-size: 0.75em; /* Smaller font */
            font-family: monospace; /* Monospace for better alignment if needed */
            word-wrap: break-word;
            background-color: #ffffff;
            max-height: 90px;
            overflow-y: auto;
            line-height: 1.4;
        }

    </style>
</head>
<body>

    <h1>CLESTO: The Jungle Chess Game</h1>

    <div id="game-container">
        <div id="board">
            <!-- Cells will be generated by JavaScript -->
        </div>
        <div id="ui-info">
            <h2>Game Info</h2>
            <p>Turn: <span id="turn-indicator">Orange</span></p>
            <p>Status: <span id="status-message">Loading...</span></p>

            <h3>Move Log</h3>
            <div id="move-log"></div>

            <h3>Board State</h3>
            <div id="board-state-log"></div>

             <!-- Button Container -->
             <div class="button-container">
                <button id="undo-button" class="game-button" disabled>Undo Move</button>
                <button id="reset-button" class="game-button">Reset Game</button>
             </div>
        </div>
    </div>

    <!-- Piece image assets -->
    <div id="piece-assets" style="display: none;">
        <!-- Orange Pieces -->
        <img data-piece="O_8" src="https://staticjw.com/clesto/animals/elephant-orange.png" alt="Orange Elephant (8)">
        <img data-piece="O_7" src="https://staticjw.com/clesto/animals/lion-orange.png" alt="Orange Lion (7)">
        <img data-piece="O_6" src="https://staticjw.com/clesto/animals/tiger-orange.png" alt="Orange Tiger (6)">
        <img data-piece="O_5" src="https://staticjw.com/clesto/animals/leopard-orange.png" alt="Orange Leopard (5)">
        <img data-piece="O_4" src="https://staticjw.com/clesto/animals/dog-orange.png" alt="Orange Dog (4)">
        <img data-piece="O_3" src="https://staticjw.com/clesto/animals/cat-orange.png" alt="Orange Cat (3)">
        <img data-piece="O_2" src="https://staticjw.com/clesto/animals/wolf-orange.png" alt="Orange Wolf (2)">
        <img data-piece="O_1" src="https://staticjw.com/clesto/animals/rat-orange.png" alt="Orange Rat (1)">

        <!-- Yellow Pieces -->
        <img data-piece="Y_8" src="https://staticjw.com/clesto/animals/elephant-yellow.png" alt="Yellow Elephant (8)">
        <img data-piece="Y_7" src="https://staticjw.com/clesto/animals/lion-yellow.png" alt="Yellow Lion (7)">
        <img data-piece="Y_6" src="https://staticjw.com/clesto/animals/tiger-yellow.png" alt="Yellow Tiger (6)">
        <img data-piece="Y_5" src="https://staticjw.com/clesto/animals/leopard-yellow.png" alt="Yellow Leopard (5)">
        <img data-piece="Y_4" src="https://staticjw.com/clesto/animals/dog-yellow.png" alt="Yellow Dog (4)">
        <img data-piece="Y_3" src="https://staticjw.com/clesto/animals/cat-yellow.png" alt="Yellow Cat (3)">
        <img data-piece="Y_2" src="https://staticjw.com/clesto/animals/wolf-yellow.png" alt="Yellow Wolf (2)">
        <img data-piece="Y_1" src="https://staticjw.com/clesto/animals/rat-yellow.png" alt="Yellow Rat (1)">
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM Elements ---
            const boardElement = document.getElementById('board');
            const turnIndicator = document.getElementById('turn-indicator');
            const statusMessage = document.getElementById('status-message');
            const resetButton = document.getElementById('reset-button');
            const undoButton = document.getElementById('undo-button'); // Get Undo button
            const moveLogElement = document.getElementById('move-log');
            const boardStateLogElement = document.getElementById('board-state-log');
            const pieceAssetContainer = document.getElementById('piece-assets');

            // --- Constants ---
            const ROWS = 9;
            const COLS = 7;
            const CELL_SIZE_W = 70;
            const CELL_SIZE_H = 70;
            const PIECE_SIZE_W = 55;
            const PIECE_SIZE_H = 55;
            const PLAYERS = { ORANGE: 'orange', YELLOW: 'yellow' };
            const RANK_TO_NAME = { 8: 'Elephant', 7: 'Lion', 6: 'Tiger', 5: 'Leopard', 4: 'Dog', 3: 'Cat', 2: 'Wolf', 1: 'Rat'};
            const RANK_TO_CODE = { 8: '8', 7: '7', 6: '6', 5: '5', 4: '4', 3: '3', 2: '2', 1: '1' };
             const SPECIAL_ABILITIES = {
                1: { name: 'Rat', rank: 1, swims: true, attacksElephant: true }, 2: { name: 'Wolf', rank: 2 },
                3: { name: 'Cat', rank: 3 }, 4: { name: 'Dog', rank: 4, swims: true },
                5: { name: 'Leopard', rank: 5, jumpH: true }, 6: { name: 'Tiger', rank: 6, jumpH: true, jumpV: true },
                7: { name: 'Lion', rank: 7, jumpH: true, jumpV: true }, 8: { name: 'Elephant', rank: 8 }
            };
            const INITIAL_SETUP = { /* ... same as before ... */
                'a3': { player: PLAYERS.ORANGE, rank: 8 }, 'g1': { player: PLAYERS.ORANGE, rank: 7 },
                'a1': { player: PLAYERS.ORANGE, rank: 6 }, 'e3': { player: PLAYERS.ORANGE, rank: 5 },
                'f2': { player: PLAYERS.ORANGE, rank: 4 }, 'c3': { player: PLAYERS.ORANGE, rank: 3 },
                'b2': { player: PLAYERS.ORANGE, rank: 2 }, 'g3': { player: PLAYERS.ORANGE, rank: 1 },
                'g7': { player: PLAYERS.YELLOW, rank: 8 }, 'a9': { player: PLAYERS.YELLOW, rank: 7 },
                'g9': { player: PLAYERS.YELLOW, rank: 6 }, 'c7': { player: PLAYERS.YELLOW, rank: 5 },
                'b8': { player: PLAYERS.YELLOW, rank: 4 }, 'e7': { player: PLAYERS.YELLOW, rank: 3 },
                'f8': { player: PLAYERS.YELLOW, rank: 2 }, 'a7': { player: PLAYERS.YELLOW, rank: 1 }
             };
            const WATER_SQUARES = new Set(['b4', 'c4', 'e4', 'f4', 'b5', 'c5', 'e5', 'f5', 'b6', 'c6', 'e6', 'f6']);
            const TRAPS = { orange: new Set(['c9', 'd8', 'e9']), yellow: new Set(['c1', 'd2', 'e1']) };
            const ALL_TRAP_SQUARES = new Set([...TRAPS.orange, ...TRAPS.yellow]);
            const DENS = { orange: 'd1', yellow: 'd9' };

            // --- Game State Variables ---
            let gameState = {};
            let gameHistory = []; // Array to store previous game states for undo

            // --- Helper Functions (getCoords, getRowCol, getPieceData, getPieceElementId, getCellElementId) ---
            // ... (Keep these exactly the same as your previous version) ...
             function getCoords(row, col) { if (row < 0 || row >= ROWS || col < 0 || col >= COLS) return null; return `${String.fromCharCode(97 + col)}${ROWS - row}`; }
             function getRowCol(coords) { if (!coords || coords.length < 2) return null; const col = coords.charCodeAt(0) - 97; const rowNum = parseInt(coords.substring(1)); if (isNaN(rowNum)) return null; const row = ROWS - rowNum; if (row < 0 || row >= ROWS || col < 0 || col >= COLS) return null; return { row, col }; }
             function getPieceData(coords) { return gameState.board[coords] || null; }
             function getPieceElementId(coords) { return `piece-${coords}`; }
             function getCellElementId(coords) { return `cell-${coords}`; }

            // --- Board Creation ---
            function createBoard() { /* ... same as before ... */
                 boardElement.innerHTML = '';
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        const cell = document.createElement('div');
                        const coords = getCoords(r, c);
                        cell.id = getCellElementId(coords);
                        cell.classList.add('cell');
                        cell.dataset.coords = coords; cell.dataset.row = r; cell.dataset.col = c;
                        if (WATER_SQUARES.has(coords)) cell.classList.add('water');
                        if (TRAPS.orange.has(coords)) cell.classList.add('trap-yellow');
                        if (TRAPS.yellow.has(coords)) cell.classList.add('trap-orange');
                        if (DENS.orange === coords) cell.classList.add('den-orange');
                        if (DENS.yellow === coords) cell.classList.add('den-yellow');
                        boardElement.appendChild(cell);
                        cell.addEventListener('dragover', handleDragOver);
                        cell.addEventListener('dragenter', handleDragEnter);
                        cell.addEventListener('dragleave', handleDragLeave);
                        cell.addEventListener('drop', handleDrop);
                    }
                }
            }

            // --- Piece Creation & Placement ---
            function createPieceElement(pieceData, coords) { /* ... same as before, including border-radius fix */
                const pieceElement = document.createElement('div');
                pieceElement.id = getPieceElementId(coords);
                pieceElement.classList.add('piece');
                pieceElement.dataset.rank = pieceData.rank; pieceElement.dataset.player = pieceData.player;
                pieceElement.dataset.coords = coords; pieceElement.draggable = true;
                const pieceKey = `${pieceData.player === PLAYERS.ORANGE ? 'O' : 'Y'}_${pieceData.rank}`;
                const asset = pieceAssetContainer.querySelector(`[data-piece="${pieceKey}"]`);
                if (asset && asset.tagName === 'IMG') {
                    const img = asset.cloneNode(true); img.style.display = 'block';
                    pieceElement.appendChild(img); pieceElement.style.background = 'none'; pieceElement.style.border = 'none';
                    // pieceElement.style.borderRadius = '50%'; // Already applied via CSS .piece rule
                } else {
                    console.warn("Image asset not found for:", pieceKey);
                    pieceElement.textContent = `${pieceData.player === PLAYERS.ORANGE ? 'O' : 'Y'}${pieceData.rank}`;
                    pieceElement.classList.add(pieceData.player); // Add color class for fallback text
                }
                pieceElement.addEventListener('dragstart', handleDragStart);
                pieceElement.addEventListener('dragend', handleDragEnd);
                return pieceElement;
            }
            function placePieces() { /* ... same as before ... */
                document.querySelectorAll('.piece').forEach(p => p.remove());
                for (const coords in gameState.board) {
                    if (gameState.board.hasOwnProperty(coords)) {
                        const pieceData = gameState.board[coords];
                        if (!pieceData) { console.warn(`Attempted to place null piece at ${coords}`); continue; }
                        const pieceElement = createPieceElement(pieceData, coords);
                        positionElementOnBoard(pieceElement, coords);
                        boardElement.appendChild(pieceElement);
                        updateHungryVisual(coords, pieceData.isHungry || false);
                    }
                }
            }
            function positionElementOnBoard(element, coords) { /* ... same as before ... */
                const rc = getRowCol(coords); if (!rc) { console.error("Cannot position element, invalid coords:", coords); return; }
                const { row, col } = rc;
                const x = col * CELL_SIZE_W + (CELL_SIZE_W - PIECE_SIZE_W) / 2;
                const y = row * CELL_SIZE_H + (CELL_SIZE_H - PIECE_SIZE_H) / 2;
                element.style.left = `${x}px`; element.style.top = `${y}px`;
                element.dataset.coords = coords;
            }

            // --- Game State Save/Load for Undo ---
            function saveGameState() {
                 // Create a deep copy of the relevant parts of the gameState
                 const stateToSave = {
                      board: JSON.parse(JSON.stringify(gameState.board)),
                      currentPlayer: gameState.currentPlayer,
                      turnNumber: gameState.turnNumber,
                      // We don't need to save boardStateHistory for undo, it's for repetition check
                      // We also don't strictly need moveHistory for undo, but keep it for log consistency
                      moveHistory: JSON.parse(JSON.stringify(gameState.moveHistory)),
                      gameOver: gameState.gameOver,
                      winner: gameState.winner
                 };
                  // Also save hunger state explicitly if not perfectly inferrable
                  // Note: The board object already contains isHungry flags, so it's saved.

                 gameHistory.push(stateToSave);
                 updateUndoButtonState(); // Enable undo after first move
            }

            function loadGameState(stateToLoad) {
                if (!stateToLoad) return;
                // Restore the game state properties
                gameState.board = stateToLoad.board; // Already deep copied when saved
                gameState.currentPlayer = stateToLoad.currentPlayer;
                gameState.turnNumber = stateToLoad.turnNumber;
                gameState.moveHistory = stateToLoad.moveHistory; // Restore move history for log
                gameState.gameOver = stateToLoad.gameOver;
                gameState.winner = stateToLoad.winner;

                 // Recalculate boardStateHistory up to this point if needed for perfect repetition check after undo
                 // Simple approach: Clear future history. Repetition check will work going forward.
                 // More complex: Rebuild history (skipped for now)
                  gameState.boardStateHistory = {}; // Reset repetition counts from this point back
                  rebuildBoardStateHistoryFromMoveHistory(); // Rebuild based on restored history


                // --- Update UI and Board based on loaded state ---
                placePieces(); // Redraw pieces based on restored board state
                rebuildMoveLog(); // Rebuild visual log from restored moveHistory
                updateUI(); // Update turn indicator etc.
                logBoardState(); // Log the restored state string
                updateStatus(`${gameState.currentPlayer.toUpperCase()}'s turn.`); // Update status message
                enableDragDrop(); // Ensure interaction is possible
                 updateUndoButtonState(); // Update button state
                 clearHighlights();
            }

             function rebuildMoveLog() {
                 moveLogElement.innerHTML = ''; // Clear visual log
                 gameState.moveHistory.forEach(entry => {
                      addLogEntry(entry.turn, entry.orange, entry.yellow);
                 });
                 moveLogElement.scrollTop = moveLogElement.scrollHeight; // Scroll to bottom
             }

             function rebuildBoardStateHistoryFromMoveHistory() {
                 // This function would simulate moves from start based on history to rebuild
                 // the boardStateHistory counts correctly. For simplicity, we skip this
                 // and just reset it. The repetition rule will function correctly going forward
                 // from the undone state, but might miss a 3-fold repetition that occurred
                 // across the undo boundary if not rebuilt fully.
                 // Simple reset is done in loadGameState.
                 console.log("Board state history reset after undo.");
             }


            // --- Game Initialization ---
            function initializeGame() {
                console.log("Initializing game...");
                gameState = {
                    board: JSON.parse(JSON.stringify(INITIAL_SETUP)),
                    currentPlayer: PLAYERS.ORANGE,
                    turnNumber: 1,
                    moveHistory: [], // Log structure: { turn, orange, yellow }
                    boardStateHistory: {}, // For repetition: { stateString: count }
                    gameOver: false,
                    winner: null
                };
                gameHistory = []; // Clear undo history

                Object.keys(gameState.board).forEach(coords => { /* Add abilities and isHungry=false */
                     const piece = gameState.board[coords]; piece.isHungry = false;
                     const abilities = SPECIAL_ABILITIES[piece.rank];
                     if (abilities) { piece.swims = abilities.swims || false; piece.attacksElephant = abilities.attacksElephant || false; piece.jumpH = abilities.jumpH || false; piece.jumpV = abilities.jumpV || false; }
                     else { piece.swims = false; piece.attacksElephant = false; piece.jumpH = false; piece.jumpV = false; }
                });

                createBoard(); placePieces();
                moveLogElement.innerHTML = ''; boardStateLogElement.textContent = '';
                updateStatus("Game Started. Orange to move.");
                updateUI(); clearHighlights();
                logBoardState(); // Log initial state & add to repetition history
                enableDragDrop();
                 updateUndoButtonState(); // Initially disabled
                console.log("Game Initialized. Orange starts.");
            }

            // --- Drag and Drop Handlers (handleDragStart, handleDragEnd, handleDragOver, handleDragEnter, handleDragLeave, handleDrop) ---
            // ... (Keep these exactly the same as your corrected version from previous step) ...
             let draggedPieceElement = null; let sourceCoords = null;
             function handleDragStart(e) { const pieceDiv = e.target.closest('.piece'); if (!pieceDiv) return; const player = pieceDiv.dataset.player; if (player !== gameState.currentPlayer || gameState.gameOver) { e.preventDefault(); return; } draggedPieceElement = pieceDiv; sourceCoords = draggedPieceElement.dataset.coords; setTimeout(() => draggedPieceElement.classList.add('dragging'), 0); e.dataTransfer.effectAllowed = 'move'; highlightValidMoves(sourceCoords); draggedPieceElement.classList.add('selected'); }
             function handleDragEnd(e) { if (draggedPieceElement) { draggedPieceElement.classList.remove('dragging', 'selected'); } draggedPieceElement = null; sourceCoords = null; clearHighlights(); }
             function handleDragOver(e) { e.preventDefault(); e.dataTransfer.dropEffect = 'move'; }
             function handleDragEnter(e) { e.preventDefault(); const targetCell = e.target.closest('.cell'); if (!targetCell) return; if (targetCell.classList.contains('valid-move-highlight')) { if (targetCell.classList.contains('valid-attack-highlight')) { targetCell.classList.add('valid-attack'); } else { targetCell.classList.add('valid-move'); } } }
             function handleDragLeave(e) { const targetCell = e.target.closest('.cell'); if (targetCell) { targetCell.classList.remove('valid-move', 'valid-attack'); } }
             function handleDrop(e) { e.preventDefault(); if (!draggedPieceElement) { clearHighlights(); return; } const targetCell = e.target.closest('.cell'); if (!targetCell || !targetCell.classList.contains('valid-move-highlight')) { console.log("Drop on invalid target."); updateStatus("Invalid move destination."); clearHighlights(); return; } const targetCoords = targetCell.dataset.coords; clearHighlights(); console.log(`Performing move from ${sourceCoords} to ${targetCoords}`); performMove(sourceCoords, targetCoords); }
             function enableDragDrop() { boardElement.style.pointerEvents = 'auto'; }
             function disableDragDrop() { boardElement.style.pointerEvents = 'none'; }


            // --- Move Logic ---
            function performMove(fromCoords, toCoords) {
                 // 0. Save current state BEFORE making changes (for undo)
                 saveGameState();

                const piece = getPieceData(fromCoords);
                 if (!piece || piece.player !== gameState.currentPlayer || gameState.gameOver) { console.error("Invalid move attempt."); updateStatus("Cannot move now."); gameHistory.pop(); updateUndoButtonState(); return; } // Pop invalid state save
                const validationResult = isValidMove(fromCoords, toCoords, piece);
                if (!validationResult.valid) { console.log(`Invalid move: ${validationResult.reason}`); updateStatus(`Invalid move: ${validationResult.reason}`); flashCell(toCoords, 'red'); gameHistory.pop(); updateUndoButtonState(); return; } // Pop invalid state save

                // --- Move is Valid ---
                const targetPiece = getPieceData(toCoords);
                const isAttack = !!targetPiece;
                const playerWhoMoved = gameState.currentPlayer; // Store who is moving NOW
                let notation = `${RANK_TO_CODE[piece.rank]}`;
                let statusAction = "";

                // 1. Starvation Check
                const starvedPiecesCoords = checkAndApplyStarvation(fromCoords, isAttack);

                // 2. Update Board State (Internal)
                if (isAttack) { console.log(`${piece.player}... captures ...`); notation += 'x'; statusAction = ` captures ${RANK_TO_NAME[targetPiece.rank]} at ${toCoords}`; delete gameState.board[toCoords]; }
                gameState.board[toCoords] = piece; delete gameState.board[fromCoords];

                // 3. Update DOM (Visual)
                if (isAttack) { const capturedElement = document.getElementById(getPieceElementId(toCoords)); if (capturedElement) capturedElement.remove(); }
                const pieceElement = document.getElementById(getPieceElementId(fromCoords));
                if (pieceElement) { pieceElement.id = getPieceElementId(toCoords); positionElementOnBoard(pieceElement, toCoords); }
                else { console.error("!!! Piece element not found", fromCoords); placePieces(); }

                // 4. Finalize Notation
                notation += toCoords;

                // 5. Check Win Condition
                const opponentDen = playerWhoMoved === PLAYERS.ORANGE ? DENS.yellow : DENS.orange;
                if (toCoords === opponentDen) {
                    gameState.winner = playerWhoMoved; gameState.gameOver = true;
                    updateStatus(`${playerWhoMoved.toUpperCase()} wins by reaching the den!${statusAction}`);
                    disableDragDrop(); logMove(notation, playerWhoMoved); logBoardState(); updateUI(); updateUndoButtonState(); return; // GAME OVER
                }

                // 6. Hungry Declaration
                 const opponent = playerWhoMoved === PLAYERS.ORANGE ? PLAYERS.YELLOW : PLAYERS.ORANGE;
                 const { hungryCount, hungryPiecesMap } = declareHungryAnimals(opponent);
                 Object.keys(gameState.board).forEach(coords => { // Update hunger state for *next* turn
                      const p = gameState.board[coords]; if (!p) return; // Piece might have been captured
                      const isNowHungry = !!hungryPiecesMap[coords];
                      p.isHungry = isNowHungry;
                      updateHungryVisual(coords, isNowHungry);
                 });
                 if (hungryCount > 0) { notation += '+'.repeat(hungryCount); }

                // 7. Starvation Notation
                notation += 'x'.repeat(starvedPiecesCoords.length);
                 if (starvedPiecesCoords.length > 0) { statusAction += ` (${starvedPiecesCoords.length} animal${starvedPiecesCoords.length > 1 ? 's' : ''} starved)`; }

                // 8. Log Move and Board State
                 logMove(notation, playerWhoMoved); // Pass player who moved
                 const boardStateString = logBoardState();

                // 9. Repetition Check
                 const orangeCount = Object.values(gameState.board).filter(p => p && p.player === PLAYERS.ORANGE).length;
                 const yellowCount = Object.values(gameState.board).filter(p => p && p.player === PLAYERS.YELLOW).length;
                 const restrictedPlayer = orangeCount > yellowCount ? PLAYERS.ORANGE : (yellowCount > orangeCount ? PLAYERS.YELLOW : PLAYERS.ORANGE);
                 // Check based on the state *after* the move, for the *next* player.
                  const nextPlayer = opponent; // The player whose turn it will be next
                 if (gameState.boardStateHistory[boardStateString] >= 3 && nextPlayer === restrictedPlayer) {
                     // If the player *whose turn it is now* would create the 3rd repetition, *they* lose.
                     gameState.winner = playerWhoMoved; // The player who just moved wins
                     gameState.gameOver = true;
                     updateStatus(`${playerWhoMoved.toUpperCase()} wins! ${nextPlayer.toUpperCase()} forced repetition.`);
                      disableDragDrop(); updateUI(); updateUndoButtonState(); console.log("Repetition rule invoked!"); return; // GAME OVER
                 }


                // 10. Switch Player
                gameState.currentPlayer = opponent;

                 // 11. Increment Turn Number *after* Yellow has moved
                 if (playerWhoMoved === PLAYERS.YELLOW) {
                     gameState.turnNumber++;
                      console.log("Incrementing turn number to:", gameState.turnNumber);
                 }

                // 12. Update UI for Next Turn
                updateStatus(`${opponent.toUpperCase()}'s turn.${statusAction}`);
                updateUI();
                 updateUndoButtonState(); // Update button state after move


                // 13. Trigger AI if it's Yellow's turn
                if (gameState.currentPlayer === PLAYERS.YELLOW && !gameState.gameOver) {
                    disableDragDrop();
                     undoButton.disabled = true; // Disable undo during AI thinking
                    setTimeout(triggerAIMove, 300); // Slightly longer delay for AI feel
                } else if (!gameState.gameOver) {
                     enableDragDrop();
                     undoButton.disabled = false; // Re-enable undo for human player
                }
            }

            // --- Move Validation (isValidMove, checkJumpPathClear) ---
            // ... (Keep these exactly the same as your previous version) ...
             function isValidMove(fromCoords, toCoords, piece) { if (fromCoords === toCoords) return { valid: false, reason: "Cannot move to the same square." }; const fromRC = getRowCol(fromCoords); const toRC = getRowCol(toCoords); if (!fromRC || !toRC) return { valid: false, reason: "Invalid coordinates." }; const targetPieceData = getPieceData(toCoords); const pieceRank = piece.rank; const pieceAbilities = SPECIAL_ABILITIES[pieceRank] || {}; if (targetPieceData && targetPieceData.player === piece.player) { return { valid: false, reason: "Cannot move to square occupied by your own piece." }; } const ownDen = piece.player === PLAYERS.ORANGE ? DENS.orange : DENS.yellow; if (toCoords === ownDen) { return { valid: false, reason: "Cannot enter your own den." }; } const dr = Math.abs(fromRC.row - toRC.row); const dc = Math.abs(fromRC.col - toRC.col); const isOrthogonal = (dr === 1 && dc === 0) || (dr === 0 && dc === 1); const isMovingToWater = WATER_SQUARES.has(toCoords); const isMovingFromWater = WATER_SQUARES.has(fromCoords); if ((isMovingToWater || isMovingFromWater) && isOrthogonal && !pieceAbilities.swims) { return { valid: false, reason: "Only Rat and Dog can move on water squares." }; } if (isMovingToWater && !pieceAbilities.swims) { return { valid: false, reason: "This animal cannot enter water." }; } let isJump = false; let isJumpValid = false; const isVerticalJump = dc === 0 && dr === 4 && (fromRC.col === 1 || fromRC.col === 2 || fromRC.col === 4 || fromRC.col === 5); const isHorizontalJump = dr === 0 && dc === 3 && (fromRC.row === 3 || fromRC.row === 4 || fromRC.row === 5); if (isVerticalJump || isHorizontalJump) { if ((isVerticalJump && !pieceAbilities.jumpV) || (isHorizontalJump && !pieceAbilities.jumpH)) { return { valid: false, reason: "This animal cannot jump in that direction." }; } if (isMovingFromWater || isMovingToWater) { return { valid: false, reason: "Cannot jump from or into water." }; } if (!checkJumpPathClear(fromRC, toRC, piece.player)) { return { valid: false, reason: "Jump path is blocked by an opponent in the water." }; } isJump = true; isJumpValid = true; } if (!isOrthogonal && !isJumpValid) { return { valid: false, reason: "Invalid move distance or type." }; } if (targetPieceData) { if (targetPieceData.player === piece.player) { return { valid: false, reason: "Cannot attack own piece." }; } const attackerRank = pieceRank; let defenderRank = targetPieceData.rank; if (ALL_TRAP_SQUARES.has(toCoords)) { console.log(`Defender ${RANK_TO_NAME[defenderRank]} at ${toCoords} is in a trap square, rank reduced to 0.`); defenderRank = 0; } const isRatAttackElephant = pieceRank === 1 && targetPieceData.rank === 8; if (isRatAttackElephant) { if (isMovingFromWater) { return { valid: false, reason: "Rat cannot attack Elephant from water." }; } return { valid: true }; } if (attackerRank < defenderRank) { return { valid: false, reason: `Cannot attack higher-ranked animal (${attackerRank} vs ${defenderRank}).` }; } } return { valid: true }; }
             function checkJumpPathClear(fromRC, toRC, attackerPlayer) { const opponent = attackerPlayer === PLAYERS.ORANGE ? PLAYERS.YELLOW : PLAYERS.ORANGE; const startRow = Math.min(fromRC.row, toRC.row); const endRow = Math.max(fromRC.row, toRC.row); const startCol = Math.min(fromRC.col, toRC.col); const endCol = Math.max(fromRC.col, toRC.col); if (fromRC.col === toRC.col) { for (let r = startRow + 1; r < endRow; r++) { const coords = getCoords(r, fromRC.col); if (!WATER_SQUARES.has(coords)) return false; const blockingPiece = getPieceData(coords); if (blockingPiece && blockingPiece.player === opponent) return false; } } else if (fromRC.row === toRC.row) { for (let c = startCol + 1; c < endCol; c++) { const coords = getCoords(fromRC.row, c); if (!WATER_SQUARES.has(coords)) return false; const blockingPiece = getPieceData(coords); if (blockingPiece && blockingPiece.player === opponent) return false; } } else { return false; } return true; }


            // --- Hungry/Starve Logic (declareHungryAnimals, checkAndApplyStarvation, getPotentialMoveDestinations) ---
            // ... (Keep these exactly the same as your previous version) ...
              function declareHungryAnimals(playerToDeclareFor) { let hungryCount = 0; const hungryPiecesMap = {}; const opponent = playerToDeclareFor === PLAYERS.ORANGE ? PLAYERS.YELLOW : PLAYERS.ORANGE; for (const coords in gameState.board) { const piece = gameState.board[coords]; if (piece && piece.player === playerToDeclareFor) { const destinations = getPotentialMoveDestinations(coords, piece); for (const targetCoords of destinations) { const targetPiece = gameState.board[targetCoords]; if (targetPiece && targetPiece.player === opponent) { const validation = isValidMove(coords, targetCoords, piece); if (validation.valid) { hungryPiecesMap[coords] = true; hungryCount++; console.log(`DECLARE HUNGRY: ${playerToDeclareFor} ${RANK_TO_NAME[piece.rank]} at ${coords} can attack ${targetCoords}`); break; } } } } } return { hungryCount, hungryPiecesMap }; }
              function checkAndApplyStarvation(movedPieceCoords, wasAttack) { const currentPlayer = gameState.currentPlayer; const starvedPiecesCoords = []; for (const coords in gameState.board) { const piece = gameState.board[coords]; if (piece && piece.player === currentPlayer && piece.isHungry) { const didThisPieceAttack = (coords === movedPieceCoords) && wasAttack; if (!didThisPieceAttack) { console.log(`STARVE: ${currentPlayer} ${RANK_TO_NAME[piece.rank]} at ${coords} starved (was hungry, did not attack).`); starvedPiecesCoords.push(coords); } else { console.log(`SAVED: ${currentPlayer} ${RANK_TO_NAME[piece.rank]} at ${coords} attacked, avoided starvation.`); } } } starvedPiecesCoords.forEach(coords => { const starvedElement = document.getElementById(getPieceElementId(coords)); if (starvedElement) starvedElement.remove(); if (gameState.board[coords]) { console.log(`Removing starved piece ${RANK_TO_NAME[gameState.board[coords].rank]} from board state at ${coords}`); } delete gameState.board[coords]; }); return starvedPiecesCoords; }
              function getPotentialMoveDestinations(fromCoords, piece) { const destinations = new Set(); const { row, col } = getRowCol(fromCoords); const abilities = SPECIAL_ABILITIES[piece.rank] || {}; const orthMoves = [getCoords(row + 1, col), getCoords(row - 1, col), getCoords(row, col + 1), getCoords(row, col - 1)]; orthMoves.forEach(c => { if (c) destinations.add(c); }); if (abilities.jumpV && (col === 1 || col === 2 || col === 4 || col === 5)) { const destUp = getCoords(row - 4, col); const destDown = getCoords(row + 4, col); if (destUp && row >= 3 && row <= 6 ) destinations.add(destUp); if (destDown && row >= 0 && row <= 2) destinations.add(destDown); } if (abilities.jumpH && (row === 3 || row === 4 || row === 5)) { const destLeft = getCoords(row, col - 3); const destRight = getCoords(row, col + 3); if (destLeft && col >= 3) destinations.add(destLeft); if (destRight && col <= 3) destinations.add(destRight); } return [...destinations]; }


            // --- AI Logic (triggerAIMove, findBestAIMove) ---
            // ... (Keep findBestAIMove exactly the same as your previous version) ...
             function triggerAIMove() { console.log("AI (Yellow) is thinking..."); const bestMove = findBestAIMove(); if (bestMove) { console.log(`AI chooses: ${bestMove.from} to ${bestMove.to}`); setTimeout(() => { performMove(bestMove.from, bestMove.to); if (!gameState.gameOver) { enableDragDrop(); undoButton.disabled = false; /* Re-enable undo after AI moves */ } }, 100); } else { console.log("AI has no valid moves! Game might be over?"); if (!gameState.gameOver) { gameState.winner = PLAYERS.ORANGE; gameState.gameOver = true; updateStatus("AI has no valid moves. Orange wins!"); disableDragDrop(); updateUI(); updateUndoButtonState(); } else { enableDragDrop(); /* Should be disabled */ } } }
             function findBestAIMove() { const possibleMoves = []; const player = gameState.currentPlayer; for (const fromCoords in gameState.board) { const piece = gameState.board[fromCoords]; if (piece && piece.player === player) { const destinations = getPotentialMoveDestinations(fromCoords, piece); for (const toCoords of destinations) { const validation = isValidMove(fromCoords, toCoords, piece); if (validation.valid) { possibleMoves.push({ from: fromCoords, to: toCoords, pieceRank: piece.rank, isHungry: piece.isHungry || false, targetPiece: gameState.board[toCoords] || null }); } } } } if (possibleMoves.length === 0) return null; let bestMove = null; let bestScore = -Infinity; const hungryPieces = possibleMoves.filter(move => move.isHungry); const mustAttack = hungryPieces.length > 0; let consideredMoves = possibleMoves; if (mustAttack) { const hungryAttackMoves = hungryPieces.filter(move => move.targetPiece); if (hungryAttackMoves.length > 0) { console.log("AI is hungry and can attack..."); consideredMoves = hungryAttackMoves; } else { console.log("AI is hungry but cannot attack..."); consideredMoves = hungryPieces; } } for (const move of consideredMoves) { let score = 0; const targetPiece = move.targetPiece; const movingPieceRank = move.pieceRank; if (move.to === DENS.orange) { score = 1000; } else if (targetPiece) { score = 50 + targetPiece.rank * 5; if (movingPieceRank === 1 && targetPiece.rank === 8) score += 100; } else { score = 1; const targetDenRC = getRowCol(DENS.orange); const currentRC = getRowCol(move.from); const destRC = getRowCol(move.to); if (targetDenRC && currentRC && destRC) { const distBefore = Math.abs(currentRC.row - targetDenRC.row) + Math.abs(currentRC.col - targetDenRC.col); const distAfter = Math.abs(destRC.row - targetDenRC.row) + Math.abs(destRC.col - targetDenRC.col); if (distAfter < distBefore) score += 5; } if (TRAPS.yellow.has(move.to)) { score -= 10; } } if (move.isHungry && !targetPiece && !mustAttack) { console.warn("AI considering non-attack while hungry (unexpected)", move); score -= 200; } const tempBoard = JSON.parse(JSON.stringify(gameState.board)); tempBoard[move.to] = tempBoard[move.from]; delete tempBoard[move.from]; const nextStateStr = getBoardStateString(tempBoard); const orangeCount = Object.values(tempBoard).filter(p => p && p.player === PLAYERS.ORANGE).length; const yellowCount = Object.values(tempBoard).filter(p => p && p.player === PLAYERS.YELLOW).length; const restrictedPlayer = orangeCount > yellowCount ? PLAYERS.ORANGE : (yellowCount > orangeCount ? PLAYERS.YELLOW : PLAYERS.ORANGE); if ((gameState.boardStateHistory[nextStateStr] || 0) >= 2 && player === restrictedPlayer) { score = -500; console.log("AI avoiding repetition:", move.from, "->", move.to); } score += Math.random() * 0.1; if (score > bestScore) { bestScore = score; bestMove = move; } } if (!bestMove && !mustAttack && possibleMoves.length > 0) { console.log("AI picking random valid move."); bestMove = possibleMoves[Math.floor(Math.random() * possibleMoves.length)]; } else if (!bestMove && consideredMoves.length > 0) { console.log("AI picking random forced move."); bestMove = consideredMoves[Math.floor(Math.random() * consideredMoves.length)]; } return bestMove; }


            // --- UI Update & Logging ---
            function updateUI() {
                 // Update turn indicator text and class
                 if (gameState.gameOver) {
                     turnIndicator.textContent = `Game Over - ${gameState.winner ? gameState.winner.toUpperCase() : 'UNKNOWN'} Wins!`;
                     turnIndicator.className = 'game-over'; // Use class for styling
                 } else {
                     turnIndicator.textContent = gameState.currentPlayer.toUpperCase();
                     turnIndicator.className = gameState.currentPlayer; // 'orange' or 'yellow' class
                 }
                 // Update Undo Button State
                 updateUndoButtonState();
            }
            function updateStatus(message) { statusMessage.textContent = message; console.log("Status:", message); }

             // NEW: Function to add a single log entry visually
             function addLogEntry(turn, orangeMove, yellowMove) {
                 const logEntryDiv = document.createElement('div');
                 logEntryDiv.classList.add('log-entry');
                 logEntryDiv.dataset.turn = turn;

                 const turnSpan = document.createElement('span');
                 turnSpan.classList.add('turn-number');
                 turnSpan.textContent = `${turn}.`;
                 logEntryDiv.appendChild(turnSpan);

                 const orangeSpan = document.createElement('span');
                  if (orangeMove) {
                      orangeSpan.classList.add('log-orange');
                      orangeSpan.textContent = orangeMove;
                  } else {
                       orangeSpan.classList.add('placeholder');
                       orangeSpan.textContent = '...';
                  }
                 logEntryDiv.appendChild(orangeSpan);

                 const yellowSpan = document.createElement('span');
                  if (yellowMove) {
                      yellowSpan.classList.add('log-yellow');
                      yellowSpan.textContent = yellowMove;
                  } else {
                       // Don't add placeholder if yellow hasn't moved yet in this turn
                  }
                  // Only add yellow span if it has content
                  if (yellowMove) {
                      logEntryDiv.appendChild(yellowSpan);
                  }


                 moveLogElement.appendChild(logEntryDiv);
                 moveLogElement.scrollTop = moveLogElement.scrollHeight;
             }


            // REVISED logMove function
            function logMove(notation, playerWhoMoved) {
                const turnNum = gameState.turnNumber;
                let currentTurnEntry = gameState.moveHistory.find(entry => entry.turn === turnNum);
                let existingLogDiv = moveLogElement.querySelector(`[data-turn="${turnNum}"]`);

                 if (playerWhoMoved === PLAYERS.ORANGE) {
                      if (!currentTurnEntry) {
                           currentTurnEntry = { turn: turnNum, orange: notation, yellow: null };
                           gameState.moveHistory.push(currentTurnEntry);
                           // Add new visual log entry
                           addLogEntry(turnNum, notation, null);
                      } else {
                           // This case (Orange moving again in same turn) should ideally not happen with correct turn logic
                           console.warn("Orange moved again in turn", turnNum);
                           currentTurnEntry.orange = notation; // Overwrite data model
                           // Update existing visual log entry
                           if (existingLogDiv) {
                                const orangeSpan = existingLogDiv.querySelector('.log-orange');
                                if (orangeSpan) { orangeSpan.textContent = notation; orangeSpan.className = 'log-orange';}
                                else { /* Handle case where span didn't exist? */}
                           } else { // Fallback if visual entry missing
                                addLogEntry(turnNum, notation, currentTurnEntry.yellow);
                           }
                      }
                 } else { // Yellow moved
                     if (currentTurnEntry) {
                          currentTurnEntry.yellow = notation; // Update data model
                          // Update existing visual log entry
                          if (existingLogDiv) {
                               let yellowSpan = existingLogDiv.querySelector('.log-yellow');
                               if (!yellowSpan) { // Create yellow span if it doesn't exist
                                    yellowSpan = document.createElement('span');
                                    existingLogDiv.appendChild(yellowSpan);
                               }
                               yellowSpan.textContent = notation;
                               yellowSpan.className = 'log-yellow'; // Ensure correct class
                          } else { // Fallback if visual entry missing
                               console.error("Could not find log div for turn", turnNum, "to add Yellow's move.");
                               // Create a new entry as fallback
                                addLogEntry(turnNum, currentTurnEntry.orange || '...', notation);
                          }
                     } else {
                          // Should not happen if Orange always moves first in a turn
                          console.error("Yellow moved but no entry found for turn", turnNum);
                           // Create new entry as fallback
                          currentTurnEntry = { turn: turnNum, orange: null, yellow: notation };
                          gameState.moveHistory.push(currentTurnEntry);
                          addLogEntry(turnNum, null, notation);
                     }
                 }
             }


            // REVISED getBoardStateString function
             function getBoardStateString(board = gameState.board) {
                 const pieces = [];
                 // Iterate row by row from top ('9') down to '1'
                 for (let r = 0; r < ROWS; r++) { // r=0 is row 9, r=8 is row 1
                     // Iterate column by column from left ('a') to right ('g')
                     for (let c = 0; c < COLS; c++) { // c=0 is col a, c=6 is col g
                         const coords = getCoords(r, c);
                         const piece = board[coords];
                         if (piece) {
                             // Format: Rank + Coords (Uppercase for Orange Coords, Lowercase for Yellow Coords)
                             // Correction: Rule says "lowercase for yellow animals and uppercase for orange animals".
                             // Example: 7a9, 6g9 ... 8A3, 3C3
                             // This implies Rank + LowercaseCoords for Yellow, Rank + UppercaseCoords for Orange
                             const stateOutput = piece.player === PLAYERS.ORANGE
                                 ? `${piece.rank}${coords.toUpperCase()}` // e.g., 8A3
                                 : `${piece.rank}${coords.toLowerCase()}`; // e.g., 7a9
                             pieces.push(stateOutput);
                         }
                     }
                 }
                  // DO NOT SORT pieces array - order matters (row by row)
                 return pieces.join(',');
             }


             function logBoardState() {
                 const stateString = getBoardStateString();
                 boardStateLogElement.textContent = stateString; // Display current state
                 // Add to history for repetition check (using the CORRECT state string)
                 gameState.boardStateHistory[stateString] = (gameState.boardStateHistory[stateString] || 0) + 1;
                 console.log(`Board State (${gameState.boardStateHistory[stateString]}x):`, stateString);
                 return stateString;
             }
             function updateHungryVisual(coords, isHungry) { /* ... same as before ... */
                 const pieceElement = document.getElementById(getPieceElementId(coords));
                 if (pieceElement) { if (isHungry) { pieceElement.classList.add('hungry'); } else { pieceElement.classList.remove('hungry'); } }
             }

            // --- Highlighting Valid Moves (highlightValidMoves, clearHighlights, flashCell) ---
            // ... (Keep these exactly the same as your previous version) ...
              function highlightValidMoves(fromCoords) { clearHighlights(); const piece = gameState.board[fromCoords]; if (!piece || piece.player !== gameState.currentPlayer) return; const destinations = getPotentialMoveDestinations(fromCoords, piece); destinations.forEach(toCoords => { const validation = isValidMove(fromCoords, toCoords, piece); if (validation.valid) { const cell = document.getElementById(getCellElementId(toCoords)); if (cell) { cell.classList.add('valid-move-highlight'); if (gameState.board[toCoords]) { cell.classList.add('valid-attack-highlight'); } } } }); }
              function clearHighlights() { boardElement.querySelectorAll('.cell').forEach(cell => { cell.classList.remove('valid-move', 'valid-attack', 'valid-move-highlight', 'valid-attack-highlight'); cell.style.backgroundColor = ''; cell.style.transition = ''; }); }
              function flashCell(coords, color = 'red', duration = 500) { const cell = document.getElementById(getCellElementId(coords)); if (cell) { cell.style.transition = `background-color ${duration / 2}ms ease-out`; cell.style.backgroundColor = color === 'red' ? 'rgba(255,0,0,0.5)' : 'rgba(0,255,0,0.5)'; setTimeout(() => { cell.style.backgroundColor = ''; }, duration / 2); } }


            // --- Undo Move Functionality ---
            function undoMove() {
                if (gameHistory.length === 0 || gameState.currentPlayer === PLAYERS.YELLOW) {
                     console.log("Cannot undo."); // Cannot undo if history is empty or if it's AI's turn / during AI move
                     return;
                 }

                console.log("Undoing move...");

                 // Pop the last saved state (state *before* the move we want to undo)
                 const prevState = gameHistory.pop();

                 if (!prevState) {
                      console.error("Undo failed: No previous state found in history.");
                      updateUndoButtonState(); // Make sure button state is correct
                      return;
                 }

                 // If the AI (Yellow) just moved, we need to undo two steps (AI move + Player move)
                 // Check the player *in the state we are restoring*
                 // let statesToUndo = 1;
                 // if (prevState.currentPlayer === PLAYERS.YELLOW && gameHistory.length > 0) {
                 //      // The state we are restoring is Yellow's turn, meaning Orange just moved.
                 //      // If we want to undo Orange's move, we might need to pop again?
                 //      // Let's simplify: Always undo the last *completed* action recorded in history.
                 //       console.log("Undoing AI move as well...");
                 //       const humanMovePrevState = gameHistory.pop();
                 //       if (humanMovePrevState) {
                 //            loadGameState(humanMovePrevState);
                 //       } else {
                 //            console.warn("Could not undo human move prior to AI move.");
                 //            loadGameState(prevState); // Load the state before AI move anyway
                 //       }
                 // } else {
                     // Only undo one move (human just moved, or AI didn't move last)
                     loadGameState(prevState);
                 // }

                 console.log("Game state restored to turn:", gameState.turnNumber, "Player:", gameState.currentPlayer);
            }

            function updateUndoButtonState() {
                // Disable if history is empty OR if it's AI's turn and thinking/acting OR game is over
                 undoButton.disabled = (gameHistory.length === 0 || gameState.gameOver || (gameState.currentPlayer === PLAYERS.YELLOW && boardElement.style.pointerEvents === 'none') );
            }


            // --- Event Listeners ---
            resetButton.addEventListener('click', initializeGame);
            undoButton.addEventListener('click', undoMove); // Add listener for Undo button

            // --- Initial Game Setup ---
            initializeGame();

        }); // End DOMContentLoaded
    </script>

</body>
</html>