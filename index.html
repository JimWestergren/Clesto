<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Play Clesto, the Jungle Chess game online. A strategy board game with unique animal movements and rules.">
    <title>CLESTO: The Jungle Chess Game</title>

    <!-- Preload key visual assets -->
    <link rel="preload" as="image" href="https://staticjw.com/clesto/board.png">
    <link rel="preload" as="image" href="https://staticjw.com/clesto/animals/elephant-orange.png">
    <link rel="preload" as="image" href="https://staticjw.com/clesto/animals/lion-orange.png">
    <link rel="preload" as="image" href="https://staticjw.com/clesto/animals/elephant-yellow.png">
    <link rel="preload" as="image" href="https://staticjw.com/clesto/animals/lion-yellow.png">

    <style>
        /* --- Global Variables & Basic Setup --- */
        :root {
            /* Player Colors (Keep As Is) */
            --orange-color: #E67E22;
            --yellow-color: #F1C40F;
            --dark-orange: #D35400;
            --dark-yellow: #F39C12;

            /* UI Colors (Will be largely overridden, but set sensible defaults) */
            --primary-bg: #6fb367;      /* Main Green Background */
            --secondary-bg: #fdf6e3;    /* Light Cream/Beige for Panels */
            --tertiary-bg: #f5f5f5;     /* Lighter Grey for Logs/Code */
            --text-dark: #4a4a4a;       /* Dark Text for Readability */
            --text-light: #ffffff;      /* Light Text (e.g., on buttons) */
            --border-color: #a9a9a9;    /* Default Border */
            --button-default-bg: #4CAF50; /* Default Green Button */
            --button-default-hover: #45a049; /* Darker Green Hover */

            /* Highlight & Feedback Colors (Keep As Is) */
            --cell-highlight-move: rgba(0, 255, 0, 0.7);
            --cell-highlight-attack: rgba(255, 0, 0, 0.7);
            --piece-select-glow: rgba(0, 191, 255, 0.9);
            --hungry-outline: rgba(255, 0, 0, 0.8);
            --ai-move-from-bg: rgba(0, 0, 255, 0.15);
            --ai-move-to-bg: rgba(0, 0, 255, 0.3);
            --focus-outline: 2px solid #007bff;

            /* Layout Dimensions (Keep As Is) */
            --board-max-width: 550px;
            --ui-max-width: 300px;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: var(--primary-bg); /* Use Green Background */
            color: var(--text-dark);           /* Default Dark Text */
            padding: 10px;
            margin: 0;
            box-sizing: border-box;
            width: 100%;
            min-height: 100vh;
        }

        h1 {
            margin-top: 10px;
            margin-bottom: 15px;
            color: var(--text-light); /* White text on green background */
            font-weight: 300;
            /* border-bottom: 1px solid var(--medium-gray); Remove border */
            padding-bottom: 10px;
            font-size: 1.8em;
            text-align: center;
            width: 100%;
            max-width: calc(var(--board-max-width) + var(--ui-max-width) + 40px);
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.4); /* Add subtle shadow */
        }

        main {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            margin-top: 10px;
            width: 100%;
            max-width: calc(var(--board-max-width) + var(--ui-max-width) + 40px);
            box-sizing: border-box;
        }

        /* --- Board Styling --- */
        #board {
            /* Outer container: Sets dimensions, background image, and padding */
            width: var(--board-max-width);
            max-width: 100%;
            /* Responsive width */
            aspect-ratio: 7.1 / 9;
            /* Maintain board proportions */
            height: auto;
            border: none;
            position: relative;
            background-image: url('https://staticjw.com/clesto/board.png');
            background-size: cover;
            background-position: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
            border-radius: 5px;
            outline: none;
            /* For custom focus */
            box-sizing: border-box;
            padding: 22px;
            /* Adjust padding to align grid with background */
            overflow: hidden;
            /* Clip any potential overflow */
        }

        #board-grid-wrapper {
            /* Inner container: Holds the grid cells and pieces */
            width: 100%;
            height: 100%;
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            grid-template-rows: repeat(9, 1fr);
            position: relative;
            outline: none;
        }

        #board:focus {
            /* Custom focus style for the board */
            box-shadow: 0 0 0 3px var(--focus-outline);
        }

        .cell {
            /* Individual grid cells */
            width: 100%;
            height: 100%;
            border: none;
            box-sizing: border-box;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.6em;
            /* For coordinate display (optional) */
            color: rgba(0, 0, 0, 0.3);
            user-select: none;
            background-clip: padding-box;
            /* Ensure background doesn't overlap borders */
            transition: background-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            outline: none;
            /* For custom focus */
        }

        .cell:focus {
            /* Custom focus style for cells */
            box-shadow: inset 0 0 0 3px var(--focus-outline);
            z-index: 5;
            /* Bring focus outline above other elements */
        }

        .cell::before {
            /* Pseudo-element for styling special terrain (water, traps, dens) */
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            /* Doesn't interfere with clicks/drags */
            box-sizing: border-box;
            border-radius: inherit;
            opacity: 0.8;
            /* Slightly transparent overlay */
        }

        /* Specific terrain styles using the ::before pseudo-element */
        .water::before {
            background-color: rgba(100, 150, 255, 0.3);
        }

        .trap-orange::before { /* Affects Orange, near Yellow den */
            /* background-color: rgba(255, 255, 150, 0.3); */
            /* border: 2px dashed var(--dark-yellow); */
        }

        .trap-yellow::before { /* Affects Yellow, near Orange den */
            /* background-color: rgba(255, 150, 150, 0.3); */
            /* border: 2px dashed var(--hungry-outline); */
        }

        .den-orange::before {
            /* background-color: rgba(255, 100, 0, 0.4); */
            /* border: 3px solid var(--dark-orange); */
        }

        .den-yellow::before {
            /* background-color: rgba(255, 255, 0, 0.4); */
            /* border: 3px solid var(--dark-yellow); */
        }

        /* Highlighting for AI's last move */
        .ai-move-from {
            background-color: var(--ai-move-from-bg) !important;
        }

        .ai-move-to {
            background-color: var(--ai-move-to-bg) !important;
        }

        /* --- Highlighting for Last Moves --- */
        /* Generic cell styles (apply to both players) */
        .last-move-from {
            background-color: rgba(0, 0, 255, 0.1); /* Light background for origin */
             transition: background-color 0.3s ease-out;
        }
        .last-move-to {
            background-color: rgba(0, 0, 255, 0.25); /* Darker background for destination */
             transition: background-color 0.3s ease-out;
        }
        /* Player-specific border/glow (optional, can use background only) */
        .orange-last-move {
            background-color: rgba(0, 0, 255, 0.25); /* Light background for origin */
             transition: background-color 0.3s ease-out;
        }
        .yellow-last-move {
            background-color: rgba(0, 0, 255, 0.25); /* Darker background for destination */
             transition: background-color 0.3s ease-out;
        }

        /* --- Piece Styling --- */
        .piece {
            /* Width calculated as a percentage of the GRID WRAPPER */
            /* Cell Width = 100% / 7 columns ≈ 14.2857% */
            /* Piece Width = 84.5% of Cell Width */
            /* Piece % of Wrapper = (100/7) * 0.845 ≈ 12.07% */
            width: 12.07%;
            aspect-ratio: 1 / 1;
            /* Make piece square relative to its width */
            height: auto;
            /* Height is automatically determined by width + aspect ratio */

            position: absolute;
            /* Positioned relative to #board-grid-wrapper */
            left: 0;
            /* Left position set by JavaScript */
            top: 0;
            /* Top position set by JavaScript */

            /* CURSOR REMOVED - Will be applied conditionally via JS/CSS class */
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.25);
            z-index: 10;
            /* Pieces sit above cells */
            /* Smooth transitions for movement, scaling, and effects */
            transition: transform 0.3s ease-in-out, box-shadow 0.2s ease, outline 0.2s ease, left 0.3s ease-in-out, top 0.3s ease-in-out;
            user-select: none;
            /* Prevent text selection */
            overflow: visible;
            /* Allow outlines/glows to extend slightly */
            background: none;
            border: none;
            border-radius: 50%;
            /* Circular pieces */
            outline: none;
            /* Custom focus/selection */
            touch-action: none;
            /* Improve touch interactions */
        }

        .piece img {
            /* Styling for the animal image inside the piece div */
            width: 100%;
            height: 100%;
            display: block;
            object-fit: contain;
            /* Scale image while preserving aspect ratio */
            pointer-events: none;
            /* Image doesn't interfere with events on the parent div */
            border-radius: 50%;
        }

        .piece:focus {
            /* Custom focus style for pieces 
            outline: 3px solid var(--focus-outline);
            outline-offset: 1px;
            z-index: 15; */
            /* Bring focused piece above others */
        }

        .piece.dragging {
            /* Style applied when a piece is being dragged */
            opacity: 0.6;
            cursor: grabbing;
            z-index: 100;
            /* Ensure dragged piece is on top */
            transform: scale(1.1);
            /* Slightly enlarge */
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            /* Enhance shadow */
            transition: transform 0.15s ease-out, box-shadow 0.2s ease, outline 0.2s ease;
            /* Faster transition while dragging */
        }

        /* --- Movable Piece Cursor --- */
        .piece.movable {
             cursor: grab; /* Apply hand cursor only when piece is interactive */
        }

        .piece.captured {
            /* Animation for captured pieces */
            animation: capture-animation 0.4s ease-out forwards;
        }

        /* --- Trap Rank Indicator Styling --- */
        .trap-rank-indicator {
            position: absolute;
            top: -2px; /* Position slightly above the piece image */
            left: 0;
            width: 100%;
            text-align: center;
            font-size: 0.75em; /* Smaller font size */
            font-weight: bold;
            color: white; /* White text */
            background-color: rgba(200, 0, 0, 0.75); /* Reddish semi-transparent background */
            border-radius: 3px;
            padding: 0 2px;
            z-index: 1; /* Above the image (z-index 0 default) but below selection/hungry (z-index > 1) */
            pointer-events: none; /* So it doesn't interfere with clicks/drags */
            display: none; /* Hidden by default */
            box-sizing: border-box;
            user-select: none; /* Prevent text selection */
        }

        .trap-rank-indicator.visible {
            display: block; /* Show the indicator when this class is added */
        }

        @keyframes capture-animation {
            0% {
                transform: scale(1);
                opacity: 1;
            }

            100% {
                transform: scale(0.5);
                opacity: 0;
            }
        }

        /* --- Visual Feedback --- */
        .valid-move {
            /* Style for cells representing a valid non-attack move */
            box-shadow: inset 0 0 0 3px var(--cell-highlight-move);
            background-color: rgba(0, 255, 0, 0.1);
        }

        .valid-attack {
            /* Style for cells representing a valid attack move */
            box-shadow: inset 0 0 0 3px var(--cell-highlight-attack);
            background-color: rgba(255, 0, 0, 0.1);
        }

        .selected {
            /* Outline for the currently selected piece */
            /* outline: 3px solid var(--piece-select-glow); */ /* Blue solid */
            /* outline-offset: 1px;
            z-index: 16; */ /* Ensure selected outline is visually prominent */
        }

        .hungry {
            /* Box-shadow glow for pieces that must attack if possible */
            /* outline: 3px dashed var(--hungry-outline); */ /* Keep old style commented */
            /* outline-offset: 2px; */
            box-shadow: 0 0 0 3px var(--hungry-outline); /* Red 'glow' effect */
             /* Optional: Add a subtle animation */
            /* animation: hungry-pulse 1.5s infinite ease-in-out; */
        }

        /* Optional pulse animation for hungry pieces */
        @keyframes hungry-pulse {
            0% { box-shadow: 0 0 0 3px var(--hungry-outline); }
            50% { box-shadow: 0 0 0 5px rgba(255, 0, 0, 0.5); } /* Slightly wider, semi-transparent */
            100% { box-shadow: 0 0 0 3px var(--hungry-outline); }
        }

        /* --- UI Info Panel Styling --- */
        #ui-info-section {
            width: var(--ui-max-width);
            max-width: 100%;
            border: 1px solid var(--border-color); /* Use new border color */
            padding: 20px;
            background-color: var(--secondary-bg); /* Use Cream/Beige background */
            height: fit-content;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
        }

        #ui-info-section h2,
        #ui-info-section h3 {
            margin-top: 0;
            margin-bottom: 15px;
            border-bottom: 1px solid var(--border-color); /* Use new border color */
            padding-bottom: 8px;
            font-weight: 500; /* Slightly bolder */
            color: var(--text-dark); /* Use new dark text color */
        }

        #ui-info-section h3 {
            margin-top: 15px;
            /* Space above subheadings */
        }

        #ui-info-section p {
            margin: 10px 0;
            line-height: 1.5;
        }

        #turn-indicator {
            font-weight: 600;
            padding: 3px 6px;
            border-radius: 4px;
            color: white;
        }

        /* Player-specific turn indicator colors */
        #turn-indicator.orange {
            background-color: var(--orange-color);
        }

        #turn-indicator.yellow {
            background-color: var(--yellow-color);
            color: var(--dark-gray);
            /* Better contrast */
        }

        #turn-indicator.game-over {
            background-color: #dc3545;
            /* Red for game over */
        }

        #status-message {
            min-height: 1.5em;
            /* Prevent layout shifts */
        }

        /* --- Clock Styling --- */
        .clock-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 10px;
            margin: 4px 0 8px 0;
            border: 1px solid var(--border-color); /* Use new border color */
            border-radius: 4px;
            background-color: #f0e8d1; /* Slightly different cream for clocks */
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }

        .clock-label {
            font-weight: 500;
            font-size: 0.9em;
            margin-right: 10px;
            color: var(--text-dark); /* Use new dark text color */
        }

        .clock-time {
            font-family: 'Courier New', Courier, monospace;
            font-size: 1.1em;
            font-weight: bold;
            padding: 2px 5px;
            border-radius: 3px;
            background-color: #e9e0c7; /* Background matching hover/active toggle */
            color: var(--text-dark); /* Default dark text */
        }

        /* Style for clock time when it runs out */
        .clock-time.time-out {
            color: #dc3545; /* Red color */
            /* Optional: Add other styles like background */
            /* background-color: #f8d7da; */ /* Light red background */
        }

        /* Style for the active clock */
        .clock-container.clock-active {
            border-color: var(--text-dark); /* Use dark text color for active border */
            background-color: #e9e0c7; /* Match time background */
        }

        /* Player-specific active clock time background (optional) */
        #orange-clock-container.clock-active .clock-time {
             background-color: var(--orange-color);
             color: white;
        }
         #yellow-clock-container.clock-active .clock-time {
             background-color: var(--yellow-color);
             color: var(--dark-gray);
         }

        /* --- Buttons --- */
        .button-container {
            padding-top: 10px;
            margin-bottom: 15px;
            display: flex;
            gap: 10px;
            justify-content: space-around;
            flex-wrap: wrap;
        }

        .game-button {
            padding: 10px 18px;
            cursor: pointer;
            border-radius: 5px;
            border: none;
            font-size: 0.95em;
            transition: background-color 0.2s ease, box-shadow 0.2s ease;
            background-color: var(--button-default-bg); /* Use Green Button color */
            color: var(--text-light);                   /* Use Light Text color */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            outline: none;
            margin-bottom: 5px;
        }

        .game-button:hover {
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.15);
            background-color: var(--button-default-hover); /* Darker green on hover */
        }

        .game-button:focus-visible {
            /* Style for keyboard focus */
            box-shadow: 0 0 0 3px var(--focus-outline);
        }

        /* Specific button colors */
        #reset-button {
            background-color: var(--button-default-bg); /* Match default green */
        }

        #reset-button:hover {
            background-color: var(--button-default-hover); /* Match default green hover */
        }

        #undo-button {
            background-color: #ffc107;
            /* Yellow */
            color: var(--dark-gray);
        }

        #undo-button:hover {
            background-color: #e0a800;
        }

        #undo-button:disabled {
            background-color: #adb5bd;
            cursor: not-allowed;
            box-shadow: none;
        }

        /* --- PvP Toggle Switch Styling --- */
        .pvp-toggle-container {
            display: flex;
            align-items: center;
            justify-content: space-between; /* Adjust as needed */
            margin-top: 8px;
            margin-bottom: 8px;
            padding: 5px 0;
        }

        .pvp-label {
            margin-right: 10px;
            font-weight: 500;
            font-size: 0.95em;
        }

        /* The switch - a wrapper around the checkbox and slider */
        .switch {
            position: relative;
            display: inline-block;
            width: 50px; /* Width of the switch */
            height: 24px; /* Height of the switch */
        }

        /* Hide default HTML checkbox */
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        /* The slider */
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #bdbdbd; /* Darker gray for inactive */
            transition: .4s;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 18px; /* Height of the knob */
            width: 18px; /* Width of the knob */
            left: 3px; /* Position from left */
            bottom: 3px; /* Position from bottom */
            background-color: white;
            transition: .4s;
        }

        input:checked + .slider {
            background-color: var(--orange-color); /* Use a game color when active */
        }

        input:focus + .slider {
            box-shadow: 0 0 1px var(--orange-color);
        }
         input:focus-visible + .slider { /* Better focus styling */
             outline: 2px solid var(--focus-outline);
             outline-offset: 1px;
         }


        input:checked + .slider:before {
            transform: translateX(26px); /* Move knob to the right */
        }

        /* Rounded sliders */
        .slider.round {
            border-radius: 24px; /* Make the track round */
        }

        .slider.round:before {
            border-radius: 50%; /* Make the knob round */
        }

        /* --- PvP Info Icon & Tooltip Styling --- */
        .pvp-info-icon {
            display: inline-block;
            margin-left: 8px;       /* Space between label and icon */
            cursor: help;           /* Use help cursor */
            color: #007bff;         /* Blue color for the icon */
            font-weight: bold;
            font-size: 1.1em;
            line-height: 1;         /* Prevent extra vertical space */
            border-radius: 50%;     /* Make focus outline round */
            padding: 0 2px;        /* Small padding for focus */
            vertical-align: middle;
        }

        .pvp-info-icon:focus {
            outline: var(--focus-outline); /* Use standard focus outline */
            outline-offset: 1px;
        }

        .tooltip-text {
            visibility: hidden;
            opacity: 0;
            position: absolute;
            background-color: var(--text-dark);
            color: var(--text-light);
            text-align: center;
            padding: 6px 10px;
            border-radius: 5px;
            z-index: 101;
            font-size: 0.85em;
            width: 180px;
            /* Position above the ICON (which is now inside switch-icon-wrapper) */
            bottom: 130%; /* Adjust vertical distance from icon */
            left: 50%; /* Start at the center of the icon */
            /* Translate leftwards by roughly half tooltip width PLUS half icon width approx */
            transform: translateX(-50%); /* Use transform for better centering */
            transition: opacity 0.3s ease;
            pointer-events: none;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        /* Show tooltip on hover or focus */
        .pvp-info-icon:hover + .tooltip-text,
        .pvp-info-icon:focus + .tooltip-text {
            visibility: visible;
            opacity: 1;
        }

        /* Optional: Add a little arrow/pointer below the tooltip */
        .tooltip-text::after {
            content: "";
            position: absolute;
            top: 100%; /* At the bottom of the tooltip */
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: var(--text-dark) transparent transparent transparent; /* Arrow pointing down */
        }

        .tooltip-text::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%; /* Center relative to tooltip */
            transform: translateX(-50%); /* Ensure arrow is centered */
            margin-left: 0; /* Reset margin-left used previously */
            border-width: 5px;
            border-style: solid;
            border-color: var(--text-dark) transparent transparent transparent;
        }

        .switch-icon-wrapper { 
            display: flex; /* Align switch and icon horizontally */ 
            align-items: center; /* Vertically center them */ 
            position: relative; /* Crucial for tooltip positioning */ 
        }

        /* --- Logs --- */
        #move-log {
            height: 220px;
            overflow-y: auto;
            border: 1px solid var(--border-color); /* Use new border color */
            border-radius: 5px;
            padding: 8px 10px;
            margin-top: 10px;
            font-size: 0.9em;
            background-color: var(--tertiary-bg); /* Use Lighter Grey background */
            line-height: 1.6;
        }

        .log-entry {
            padding: 3px 0;
            border-bottom: 1px dashed var(--medium-gray);
        }

        .log-entry:last-child {
            border-bottom: none;
        }

        .log-entry .turn-number {
            display: inline-block;
            width: 25px;
            font-weight: bold;
            color: #6c757d;
            margin-right: 5px;
        }

        .log-entry .log-orange,
        .log-entry .log-yellow {
            display: inline-block;
            min-width: 60px;
            padding: 2px 5px;
            border-radius: 3px;
            margin: 0 3px;
            text-align: center;
        }

        /* Move log colors matching player colors */
        .log-entry .log-orange {
            background-color: rgba(230, 126, 34, 0.15);
            color: var(--dark-orange);
            border: 1px solid rgba(230, 126, 34, 0.3);
        }

        .log-entry .log-yellow {
            background-color: rgba(241, 196, 15, 0.15);
            color: #c78b02;
            /* Darker yellow for text */
            border: 1px solid rgba(241, 196, 15, 0.3);
        }

        .log-entry .placeholder {
            /* Style for when a player hasn't moved yet in the current turn */
            color: #adb5bd;
            font-style: italic;
            display: inline-block;
            min-width: 60px;
            text-align: center;
        }

        /* --- Move Log Tooltip Styling --- */
        .log-entry .log-orange,
        .log-entry .log-yellow {
            position: relative; /* Needed for absolute positioning of the tooltip */
            cursor: help;       /* Indicate more info is available */
            /* Optional: Add subtle underline on hover/focus */
             /* text-decoration: none; */
             /* transition: text-decoration 0.2s ease; */
        }

        .log-entry .log-orange:hover,
        .log-entry .log-yellow:hover,
        .log-entry .log-orange:focus,
        .log-entry .log-yellow:focus {
            /* Optional: Style on hover/focus */
            /* text-decoration: underline; */
            outline: none; /* Remove default focus outline if custom one is not desired */
        }
        .log-entry .log-orange:focus-visible,
        .log-entry .log-yellow:focus-visible {
             /* Add a visible focus style for keyboard nav */
             box-shadow: 0 0 0 2px var(--focus-outline);
             outline: none;
        }

        /* --- Shared Move Log Tooltip --- */
        .shared-tooltip {
            position: fixed; /* Position relative to viewport */
            background-color: rgba(50, 50, 50, 0.9); /* Dark semi-transparent */
            color: var(--text-light);
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 0.9em;
            line-height: 1.4;
            white-space: normal;
            word-wrap: break-word;
            z-index: 1100; /* High z-index */
            max-width: 240px;
            /* Hide initially */
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.2s ease, visibility 0.2s ease;
            pointer-events: none; /* Prevent interaction */
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            /* Reset potential inherited styles */
            display: block;
            margin: 0;
            text-align: left;
        }

        #board-state-log {
            margin-top: 10px;
            border: 1px solid var(--border-color); /* Use new border color */
            border-radius: 5px;
            padding: 10px;
            font-size: 0.75em;
            font-family: monospace;
            word-wrap: break-word;
            background-color: var(--tertiary-bg); /* Use Lighter Grey background */
            max-height: 90px;
            overflow-y: auto;
            line-height: 1.4;
        }

        /* --- Debug Log Section Styling (Optional) --- */
        #debug-log-container {
            width: 100%;
            max-width: calc(var(--board-max-width) + var(--ui-max-width) + 40px);
            margin-top: 20px;
            padding: 15px;
            background-color: var(--secondary-bg); /* Use Cream/Beige background */
            border: 1px solid var(--border-color); /* Use new border color */
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            box-sizing: border-box;
        }

        #debug-log-container h2 {
            margin-top: 0;
            margin-bottom: 10px;
            font-weight: 500; /* Slightly bolder */
            border-bottom: 1px solid var(--border-color); /* Use new border color */
            padding-bottom: 5px;
            font-size: 1.2em;
            color: var(--text-dark); /* Use new dark text color */
        }

        #debug-log-output {
            height: 200px;
            max-height: 40vh;
            overflow-y: auto;
            background-color: var(--tertiary-bg); /* Use Lighter Grey background */
            border: 1px solid var(--border-color); /* Use new border color */
            border-radius: 3px;
            padding: 8px;
            font-family: monospace;
            font-size: 0.8em;
            white-space: pre-wrap;
            word-break: break-word;
            line-height: 1.4;
            color: var(--text-dark); /* Ensure default text color */
        }

        .debug-log-entry {
            padding: 2px 0;
            border-bottom: 1px dashed #e9ecef;
        }

        .debug-log-entry:last-child {
            border-bottom: none;
        }

        .debug-log-timestamp {
            color: #6c757d;
            margin-right: 8px;
        }

        /* Color coding for debug levels */
        .debug-log-warn {
            color: #fd7e14;
        }

        .debug-log-error {
            color: #dc3545;
            font-weight: bold;
        }

        .debug-hidden {
            /* Class to hide the debug section */
            display: none;
        }

        /* --- Rules Accordion Styling --- */
        #rules-accordion-container {
            width: 100%;
            max-width: calc(var(--board-max-width) + var(--ui-max-width) + 40px); /* Match main content width */
            margin: 15px auto 15px auto; /* Add some space around it */
            border: 1px solid var(--border-color); /* Use new border color */
            border-radius: 5px;
            overflow: hidden; /* Clip content during transition */
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            box-sizing: border-box;
            background-color: var(--secondary-bg); /* Use Cream/Beige background */
        }

        .rules-toggle-button {
            background-color: #e8e0c9; /* Slightly darker cream for header */
            color: var(--text-dark); /* Use new dark text color */
            cursor: pointer;
            padding: 12px 18px;
            width: 100%;
            border: none;
            text-align: left;
            outline: none;
            font-size: 1.1em;
            transition: background-color 0.3s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 500;
        }

        .rules-toggle-button:hover,
        .rules-toggle-button.active {
            background-color: #dcd4b8; /* Darker cream on hover/active */
        }

        .rules-toggle-button:focus-visible {
             box-shadow: 0 0 0 3px var(--focus-outline);
             z-index: 1; /* Ensure focus outline is visible */
             position: relative; /* Needed for z-index */
        }

        .rules-icon {
            font-size: 1.2em;
            font-weight: bold;
            transition: transform 0.3s ease;
        }

        .rules-toggle-button.active .rules-icon {
            transform: rotate(45deg); /* Rotate '+' to 'x' */
        }

        .rules-content {
            padding: 0 18px;
            background-color: var(--secondary-bg); /* Match panel background */
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out, padding 0.3s ease-out;
            border-top: 1px solid var(--border-color); /* Use new border color */
            color: var(--text-dark); /* Ensure text color */
        }

        .rules-content.expanded {
             padding: 15px 18px; /* Padding when expanded */
             /* max-height is set by JS */
        }


        .rules-content h3 {
            margin-top: 15px;
            margin-bottom: 8px;
            color: var(--text-dark); /* Use standard dark text */
            font-weight: 600;      /* Make slightly bolder */
            border-bottom: 1px solid var(--border-color); /* Use new border color */
            padding-bottom: 4px;
        }
         .rules-content h3:first-child {
            margin-top: 0;
         }

        .rules-content h4 {
            margin-top: 12px;
            margin-bottom: 5px;
            color: #5a5a5a; /* Slightly lighter dark text */
        }


        .rules-content p,
        .rules-content ul,
        .rules-content ol {
            margin-bottom: 10px;
            line-height: 1.6;
        }

        .rules-content ul,
        .rules-content ol {
            padding-left: 25px; /* Indent lists */
        }
         .rules-content ul ul,
         .rules-content ol ol,
         .rules-content ul ol,
         .rules-content ol ul {
             margin-bottom: 5px; /* Less space for nested lists */
         }

        .rules-content li {
            margin-bottom: 5px;
        }

        .rules-content strong {
            font-weight: 600; /* Make bold text stand out */
        }

        /* --- Mobile Responsiveness --- */
        @media (max-width: 850px) {

            /* Adjust layout for smaller screens */
            body {
                padding: 5px;
            }

            h1 {
                font-size: 1.5em;
                margin-bottom: 10px;
            }

            main {
                flex-direction: column;
                align-items: center;
                gap: 15px;
                padding: 0 5px;
                max-width: 100%;
            }

            /* Stack board and UI vertically */
            #board {
                width: 95vw;
                /* Use viewport width */
                max-width: var(--board-max-width);
                /* Still respect max width */
                padding: 25px 21px;
                /* Slightly reduce padding */
                order: 1;
                /* Place board first */
            }

            #ui-info-section {
                width: 95vw;
                max-width: var(--board-max-width);
                /* Match board max width */
                order: 2;
                /* Place UI below board */
            }

            /* Reduce log heights */
            #move-log {
                height: 150px;
            }

            #board-state-log {
                max-height: 60px;
            }

            .button-container {
                padding-top: 10px;
            }

            .game-button {
                padding: 8px 12px;
                font-size: 0.9em;
            }

            #debug-log-container {
                margin-top: 15px;
                width: 95vw;
                max-width: var(--board-max-width);
            }

            #debug-log-output {
                height: 150px;
            }
        }

        @media (max-width: 600px) {
            #board {
                padding: 16px 20px;
            }
        }
    </style>
</head>

<body>

    <h1>CLESTO: The Jungle Chess Game</h1>

    <main id="game-container" role="main">
        <!-- Game Board Section -->
        <section aria-labelledby="board-label">
            <h2 id="board-label" class="visually-hidden">Game Board</h2>
            <div id="board" tabindex="0"> <!-- Outer container for board background/focus -->
                <div id="board-grid-wrapper"> <!-- Inner container for grid layout and pieces -->
                    <!-- Cells will be generated by JavaScript here -->
                </div>
            </div>
        </section>

        <!-- UI and Information Section -->
        <section id="ui-info-section" role="region" aria-labelledby="ui-info-heading">
            <h2 id="ui-info-heading">Game Info</h2>

            <!-- START: Clock Displays -->
            <div class="clock-container" id="orange-clock-container">
                <span class="clock-label">Orange Time:</span>
                <span class="clock-time" id="orange-clock-time">10:00</span>
            </div>
            <div class="clock-container" id="yellow-clock-container">
                <span class="clock-label">Yellow Time:</span>
                <span class="clock-time" id="yellow-clock-time">10:00</span>
            </div>
            <!-- END: Clock Displays -->

            <p>Turn: <span id="turn-indicator">Orange</span></p>
            <p>Status: <span id="status-message" aria-live="polite">Loading...</span></p>

            <!-- Player vs Player Toggle -->
            <div class="pvp-toggle-container"> <!-- START: Add this container div -->
                <label for="pvp-toggle" class="pvp-label">Player vs Player Mode:</label>
                <div class="switch-icon-wrapper"> <!-- Wrapper for switch and icon -->
                    <label class="switch">
                        <input type="checkbox" id="pvp-toggle">
                        <span class="slider round"></span>
                    </label>
                    <span class="pvp-info-icon" tabindex="0" role="button" aria-label="About Player vs Player Mode" aria-describedby="pvp-tooltip-content">ⓘ</span>
                    <span class="tooltip-text" id="pvp-tooltip-content" role="tooltip">Two players take turns on the same device.</span>
                </div>
            </div> <!-- END: Add this container div -->

            <div class="button-container">
                <button id="undo-button" class="game-button" disabled>Undo Turn</button>
                <button id="reset-button" class="game-button">Reset Game</button>
            </div>

            <h3>Move Log</h3>
            <div id="move-log" role="log" aria-live="polite" aria-atomic="false">
                <!-- Log entries will be added by JavaScript here -->
            </div>

            <h3>Board State</h3>
            <div id="board-state-log">
                <!-- Board state string for debugging/repetition check -->
            </div>

            <!-- Load From State Section -->
            <div style="margin-top: 15px; border-top: 1px solid var(--medium-gray); padding-top: 10px;">
                <label for="board-state-input" style="display: block; margin-bottom: 5px; font-weight: bold;">Load Board State:</label>
                <input type="text" id="board-state-input" placeholder="Paste board state (e.g., 8G7,7A9,...)" style="width: calc(100% - 12px); padding: 6px; margin-bottom: 8px; border: 1px solid var(--medium-gray); border-radius: 3px;">
                <button id="load-state-button" class="game-button" style="background-color: #28a745;">Load Board State</button> <!-- Green button -->
                <p id="load-status-message" style="font-size: 0.85em; color: #6c757d; min-height: 1.2em; margin-top: 5px;"></p>
            </div>
            <!-- End Load From State Section -->
        </section>
    </main>

    <!-- Rules Accordion Section -->
    <section id="rules-accordion-container" aria-labelledby="rules-heading">
        <button id="rules-toggle-button" class="rules-toggle-button" aria-expanded="false" aria-controls="rules-content">
            <span class="rules-button-text">Show Game Rules</span>
            <span class="rules-icon" aria-hidden="true">+</span>
        </button>
        <div id="rules-content" class="rules-content" role="region" aria-hidden="true">
            <h2 id="rules-heading" class="visually-hidden">Game Rules</h2>

            <h3>Objective</h3>
            <p>Be the first player to move any of your animals into the opponent's <strong>Den</strong> square.</p>
            <ul>
                <li>Orange's Den: <strong>d1</strong></li>
                <li>Yellow's Den: <strong>d9</strong></li>
            </ul>

            <h3>Gameplay</h3>
            <ul>
                <li>Orange starts the game.</li>
                <li>Players take turns moving one animal per turn.</li>
                <li>Animals move one square horizontally or vertically (never diagonally).</li>
                <li>You cannot move onto a square occupied by your own animal.</li>
            </ul>

            <h4>Attacking</h4>
            <ul>
                <li>You can move onto a square occupied by an opponent's animal if your animal's rank is <strong>equal to or higher than</strong> the opponent's rank.</li>
                <li>This is an attack, and the opponent's captured animal is removed from the board.</li>
                <li><strong>Exception:</strong> See Special Powers for Rat vs. Elephant.</li>
            </ul>

            <h4>End of Turn Sequence</h4>
            <p>After making your move, the following checks happen automatically:</p>
            <ol>
                <li><strong>Declare Hungry:</strong> Any of the <em>opponent's</em> animals that can now make a valid attack are marked as <strong>hungry</strong> (red glow).</li>
                <li><strong>Check Starvation:</strong> If any of <em>your own</em> animals were marked as hungry at the <em>start</em> of your turn, but you did not make an attacking move with any of them, those hungry animals starve and are removed from the board.</li>
            </ol>

            <h4>Special Squares</h4>
            <ul>
                <li><strong>Den:</strong> Your own Den (Orange: d1, Yellow: d9) cannot be entered by your pieces. Reaching the opponent's Den wins the game. A <strong>hungry</strong> animal cannot enter the opponent's Den.</li>
                <li><strong>Water (b4-c6, e4-f6):</strong> Only specific animals can enter or move on water (see Special Powers).</li>
                <li><strong>Traps:</strong>
                    <ul>
                        <li>Orange Traps: <strong>c1, d2, e1</strong></li>
                        <li>Yellow Traps: <strong>c9, d8, e9</strong></li>
                    </ul>
                    Any animal landing on a Trap square has its rank effectively reduced to <strong>0</strong> for the purpose of being attacked while on that square. A "(0)" marker appears above trapped animals. However, an animal attacking <em>from</em> a trap square uses its normal rank.
                 </li>
            </ul>

            <h4>Other Rules</h4>
            <ul>
                <li>You must make a move each turn (passing is not allowed).</li>
                <li>The game cannot end in a draw.</li>
            </ul>

            <h3>Special Powers</h3>
            <ul>
                <li><strong>Rat [1]:</strong>
                    <ul>
                        <li>Can enter, move on, and <strong>attack from Water</strong> squares.</li>
                        <li>Can attack the <strong>Elephant [8]</strong>, but only when attacking from a land square (cannot attack Elephant when starting from Water).</li>
                    </ul>
                 </li>
                 <li><strong>Dog [3]:</strong>
                    <ul>
                         <li>Can enter, move on, and <strong>attack from Water</strong> squares.</li>
                    </ul>
                 </li>
                 <li><strong>Lion [7] and Tiger [6]:</strong>
                    <ul>
                        <li>Can <strong>jump</strong> horizontally or vertically over <strong>Water</strong> squares.</li>
                        <li>A jump moves from a land square directly across 2 or 3 water squares to another land square.</li>
                        <li>Jumps can be used to move or attack.</li>
                        <li>A jump is blocked if an opponent's swimming animal (Rat or Dog) occupies any water square along the jump path.</li>
                    </ul>
                </li>
                 <li><strong>Leopard [5]:</strong>
                    <ul>
                        <li>Can <strong>jump horizontally</strong> over <strong>Water</strong> squares (across 2 water squares).</li>
                        <li>Cannot jump vertically.</li>
                        <li>Jumps follow the same blocking rules as Lion/Tiger.</li>
                    </ul>
                </li>
                <li><strong>Elephant [8]:</strong> Can attack the Rat [1].</li>
            </ul>

            <h3>Repetition Limit</h3>
            <p>To prevent endless loops and ensure a winner, a repetition rule exists:</p>
            <ul>
                <li>Determine which player currently has more animals on the board. If tied, the starting player (Orange) is considered the "leading player".</li>
                <li>The leading player is <strong>not allowed</strong> to make a move that results in a board position that has already occurred <strong>3 times</strong> previously during the game.</li>
            </ul>
            <p><em>(Board positions are tracked automatically.)</em></p>

        </div><!-- /#rules-content -->
    </section><!-- /#rules-accordion-container -->

    <!-- Debug Log Section (conditionally displayed) -->
    <section id="debug-log-container" aria-labelledby="debug-log-heading">
        <h2 id="debug-log-heading">Debug Log</h2>
        <div id="debug-log-output">
            <!-- Console messages mirrored here if debug = true -->
        </div>
        <button id="clear-debug-log" class="game-button" style="margin-top: 10px; background-color: #dc3545;">Clear Log</button>
    </section>

    <!-- Utility class to visually hide elements but keep them accessible -->
    <style>
        .visually-hidden {
            position: absolute;
            width: 1px;
            height: 1px;
            margin: -1px;
            padding: 0;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            border: 0;
        }
    </style>

    <!-- Hidden container for preloading/caching piece image assets -->
    <div id="piece-assets" style="display: none;">
        <!-- Orange Pieces -->
        <img data-piece="O_8" src="https://staticjw.com/clesto/animals/elephant-orange.png" alt="Orange Elephant (8)" loading="lazy">
        <img data-piece="O_7" src="https://staticjw.com/clesto/animals/lion-orange.png" alt="Orange Lion (7)" loading="lazy">
        <img data-piece="O_6" src="https://staticjw.com/clesto/animals/tiger-orange.png" alt="Orange Tiger (6)" loading="lazy">
        <img data-piece="O_5" src="https://staticjw.com/clesto/animals/leopard-orange.png" alt="Orange Leopard (5)" loading="lazy">
        <img data-piece="O_4" src="https://staticjw.com/clesto/animals/wolf-orange.png" alt="Orange Wolf (4)" loading="lazy">
        <img data-piece="O_3" src="https://staticjw.com/clesto/animals/dog-orange.png" alt="Orange Dog (3)" loading="lazy">
        <img data-piece="O_2" src="https://staticjw.com/clesto/animals/cat-orange.png" alt="Orange Cat (2)" loading="lazy">
        <img data-piece="O_1" src="https://staticjw.com/clesto/animals/rat-orange.png" alt="Orange Rat (1)" loading="lazy">
        <!-- Yellow Pieces -->
        <img data-piece="Y_8" src="https://staticjw.com/clesto/animals/elephant-yellow.png" alt="Yellow Elephant (8)" loading="lazy">
        <img data-piece="Y_7" src="https://staticjw.com/clesto/animals/lion-yellow.png" alt="Yellow Lion (7)" loading="lazy">
        <img data-piece="Y_6" src="https://staticjw.com/clesto/animals/tiger-yellow.png" alt="Yellow Tiger (6)" loading="lazy">
        <img data-piece="Y_5" src="https://staticjw.com/clesto/animals/leopard-yellow.png" alt="Yellow Leopard (5)" loading="lazy">
        <img data-piece="Y_4" src="https://staticjw.com/clesto/animals/wolf-yellow.png" alt="Yellow Wolf (4)" loading="lazy">
        <img data-piece="Y_3" src="https://staticjw.com/clesto/animals/dog-yellow.png" alt="Yellow Dog (3)" loading="lazy">
        <img data-piece="Y_2" src="https://staticjw.com/clesto/animals/cat-yellow.png" alt="Yellow Cat (2)" loading="lazy">
        <img data-piece="Y_1" src="https://staticjw.com/clesto/animals/rat-yellow.png" alt="Yellow Rat (1)" loading="lazy">
    </div>

    <!-- Shared Tooltip for Move Log -->
    <span id="move-log-tooltip" class="log-tooltip shared-tooltip" role="tooltip" aria-hidden="true"></span>

    <!-- Turn Start Sound -->
    <audio id="turn-start-sound" src="notification-alert.mp3" preload="auto"></audio>

    <script>
    window.addEventListener('load', () => { // Changed from DOMContentLoaded
        // --- Debug Flag ---
        const debug = true; // SET TO true TO SHOW DEBUG PANEL, false TO HIDE

        // --- DOM Element References ---
        const boardElement = document.getElementById('board');
        const boardGridWrapper = document.getElementById('board-grid-wrapper');
        const turnIndicator = document.getElementById('turn-indicator');
        const statusMessage = document.getElementById('status-message');
        const resetButton = document.getElementById('reset-button');
        const undoButton = document.getElementById('undo-button');
        const moveLogElement = document.getElementById('move-log');
        const boardStateLogElement = document.getElementById('board-state-log');
        const pieceAssetContainer = document.getElementById('piece-assets');
        const debugLogContainer = document.getElementById('debug-log-container');
        const debugLogOutput = document.getElementById('debug-log-output');
        const clearDebugLogButton = document.getElementById('clear-debug-log');
        // --- DOM Element References (Add Clock Elements) ---
        const orangeClockContainer = document.getElementById('orange-clock-container');
        const yellowClockContainer = document.getElementById('yellow-clock-container');
        const orangeClockTimeElement = document.getElementById('orange-clock-time');
        const yellowClockTimeElement = document.getElementById('yellow-clock-time');
        // --- DOM Element References (Add Tooltip) ---
        const sharedMoveTooltip = document.getElementById('move-log-tooltip');
        const turnSoundElement = document.getElementById('turn-start-sound');


        // --- Console Override & Debug Panel Logic ---
        // Store original console methods
        const originalConsole = {
            log: console.log,
            warn: console.warn,
            error: console.error
        };

        /**
         * Formats console arguments into a single string, handling objects and circular references.
         * @param {Array} args - The arguments passed to the console method.
         * @returns {string} A formatted string representation of the arguments.
         */
        function formatArgs(args) {
            const seen = new Set(); // Used to detect circular references in objects
            return Array.from(args).map(arg => {
                if (typeof arg === 'object' && arg !== null) {
                    try {
                        // Stringify objects, handling circular references
                        seen.clear(); // Reset for each top-level object
                        return JSON.stringify(arg, (key, value) => {
                            if (typeof value === 'object' && value !== null) {
                                if (seen.has(value)) {
                                    return '[Circular]'; // Placeholder for circular reference
                                }
                                seen.add(value);
                            }
                            return value;
                        }, 2); // Indent with 2 spaces for readability
                    } catch (e) {
                        // Handle potential errors during stringification
                        if (e instanceof TypeError && e.message.includes('circular structure')) {
                            return '[Circular Object]';
                        }
                        return '[Unserializable Object]';
                    }
                }
                if (typeof arg === 'function') {
                    return '[Function]';
                }
                if (typeof arg === 'undefined') {
                    return 'undefined';
                }
                return String(arg); // Convert other types to string
            }).join(' '); // Join arguments with spaces
        }

        /**
         * Logs a message to the debug panel if debugging is enabled.
         * @param {string} level - The log level ('log', 'warn', 'error').
         * @param {Array} args - The original arguments passed to the console method.
         */
        function logToPanel(level, args) {
            if (!debug || !debugLogOutput) return; // Only log if debug is true and panel exists

            const message = formatArgs(args);
            const timestamp = new Date().toLocaleTimeString();
            const entry = document.createElement('div');
            entry.classList.add('debug-log-entry');

            // Add timestamp
            const timeSpan = document.createElement('span');
            timeSpan.classList.add('debug-log-timestamp');
            timeSpan.textContent = `[${timestamp}]`;
            entry.appendChild(timeSpan);

            // Add message content with appropriate styling
            const messageSpan = document.createElement('span');
            messageSpan.textContent = message;
            if (level === 'warn') {
                messageSpan.classList.add('debug-log-warn');
            } else if (level === 'error') {
                messageSpan.classList.add('debug-log-error');
            }
            entry.appendChild(messageSpan);

            // Append to panel and scroll to bottom
            debugLogOutput.appendChild(entry);
            debugLogOutput.scrollTop = debugLogOutput.scrollHeight;
        }

        // Override console methods to also log to the panel
        console.log = function(...args) {
            originalConsole.log.apply(console, args); // Call original console.log
            logToPanel('log', args); // Log to panel
        };
        console.warn = function(...args) {
            originalConsole.warn.apply(console, args); // Call original console.warn
            logToPanel('warn', args); // Log to panel
        };
        console.error = function(...args) {
            originalConsole.error.apply(console, args); // Call original console.error
            logToPanel('error', args); // Log to panel
        };

        // Show or hide the debug panel based on the debug flag
        if (!debug && debugLogContainer) {
            debugLogContainer.classList.add('debug-hidden');
        } else if (debugLogContainer) {
            debugLogContainer.classList.remove('debug-hidden');
        }

        // Add event listener for the "Clear Log" button
        if (clearDebugLogButton && debugLogOutput) {
            clearDebugLogButton.addEventListener('click', () => {
                debugLogOutput.innerHTML = ''; // Clear panel content
                console.log("Debug log cleared.");
            });
        }
        // --- END Console Override ---


        // --- Game Constants ---
        const ROWS = 9;
        const COLS = 7;
        const PLAYERS = {
            ORANGE: 'orange',
            YELLOW: 'yellow'
        };
        const RANK_TO_NAME = {
            8: 'Elephant',
            7: 'Lion',
            6: 'Tiger',
            5: 'Leopard',
            4: 'Wolf',
            3: 'Dog',
            2: 'Cat',
            1: 'Rat'
        };
        const RANK_TO_CODE = { // Used for move notation
            8: '8',
            7: '7',
            6: '6',
            5: '5',
            4: '4',
            3: '3',
            2: '2',
            1: '1'
        };
        const SPECIAL_ABILITIES = { // Defines unique animal traits
            1: {
                name: 'Rat',
                rank: 1,
                swims: true,
                attacksElephant: true
            }, // Can swim, attack Elephant (unless Elephant is in water)
            2: {
                name: 'Cat',
                rank: 2
            },
            3: {
                name: 'Dog',
                rank: 3,
                swims: true
            }, // Can swim
            4: {
                name: 'Wolf',
                rank: 4
            },
            5: {
                name: 'Leopard',
                rank: 5,
                jumpH: true
            }, // Can jump horizontally over water
            6: {
                name: 'Tiger',
                rank: 6,
                jumpH: true,
                jumpV: true
            }, // Can jump horizontally and vertically over water
            7: {
                name: 'Lion',
                rank: 7,
                jumpH: true,
                jumpV: true
            }, // Can jump horizontally and vertically over water
            8: {
                name: 'Elephant',
                rank: 8
            } // Cannot be attacked by Rat (except special case)
        };
        const INITIAL_SETUP = { // Standard starting positions
            // Orange Pieces (Bottom Row Area) - Sorted Rank 8 to 1
            'a3': { player: PLAYERS.ORANGE, rank: 8 }, // Elephant
            'g1': { player: PLAYERS.ORANGE, rank: 7 }, // Lion
            'a1': { player: PLAYERS.ORANGE, rank: 6 }, // Tiger
            'e3': { player: PLAYERS.ORANGE, rank: 5 }, // Leopard
            'f2': { player: PLAYERS.ORANGE, rank: 4 }, // Wolf
            'c3': { player: PLAYERS.ORANGE, rank: 3 }, // Dog
            'b2': { player: PLAYERS.ORANGE, rank: 2 }, // Cat
            'g3': { player: PLAYERS.ORANGE, rank: 1 }, // Rat
            // Yellow Pieces (Top Row Area) - Sorted Rank 8 to 1
            'g7': { player: PLAYERS.YELLOW, rank: 8 }, // Elephant
            'a9': { player: PLAYERS.YELLOW, rank: 7 }, // Lion
            'g9': { player: PLAYERS.YELLOW, rank: 6 }, // Tiger
            'c7': { player: PLAYERS.YELLOW, rank: 5 }, // Leopard
            'b8': { player: PLAYERS.YELLOW, rank: 4 }, // Wolf
            'e7': { player: PLAYERS.YELLOW, rank: 3 }, // Dog
            'f8': { player: PLAYERS.YELLOW, rank: 2 }, // Cat
            'a7': { player: PLAYERS.YELLOW, rank: 1 }  // Rat
        };
        const WATER_SQUARES = new Set(['b4', 'c4', 'e4', 'f4', 'b5', 'c5', 'e5', 'f5', 'b6', 'c6', 'e6', 'f6']);
        const TRAPS = { // Opponent's pieces lose rank on these squares
            orange: new Set(['c9', 'd8', 'e9']), // Traps near Yellow's Den (affect Yellow pieces)
            yellow: new Set(['c1', 'd2', 'e1']) // Traps near Orange's Den (affect Orange pieces)
        };
        const ALL_TRAP_SQUARES = new Set([...TRAPS.orange, ...TRAPS.yellow]);
        const DENS = { // Winning squares for each player
            orange: 'd1', // Orange's Den
            yellow: 'd9' // Yellow's Den
        };
        const MINIMAX_DEPTH = 3; // Depth for AI search (higher = stronger but slower)

        // --- AI Evaluation Constants (Tunable - Aggressive + Strategic + Win Focus) ---
        const AI_WIN_SCORE = 10000;
        const AI_LOSE_SCORE = -10000;
        // --- Offensive Bonuses ---
        const AI_ADVANCE_BONUS_MULT = 2.0;   // Bonus per row advanced (Reduced - rely on specifics)
        const AI_PAST_RIVER_BONUS = 25;      // Bonus for any piece being past the river center (Increased)
        const AI_NEAR_OPP_DEN_BONUS = 85;    // Bonus for AI near opponent's den (High)
        const AI_DEN_PROXIMITY_BONUS_SQ = 700; // HUGE Bonus for being 1 square away (Increased)
        const AI_DEN_PROXIMITY_BONUS_2SQ = 250; // Large Bonus for being 2 squares away (Increased)
        const AI_WIN_ADJACENT_BONUS_FACTOR = 1.1; // Multiplier for Win Score (e.g., WIN_SCORE / 1.1) (NEW)
        const AI_MULTI_ATTACKER_BONUS = 55;  // Bonus for multiple pieces near opponent den
        const AI_NEAR_OPP_TRAP_BONUS = 20;   // Bonus for AI near opponent's traps (offense)
        const AI_OFFENSIVE_MOBILITY_BONUS_MULT = 0.4; // Bonus per FORWARD/ATTACK move (Low)
        const AI_CENTER_CONTROL_BONUS = 12;  // Bonus for controlling c,d,e columns past river
        const AI_JUMPER_OFFENSE_BONUS = 55;  // Extra bonus for Lion/Tiger advancing (High)
        const AI_LEOPARD_OFFENSE_BONUS = 40; // Extra bonus for Leopard advancing
        const AI_DOG_OFFENSE_BONUS = 40;     // Extra bonus for Dog advancing (Increased)
        const AI_RAT_OFFENSE_BONUS = 35;     // Extra bonus for Rat advancing
        const AI_THREATENS_OPPONENT_BONUS = 80; // Bonus for threatening a capture next turn
        const AI_CAPTURE_BONUS_MULT = 1.4;   // Multiplier for captured piece value
        const AI_WATER_CONTROL_BONUS = 35;   // Bonus for Rat/Dog on water (Increased)
        const AI_CLEAR_HUNGER_ATTACK_BONUS = 150; // Specific bonus for making a required hungry attack (NEW)
        // --- Defensive/Strategic Penalties & Wolf/Cat Specific ---
        const AI_IMMEDIATE_WIN_THREAT_PENALTY = -3000; // Opponent can win next turn
        const AI_NEAR_OWN_DEN_PENALTY = -5;          // Opponent piece near AI den
        const AI_PIECE_TOO_DEFENSIVE_PENALTY = -5;   // General penalty for pieces sitting too far back
        const AI_WOLF_CAT_DEFENSE_BONUS = 10;        // BONUS for Wolf/Cat being defensive early
        const AI_WOLF_CAT_ADVANCE_PENALTY_MULT = -3.5;// PENALTY per row Wolf/Cat advance (Increased)
        const AI_BLOCKING_JUMPER_PENALTY = -200;     // Penalty for Wolf/Cat blocking jump squares (Increased)
        const AI_TRAP_DANGER_PENALTY = -150;         // AI piece vulnerable ON a trap
        const AI_TRAP_ATTACK_VULNERABILITY = -100;   // AI piece vulnerable TO a trap attack
        const AI_IS_THREATENED_PENALTY = -15;        // Penalty if AI piece can be captured next turn
        // --- Piece Values ---
        const AI_PIECE_VALUES = { 1: 45, 2: 5, 3: 50, 4: 20, 5: 45, 6: 70, 7: 80, 8: 70 };

        // --- Game State Variables ---
        let gameState = {}; // Holds current board, player, turn, etc.
        let gameHistory = []; // Stores previous game states for undo functionality
        let draggedPieceElement = null; // Reference to the DOM element being dragged
        let sourceCoords = null; // Coordinates of the piece being dragged/clicked
        let selectedPieceCoords = null; // Coordinates of the piece selected via click/tap
        let focusedCoords = null; // Coordinates of the currently focused cell/piece (for keyboard nav)
        let playerLastMoves = {
            [PLAYERS.ORANGE]: { from: null, to: null },
            [PLAYERS.YELLOW]: { from: null, to: null }
        };
        let isDragging = false; // Flag to track if a drag operation is in progress
        let isPlayerVsPlayerMode = false; // Flag for PvP mode (default is PvE)
        let aiMoveTimeoutId = null; // To store the AI delay timeout
        let isLoadStateInputFocused = false; // Flag for input focus

        // --- Clock Constants & State ---
        const INITIAL_TIME_SECONDS = 10 * 60; // 10 minutes
        const INCREMENT_SECONDS = 2; // 2 seconds bonus per move
        let orangeTime = INITIAL_TIME_SECONDS;
        let yellowTime = INITIAL_TIME_SECONDS;
        let orangeTimerId = null; // To store the interval ID for Orange's clock
        let yellowTimerId = null; // To store the interval ID for Yellow's clock


        // --- Utility Functions ---
        /**
         * Converts zero-based row and column indices to algebraic notation (e.g., 0,0 -> 'a9').
         * @param {number} row - The row index (0-8).
         * @param {number} col - The column index (0-6).
         * @returns {string|null} The algebraic coordinates (e.g., 'a1', 'g9') or null if invalid.
         */
        function getCoords(row, col) {
            if (row < 0 || row >= ROWS || col < 0 || col >= COLS) return null;
            // Column 'a' is ASCII 97. Row 9 is at index 0.
            return `${String.fromCharCode(97 + col)}${ROWS - row}`;
        }

        /**
         * Converts algebraic notation coordinates to zero-based row and column indices.
         * @param {string} coords - The algebraic coordinates (e.g., 'a1').
         * @returns {{row: number, col: number}|null} An object with row and col indices, or null if invalid.
         */
        function getRowCol(coords) {
            if (!coords || coords.length < 2) return null;
            const col = coords.charCodeAt(0) - 97; // 'a' -> 0, 'b' -> 1, ...
            const rowNum = parseInt(coords.substring(1));
            if (isNaN(rowNum)) return null;
            const row = ROWS - rowNum; // '9' -> 0, '8' -> 1, ...
            if (row < 0 || row >= ROWS || col < 0 || col >= COLS) return null;
            return { row, col };
        }

        /**
         * Determines which player is currently restricted by the repetition rule.
         * The player with more pieces is restricted. If piece counts are equal, Orange is restricted.
         * @param {object} [board=gameState.board] - The board state to evaluate. Defaults to current game state.
         * @returns {string} The player ('orange' or 'yellow') who is restricted.
         */
        function getRestrictedPlayer(board = gameState.board) {
            const orangeCount = Object.values(board).filter(p => p?.player === PLAYERS.ORANGE).length;
            const yellowCount = Object.values(board).filter(p => p?.player === PLAYERS.YELLOW).length;

            if (orangeCount > yellowCount) {
                return PLAYERS.ORANGE;
            } else if (yellowCount > orangeCount) {
                return PLAYERS.YELLOW;
            } else {
                // If counts are equal, the starting player (Orange) is restricted
                return PLAYERS.ORANGE;
            }
        }

        /**
         * Retrieves the data object for a piece at the given coordinates from the current game state.
         * @param {string} coords - The algebraic coordinates (e.g., 'a1').
         * @returns {object|null} The piece data object ({player, rank, ...}) or null if the square is empty.
         */
        function getPieceData(coords) {
            return gameState.board[coords] || null;
        }

        /**
         * Generates the DOM ID for a piece element based on its coordinates.
         * @param {string} coords - The coordinates (e.g., 'a1').
         * @returns {string} The DOM ID string (e.g., 'piece-a1').
         */
        function getPieceElementId(coords) {
            return `piece-${coords}`;
        }

        /**
         * Generates the DOM ID for a cell element based on coordinates.
         * @param {string} coords - The coordinates (e.g., 'a1').
         * @returns {string} The DOM ID string (e.g., 'cell-a1').
         */
        function getCellElementId(coords) {
            return `cell-${coords}`;
        }

        /**
         * Gets orthogonal adjacent coordinates for a given square.
         * @param {string} coords - The algebraic coordinates (e.g., 'd9').
         * @returns {string[]} An array of valid adjacent coordinate strings.
         */
        function getAdjacentCoords(coords) {
            const adjacent = [];
            const rc = getRowCol(coords);
            if (!rc) return [];
            const { row, col } = rc;
            const potential = [
                getCoords(row + 1, col), // Down
                getCoords(row - 1, col), // Up
                getCoords(row, col + 1), // Right
                getCoords(row, col - 1)  // Left
            ];
            potential.forEach(c => {
                if (c) adjacent.push(c); // Add if valid coords
            });
            return adjacent;
        }

        /**
         * Gets a set of unique adjacent coordinates for a given set of starting coordinates.
         * @param {Set<string>} coordsSet - A Set of algebraic coordinates (e.g., trap squares).
         * @returns {Set<string>} A Set of unique, valid adjacent coordinate strings.
         */
        function getAdjacentCoordsSet(coordsSet) {
            const allAdjacent = new Set();
            if (!coordsSet) return allAdjacent;

            coordsSet.forEach(coord => {
                const adjacent = getAdjacentCoords(coord); // Use existing helper
                adjacent.forEach(adjCoord => {
                    if (adjCoord) allAdjacent.add(adjCoord);
                });
            });
            return allAdjacent;
        }

        /**
         * Checks if the given coordinates correspond to ANY trap square.
         * @param {string} coords - The algebraic coordinates to check.
         * @returns {boolean} True if the coordinates are a trap square, false otherwise.
         */
        function isOnTrapSquare(coords) {
            if (!coords) return false;
            // Use the pre-defined Set containing all trap squares
            return ALL_TRAP_SQUARES.has(coords);
        }


        // --- Clock Helper Functions ---
        /**
         * Formats remaining seconds into MM:SS string format.
         * @param {number} totalSeconds - The total seconds remaining.
         * @returns {string} Formatted time string (e.g., "09:58").
         */
        function formatTime(totalSeconds) {
            const seconds = Math.max(0, totalSeconds); // Ensure time doesn't go below 0
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = Math.floor(seconds % 60);
            const formattedMinutes = String(minutes).padStart(2, '0');
            const formattedSeconds = String(remainingSeconds).padStart(2, '0');
            return `${formattedMinutes}:${formattedSeconds}`;
        }

        /**
         * Plays the turn start sound effect.
         */
        function playTurnSound() {
            if (turnSoundElement) {
                // Reset playback position in case it's triggered quickly
                turnSoundElement.currentTime = 0;
                // Play the sound, handling potential browser errors/restrictions
                turnSoundElement.play().catch(error => {
                    console.warn("Turn start sound playback failed:", error);
                    // Autoplay might be blocked by the browser if no user interaction occurred yet,
                    // but usually okay after first move.
                });
            } else {
                console.warn("Turn start sound element not found.");
            }
        }

        /**
         * Updates the clock display for a specific player in the DOM.
         * Also adds/removes a 'time-out' class if the time is zero or less.
         * @param {string} player - The player ('orange' or 'yellow').
         * @param {number} timeSeconds - The time in seconds to display.
         */
        function updateClockDisplay(player, timeSeconds) {
            const formattedTime = formatTime(timeSeconds);
            let clockElement = null;

            if (player === PLAYERS.ORANGE && orangeClockTimeElement) {
                clockElement = orangeClockTimeElement;
            } else if (player === PLAYERS.YELLOW && yellowClockTimeElement) {
                clockElement = yellowClockTimeElement;
            }

            if (clockElement) {
                clockElement.textContent = formattedTime; // Update time text

                // Add or remove the 'time-out' class based on the time value
                if (timeSeconds <= 0) {
                    clockElement.classList.add('time-out');
                } else {
                    clockElement.classList.remove('time-out');
                }
            }
        }

        /**
         * Stops the interval timer for a specific player's clock.
         * @param {string} player - The player ('orange' or 'yellow').
         */
        function stopClock(player) {
            if (player === PLAYERS.ORANGE) {
                if (orangeTimerId !== null) {
                    clearInterval(orangeTimerId);
                    orangeTimerId = null;
                    // console.log("Stopped Orange Clock");
                }
                 if (orangeClockContainer) orangeClockContainer.classList.remove('clock-active');
            } else if (player === PLAYERS.YELLOW) {
                if (yellowTimerId !== null) {
                    clearInterval(yellowTimerId);
                    yellowTimerId = null;
                    // console.log("Stopped Yellow Clock");
                }
                if (yellowClockContainer) yellowClockContainer.classList.remove('clock-active');
            }
        }

        /**
         * Starts the interval timer for a specific player's clock.
         * @param {string} player - The player ('orange' or 'yellow') whose clock to start.
         */
        function startClock(player) {
            // Don't start if game is over
            if (gameState.gameOver) return;

            // Stop the other player's clock first (safety measure)
            const otherPlayer = player === PLAYERS.ORANGE ? PLAYERS.YELLOW : PLAYERS.ORANGE;
            stopClock(otherPlayer);

            // Clear existing timer for the target player before starting a new one
            stopClock(player);

            // console.log(`Starting Clock for: ${player}`);
            const tick = () => {
                if (player === PLAYERS.ORANGE) {
                    orangeTime--;
                    updateClockDisplay(PLAYERS.ORANGE, orangeTime);
                    if (orangeTime <= 0) {
                        // console.log("Orange time ran out.");
                        stopClock(PLAYERS.ORANGE); // Stop the clock at 00:00
                        // Requirement: Do nothing else when time runs out
                    }
                } else if (player === PLAYERS.YELLOW) {
                    yellowTime--;
                    updateClockDisplay(PLAYERS.YELLOW, yellowTime);
                    if (yellowTime <= 0) {
                        // console.log("Yellow time ran out.");
                        stopClock(PLAYERS.YELLOW); // Stop the clock at 00:00
                         // Requirement: Do nothing else when time runs out
                    }
                }
            };

            // Initial immediate tick to avoid 1-second delay on start/resume
            tick();
            // Then set the interval
            if (player === PLAYERS.ORANGE) {
                orangeTimerId = setInterval(tick, 1000);
                if(orangeClockContainer) orangeClockContainer.classList.add('clock-active');
            } else if (player === PLAYERS.YELLOW) {
                yellowTimerId = setInterval(tick, 1000);
                if(yellowClockContainer) yellowClockContainer.classList.add('clock-active');
            }
        }

        /**
         * Stops both players' clocks. Used for game end or pausing.
         */
        function pauseAllClocks() {
            stopClock(PLAYERS.ORANGE);
            stopClock(PLAYERS.YELLOW);
            console.log("Paused All Clocks");
        }

        /**
         * Resets clock times to initial values and updates displays. Stops timers.
         */
        function initializeClocks() {
            pauseAllClocks(); // Ensure any running timers are stopped
            orangeTime = INITIAL_TIME_SECONDS;
            yellowTime = INITIAL_TIME_SECONDS;
            updateClockDisplay(PLAYERS.ORANGE, orangeTime);
            updateClockDisplay(PLAYERS.YELLOW, yellowTime);
             if(orangeClockContainer) orangeClockContainer.classList.remove('clock-active');
             if(yellowClockContainer) yellowClockContainer.classList.remove('clock-active');
            console.log("Clocks Initialized");
        }

        /**
         * Stops the clock of the player who just moved, adds increment, updates their display,
         * and starts the opponent's clock. Call this *before* switching gameState.currentPlayer.
         * @param {string} playerWhoMoved - The player who just completed their move.
         */
        function switchClocks(playerWhoMoved) {
            if (gameState.gameOver) return; // Don't switch if game ended

            // 1. Stop the clock for the player who moved
            stopClock(playerWhoMoved);

            // 2. Add increment
            if (playerWhoMoved === PLAYERS.ORANGE) {
                orangeTime += INCREMENT_SECONDS;
                updateClockDisplay(PLAYERS.ORANGE, orangeTime);
            } else if (playerWhoMoved === PLAYERS.YELLOW) {
                yellowTime += INCREMENT_SECONDS;
                updateClockDisplay(PLAYERS.YELLOW, yellowTime);
            }
             console.log(`${playerWhoMoved} clock stopped, increment added.`);

            // 3. Start the opponent's clock
            const opponent = playerWhoMoved === PLAYERS.ORANGE ? PLAYERS.YELLOW : PLAYERS.ORANGE;
            startClock(opponent);
        }

        /**
         * Resumes the clock for the currently active player based on gameState.
         * Used after loading state (undo) or switching game modes.
         */
        function resumeClockForCurrentPlayer() {
             if (gameState.gameOver) {
                 pauseAllClocks();
                 return;
             }
             console.log(`Resuming clock for current player: ${gameState.currentPlayer}`);
             startClock(gameState.currentPlayer);
        }

        /**
         * Parses move notation and generates a human-readable description,
         * including information about captures, declared hungry, and starvation.
         * @param {string} notation - The move notation (e.g., "1g4", "8xa1++", "7xf7x", "6a1xx").
         * @returns {string} A descriptive string explaining the move.
         */
        function generateMoveDescription(notation) {
            if (!notation || notation === '...') return ''; // Handle empty or placeholder notations

            // Regex to parse the notation:
            // Group 1: Rank ([1-8])
            // Group 2: Capture marker ('x', optional, *immediately after rank*)
            // Group 3: Destination ([a-g][1-9])
            // Group 4: Hungry markers ('+', zero or more, optional)
            // Group 5: Starvation markers ('x', zero or more, optional, *at the end*)
            const moveRegex = /^([1-8])(x)?([a-g][1-9])(\+*)(x*)$/;
            const match = notation.match(moveRegex);

            if (!match) {
                console.warn("Could not parse move notation for tooltip:", notation);
                return notation; // Return original notation if parsing fails
            }

            const rank = parseInt(match[1], 10);
            const pieceName = RANK_TO_NAME[rank] || `Rank ${rank}`;
            const wasCapture = match[2] === 'x'; // Capture is the 'x' right after the rank
            const destination = match[3];
            const hungryDeclared = match[4] && match[4].length > 0;
            const hungryCount = hungryDeclared ? match[4].length : 0;
            const starvedCount = match[5] ? match[5].length : 0; // Count trailing 'x's

            let description = `${pieceName} [${rank}]`;

            // Describe the primary action (move or capture)
            if (wasCapture) {
                description += ` captured on ${destination}`;
            } else {
                description += ` moved to ${destination}`;
            }

            // Add hungry declaration info
            if (hungryDeclared) {
                description += `, declaring ${hungryCount} hungry`;
            }

            // Add starvation info
            if (starvedCount > 0) {
                description += ` (${starvedCount} starved)`;
            }

            return description + "."; // Add a period at the end
        }

        // --- Board Creation and Setup ---

        /**
         * Creates the grid of cell elements and appends them to the board wrapper.
         * Assigns IDs, data attributes, classes for terrain, and event listeners.
         */
        function createBoard() {
            boardGridWrapper.innerHTML = ''; // Clear existing board elements
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const cell = document.createElement('div');
                    const coords = getCoords(r, c);
                    cell.id = getCellElementId(coords);
                    cell.classList.add('cell');
                    cell.dataset.coords = coords; // Store coords for easy access
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    cell.setAttribute('role', 'gridcell'); // Accessibility
                    cell.setAttribute('tabindex', '-1'); // Make focusable via script/keyboard nav

                    // Add terrain classes based on coordinates
                    if (WATER_SQUARES.has(coords)) cell.classList.add('water');
                    if (TRAPS.orange.has(coords)) cell.classList.add('trap-yellow'); // Trap in Yellow's area
                    if (TRAPS.yellow.has(coords)) cell.classList.add('trap-orange'); // Trap in Orange's area
                    if (DENS.orange === coords) cell.classList.add('den-orange');
                    if (DENS.yellow === coords) cell.classList.add('den-yellow');

                    boardGridWrapper.appendChild(cell);

                    // Add event listeners for drag & drop and clicks
                    cell.addEventListener('dragover', handleDragOver);
                    cell.addEventListener('dragenter', handleDragEnter);
                    cell.addEventListener('dragleave', handleDragLeave);
                    cell.addEventListener('drop', handleDrop);
                    cell.addEventListener('click', handleCellClick);
                    cell.addEventListener('focus', () => focusedCoords = coords); // Track focus for keyboard nav
                }
            }
        }

        /**
         * Creates a DOM element for a game piece.
         * @param {object} pieceData - The piece data ({ player, rank, ... }).
         * @param {string} coords - The algebraic coordinates where the piece is located.
         * @returns {HTMLElement} The created piece div element.
         */
        function createPieceElement(pieceData, coords) {
            const pieceElement = document.createElement('div');
            pieceElement.id = getPieceElementId(coords);
            pieceElement.classList.add('piece');
            pieceElement.dataset.rank = pieceData.rank;
            pieceElement.dataset.player = pieceData.player;
            pieceElement.dataset.coords = coords;
            pieceElement.setAttribute('role', 'button'); // Treat piece like a button for accessibility
            pieceElement.setAttribute('aria-label', `${pieceData.player} ${RANK_TO_NAME[pieceData.rank]} at ${coords}`);
            pieceElement.setAttribute('tabindex', '-1'); // Make focusable conditionally

            // Find and clone the corresponding image from the hidden asset container
            const pieceKey = `${pieceData.player === PLAYERS.ORANGE ? 'O' : 'Y'}_${pieceData.rank}`;
            const asset = pieceAssetContainer.querySelector(`[data-piece="${pieceKey}"]`);

            if (asset && asset.tagName === 'IMG') {
                const img = asset.cloneNode(true); // Clone the preloaded image
                pieceElement.appendChild(img);
            } else {
                // Fallback if image asset is missing
                console.warn("Image asset not found for:", pieceKey);
                pieceElement.textContent = `${pieceData.player === PLAYERS.ORANGE ? 'O' : 'Y'}${pieceData.rank}`; // Display text
                pieceElement.classList.add(pieceData.player); // Add player color class
            }

            // Add event listeners for interactions
            pieceElement.addEventListener('dragstart', handleDragStart);
            pieceElement.addEventListener('dragend', handleDragEnd);
            pieceElement.addEventListener('touchstart', handleTouchStart, { passive: false }); // Need preventDefault
            pieceElement.addEventListener('touchmove', handleTouchMove, { passive: false }); // Need preventDefault
            pieceElement.addEventListener('touchend', handleTouchEnd);
            pieceElement.addEventListener('click', handlePieceClick);
            pieceElement.addEventListener('mouseover', handlePieceMouseOver); // For hover effects
            pieceElement.addEventListener('mouseout', handlePieceMouseOut);
            pieceElement.addEventListener('focus', () => focusedCoords = coords); // Track focus

            // Allow pieces to be drop targets (for captures)
            pieceElement.addEventListener('drop', handleDrop);
            pieceElement.addEventListener('dragover', handleDragOver);
            pieceElement.addEventListener('dragenter', handleDragEnterPiece);
            pieceElement.addEventListener('dragleave', handleDragLeavePiece);
            // Add the trap indicator span (initially hidden)
            const indicatorSpan = document.createElement('span');
            indicatorSpan.classList.add('trap-rank-indicator'); // Base class for styling
            indicatorSpan.textContent = '(0)'; // The text content
            pieceElement.appendChild(indicatorSpan); // Append it inside the piece div

            return pieceElement;
        }

        /**
         * Checks if the specified player has any move that wins immediately (reaches opponent's den).
         * Logs checks during non-simulation calls.
         * @param {object} boardState - The board state to check.
         * @param {string} player - The player whose winning moves to check.
         * @param {boolean} [isSimulation=false] - Flag to suppress logging. // NEW PARAMETER
         * @returns {object|null} The winning move ({ from, to }) or null if none found.
         */
        function findImmediateWinningMove(boardState, player, isSimulation = false) { // ADD isSimulation
            const opponentDen = player === PLAYERS.ORANGE ? DENS.yellow : DENS.orange;
            // Pass isSimulation flag down
            const moves = getAllValidMoves(boardState, player, isSimulation); // Use simulation flag
            if (!isSimulation) console.log(`[AI Win Check] Checking ${moves.length} moves for immediate win to ${opponentDen}`); // Log start

            for (const move of moves) {
                if (move.to === opponentDen) {
                    const movingPiece = boardState[move.from];
                    const isHungry = movingPiece?.isHungry || false; // Default to false if piece missing (shouldn't happen)

                    // Log the check result ONLY if not simulating
                    if (!isSimulation) {
                         if (isHungry) {
                             console.log(`[AI Win Check] Found potential win ${move.from} -> ${move.to}. DISCARDED (Piece is hungry).`);
                         } else {
                              console.log(`[AI Win Check] Found VALID win ${move.from} -> ${move.to}.`);
                         }
                    }

                    // Return the move ONLY if piece is NOT hungry
                    if (!isHungry) {
                        return move; // Found a valid winning move
                    }
                    // If hungry, continue loop to check other moves (unlikely but possible)
                }
            }
             if (!isSimulation) console.log(`[AI Win Check] No immediate winning move found.`); // Log end if no win found
            return null; // No non-hungry winning move found
        }

        /**
         * Checks if the opponent has any winning moves on their next turn.
         * @param {object} currentBoardState - The current board state.
         * @param {string} currentPlayer - The player whose turn it currently IS.
         * @returns {Array<object>} An array of the opponent's winning moves [{ from, to }, ...]. Empty if none.
         */
        function getOpponentWinningMoves(currentBoardState, currentPlayer) {
            const opponent = currentPlayer === PLAYERS.ORANGE ? PLAYERS.YELLOW : PLAYERS.ORANGE;
            const opponentWinningMoves = [];
            // Simulate opponent's perspective - opponent is 'player', current AI player's den is 'opponentDen'
            const winningDenForOpponent = opponent === PLAYERS.ORANGE ? DENS.yellow : DENS.orange;

            const opponentMoves = getAllValidMoves(currentBoardState, opponent, true); // Simulate check
            for (const move of opponentMoves) {
                if (move.to === winningDenForOpponent) {
                     // Ensure opponent piece isn't hungry
                     if (!currentBoardState[move.from]?.isHungry) {
                        opponentWinningMoves.push(move);
                    }
                }
            }
            return opponentWinningMoves;
        }

        /**
         * Finds all moves the AI can make that prevent *all* of the opponent's immediate winning moves.
         * @param {object} currentGameState - The current game state object.
         * @param {Array<object>} aiMoves - All valid moves the AI can make.
         * @param {Array<object>} opponentWins - The list of opponent's winning moves.
         * @returns {Array<object>} A filtered list of AI moves that counter all threats.
         */
        function findCounterMoves(currentGameState, aiMoves, opponentWins) {
            if (!opponentWins || opponentWins.length === 0) return aiMoves; // No threats to counter

            const counterMoves = [];
            for (const aiMove of aiMoves) {
                // Simulate the AI making this move
                const nextState = simulateMove(currentGameState, aiMove);
                // Check if the opponent *still* has any winning moves in the resulting state
                const opponentWinsAfterAIMove = getOpponentWinningMoves(nextState.board, nextState.currentPlayer); // Check opponent in the *new* state

                if (opponentWinsAfterAIMove.length === 0) {
                    // This AI move successfully prevents all opponent wins
                    counterMoves.push(aiMove);
                }
            }
            return counterMoves;
        }

        /**
         * Clears existing pieces from the board and places new ones based on the current game state.
         * Also applies initial hungry and trap indicator visuals.
         */
        function placePieces() {

            // Remove all existing piece elements from the board
            boardGridWrapper.querySelectorAll('.piece').forEach(p => p.remove());

            // Iterate through the board state and create/place pieces
            for (const coords in gameState.board) {
                if (gameState.board.hasOwnProperty(coords)) {
                    const pieceData = gameState.board[coords];
                    if (!pieceData) {
                        console.warn(`Attempted to place null piece at ${coords}`);
                        continue;
                    }
                    // Create the piece element
                    const pieceElement = createPieceElement(pieceData, coords);
                    // Position it correctly on the grid
                    positionElementOnBoard(pieceElement, coords);
                    // Add it to the board
                    boardGridWrapper.appendChild(pieceElement);
                    // Apply 'hungry' visual if needed
                    updateHungryVisual(coords, pieceData.isHungry || false, pieceElement);
                    // Set initial accessibility (draggable/focusable) - will be refined below
                    // updatePieceAccessibility(pieceElement); // Deferred to end of function

                    // Check and apply trap indicator visual
                    const isPieceOnTrap = isOnTrapSquare(coords);
                    updateTrapIndicatorVisual(coords, isPieceOnTrap, pieceElement);
                }
            }
             // Ensure accessibility is correctly set after all pieces are placed
             updateAllPieceAccessibility();
        }

        /**
         * Calculates and sets the absolute CSS position (left, top percentages) for a piece element
         * within the board grid wrapper, ensuring it's centered within its target cell.
         * Also ensures the piece maintains its aspect ratio.
         * @param {HTMLElement} element - The piece element to position.
         * @param {string} coords - The algebraic coordinates of the target cell.
         */
        function positionElementOnBoard(element, coords) {
             const rc = getRowCol(coords);
             if (!rc) {
                 console.error("Cannot position element, invalid coords:", coords);
                 return;
             }
             const { row, col } = rc;

             // Calculate cell dimensions as percentages of the grid wrapper
             const cellWidthPercent = 100 / COLS; // e.g., 100 / 7 ≈ 14.28%
             const cellHeightPercent = 100 / ROWS; // e.g., 100 / 9 ≈ 11.11%

             // Get the piece's width as a percentage of the wrapper (must match CSS)
             const pieceWidthPercent = parseFloat(element.style.width || '12.07'); // Use CSS value or default

             // Calculate piece height percentage to maintain 1:1 aspect ratio based on actual pixel dimensions
             const wrapperWidth = boardGridWrapper.offsetWidth;
             const wrapperHeight = boardGridWrapper.offsetHeight;
             let pieceHeightPercent = pieceWidthPercent * (wrapperWidth / wrapperHeight); // Initial calculation based on width %

             // If wrapper dimensions are available, refine the height percentage calculation
             if (wrapperHeight > 0 && wrapperWidth > 0) {
                 const pieceWidthPx = wrapperWidth * (pieceWidthPercent / 100);
                 // Calculate the height % needed to make pixel height equal to pixel width
                 pieceHeightPercent = (pieceWidthPx / wrapperHeight) * 100;
                 // Explicitly set height style to ensure consistency if calculated
                 element.style.height = `${pieceHeightPercent}%`;
             } else {
                // Fallback if dimensions aren't ready - rely on aspect-ratio CSS
                element.style.height = 'auto'; // Let CSS aspect-ratio handle height
             }
             // Ensure width is set (might have been auto initially)
             element.style.width = `${pieceWidthPercent}%`;


             // Calculate the top-left corner of the target cell (relative to the wrapper)
             const cellLeftPercent = col * cellWidthPercent;
             const cellTopPercent = row * cellHeightPercent;

             // Calculate the offset needed to center the piece within the cell
             const offsetXPercent = (cellWidthPercent - pieceWidthPercent) / 2;
             const offsetYPercent = (cellHeightPercent - pieceHeightPercent) / 2; // Use the calculated piece height %

             // Calculate the final top-left position for the piece element
             const finalLeftPercent = cellLeftPercent + offsetXPercent;
             const finalTopPercent = cellTopPercent + offsetYPercent;

             // Apply the calculated position
             element.style.left = `${finalLeftPercent}%`;
             element.style.top = `${finalTopPercent}%`;

             // Reset any transform applied during dragging/animations
             element.style.transform = '';
             // Update the element's coordinate data attribute
             element.dataset.coords = coords;
        }


        /**
         * Updates the tabindex, draggable attributes, AND cursor style (via .movable class)
         * of a piece element based on the current game state.
         * Pieces are only interactive (focusable, draggable, hand cursor) for the
         * player whose turn it currently is, regardless of game mode (PvP/PvE).
         * @param {HTMLElement} pieceElement - The piece element to update.
         */
        function updatePieceAccessibility(pieceElement) {
            if (!pieceElement) return;
            const piecePlayer = pieceElement.dataset.player;

            // Determine if the piece should be interactive:
            // It must belong to the current player AND the game must not be over.
            const shouldBeInteractive = !gameState.gameOver && (piecePlayer === gameState.currentPlayer);

            if (shouldBeInteractive) {
                pieceElement.setAttribute('tabindex', '0'); // Allow focus
                pieceElement.draggable = true; // Allow dragging
                pieceElement.classList.add('movable'); // Add class for hand cursor
            } else {
                pieceElement.setAttribute('tabindex', '-1'); // Disallow focus
                pieceElement.draggable = false; // Disallow dragging
                pieceElement.classList.remove('movable'); // Remove class for hand cursor
            }
        }

        /**
         * Updates accessibility attributes for all piece elements on the board.
         * Typically called after a turn change or game state load.
         */
        function updateAllPieceAccessibility() {
            boardGridWrapper.querySelectorAll('.piece').forEach(p => updatePieceAccessibility(p));
        }


        // --- Game State Management ---

        /**
         * Creates a deep copy of the current game state and pushes it onto the history stack.
         */
        function saveGameState() { // Task 17 Change
            const stateToSave = {
                board: JSON.parse(JSON.stringify(gameState.board)),
                currentPlayer: gameState.currentPlayer,
                turnNumber: gameState.turnNumber,
                moveHistory: JSON.parse(JSON.stringify(gameState.moveHistory)),
                boardStateHistory: JSON.parse(JSON.stringify(gameState.boardStateHistory)),
                gameOver: gameState.gameOver,
                winner: gameState.winner,
                playerLastMoves: JSON.parse(JSON.stringify(playerLastMoves)),
                // --- Add Clock Times ---
                orangeTime: orangeTime,
                yellowTime: yellowTime
                // --- End Add Clock Times ---
            };
            gameHistory.push(stateToSave);
            updateUndoButtonState();
            console.log(`Game state saved. History length: ${gameHistory.length}`);
        }

        /**
         * Restores the game state to a previous state from the history.
         * @param {object} stateToLoad - The game state object retrieved from `gameHistory`.
         */
        function loadGameState(stateToLoad) { // Task 17 Change
            if (!stateToLoad) return;
            console.log("Loading game state (for Undo/Load)...");

            // --- Stop Clocks Before Loading ---
            pauseAllClocks(); // Stop any active timers

            gameState.board = stateToLoad.board;
            gameState.currentPlayer = stateToLoad.currentPlayer;
            gameState.turnNumber = stateToLoad.turnNumber;
            gameState.moveHistory = stateToLoad.moveHistory;
            gameState.boardStateHistory = stateToLoad.boardStateHistory;
            gameState.gameOver = stateToLoad.gameOver;
            gameState.winner = stateToLoad.winner;
            playerLastMoves = stateToLoad.playerLastMoves;
            // --- Restore Clock Times ---
            orangeTime = stateToLoad.orangeTime ?? INITIAL_TIME_SECONDS; // Use default if missing
            yellowTime = stateToLoad.yellowTime ?? INITIAL_TIME_SECONDS; // Use default if missing
            // --- Update Clock Displays ---
            updateClockDisplay(PLAYERS.ORANGE, orangeTime);
            updateClockDisplay(PLAYERS.YELLOW, yellowTime);

            placePieces();
            rebuildMoveLog();
            highlightLastMoves();
            updateUI();
            logBoardState(true); // Log state without incrementing count
            updateStatus(gameState.gameOver ? `Game Over: ${gameState.winner} wins!` : `${gameState.currentPlayer.toUpperCase()}'s turn.`);

            if (!gameState.gameOver) {
                // Interaction is handled AFTER load by the calling function (undoMove, initializeGame)
                // enablePlayerInteraction(); // DON'T enable here, let caller decide
            } else {
                disablePlayerInteraction(); // Disable if game was over
                pauseAllClocks(); // Ensure clocks stay stopped if game over
            }

            updateUndoButtonState();
            clearHighlights(); // General selection highlights
            selectedPieceCoords = null;
            console.log("Game state loaded.");
            // Clocks are NOT started here; the function calling loadGameState (e.g., undoMove) will resume them.
        }

        /**
         * Clears and rebuilds the visual move log based on the `gameState.moveHistory`.
         * Necessary after loading a previous game state.
         */
        function rebuildMoveLog() {
            moveLogElement.innerHTML = ''; // Clear the current log display
            // Add each entry from the history back to the DOM
            gameState.moveHistory.forEach(entry => {
                addLogEntryToDOM(entry.turn, entry.orange, entry.yellow);
            });
            // Scroll to the bottom of the log
            moveLogElement.scrollTop = moveLogElement.scrollHeight;
        }

        /**
         * Handles the Undo button click. Reverts the game state.
         * - In PvP mode: Undoes the single last move made by either player.
         * - In PvE mode: Undoes the last full turn (AI's move + Player's preceding move).
         * Also handles restoring clocks and playing turn sound.
         */
        function undoMove() {
            // Prevent undo while AI is processing its turn (only relevant in PvE)
            if (!isPlayerVsPlayerMode && gameState.currentPlayer === PLAYERS.YELLOW && boardGridWrapper.style.pointerEvents === 'none') {
                console.log("Cannot undo while AI is thinking.");
                updateStatus("Cannot undo while AI is thinking.");
                return;
            }

            // Check if there's anything in the history to undo (minimum depends on mode)
            const minHistoryLength = isPlayerVsPlayerMode ? 1 : 1; // Need at least 1 state for any undo
            if (gameHistory.length < minHistoryLength) {
                console.log("Nothing to undo.");
                updateStatus("Nothing to undo.");
                return;
            }

            // --- Pause Clocks Before Undoing ---
            pauseAllClocks();

            let stateToRestore = null;

            if (isPlayerVsPlayerMode) {
                // --- PvP Logic: Undo 1 move ---
                console.log("Undoing last PvP move...");
                stateToRestore = gameHistory.pop(); // Pop the state before the last player's move
            } else {
                // --- PvE Logic: Try to undo 2 moves (Player + AI) ---
                if (gameHistory.length >= 2) {
                    // We want the state *before* the player's move, which is 2 steps back
                    console.log("Undoing last full turn (Player + AI)...");
                    gameHistory.pop(); // Pop and discard the state before the AI's move
                    stateToRestore = gameHistory.pop(); // Pop and restore the state before the Player's move
                } else if (gameHistory.length === 1) {
                    // Fallback: Only player's first move exists in history. Undo just that one.
                    console.log("Undoing player's first move (only one in history)...");
                    stateToRestore = gameHistory.pop();
                }
            }

            // --- Check if a state was successfully retrieved to restore ---
            if (!stateToRestore) {
                // This case might be hit if history was exactly 1 in PvE and popping failed somehow (unlikely)
                // Or if history somehow became empty unexpectedly. Safest is to reset.
                console.error("Undo Error: Could not retrieve a state to restore. History length:", gameHistory.length);
                initializeGame(); // Reset to initial state as a safe fallback
                updateStatus("Undo error or history empty. Game reset.");
                updateUndoButtonState();
                pauseAllClocks(); // Ensure clocks stopped
                return;
            }

            // --- Load the determined state ---
            console.log("Loading restored state...");
            // loadGameState handles restoring board, player, clocks values etc., and updating UI text/displays
            loadGameState(stateToRestore);

            // --- Post-load updates ---
            updateStatus(`Undo successful. ${gameState.currentPlayer.toUpperCase()}'s turn.`);
            updateUndoButtonState(); // Update button based on new history length

            // Resume Clock & Play Sound
            if (!gameState.gameOver) {
                // After undoing in PvE (usually 2 moves), it will always be Orange's turn.
                // After undoing in PvP (1 move), it could be Orange or Yellow.
                // After undoing PvE fallback (1 move), it will be Orange's turn.
                // gameState.currentPlayer reflects the correct player whose turn it now IS.
                enablePlayerInteraction(); // Ensure interaction is enabled (important after PvE undo)
                startClock(gameState.currentPlayer); // Start clock for the player whose turn it now is
                playTurnSound(); // Play sound for the start of their turn
            } else {
                // If undo results in a game-over state, ensure clocks remain paused.
                pauseAllClocks();
                disablePlayerInteraction(); // Ensure interaction disabled if game over
            }
            // Ensure piece accessibility is correct after potential enable/disable calls
            updateAllPieceAccessibility();

        } // End undoMove (Modified Task 14, 17, 28, 29)

        /**
         * Enables or disables the Undo button based on the game history length, game over state, and AI thinking state.
         */
        function updateUndoButtonState() {
            // Disable if history is empty OR game is over OR if it's AI's turn and interaction is disabled
            undoButton.disabled = gameHistory.length === 0 || gameState.gameOver ||
                                  (gameState.currentPlayer === PLAYERS.YELLOW && boardGridWrapper.style.pointerEvents === 'none');
        }


        // --- Game Initialization ---

        /**
         * Sets up the initial game state, creates the board, places pieces, and updates the UI.
         * Accepts an optional custom board state object to load from.
         * @param {object|null} [customBoard=null] - A board object ({ coords: pieceData }) to load instead of INITIAL_SETUP.
         * @param {boolean} [isLoadingFromFile=false] - Flag to indicate if loading from a state string input.
         */
        function initializeGame(customBoard = null, isLoadingFromFile = false) { // Task 17 Change (isLoadingFromFile)
             console.log("Initializing game..." + (customBoard ? " with custom state." : ""));

            // --- Initialize Clocks ---
            initializeClocks(); // Reset times and display, stop timers (Task 17)

            gameState = {
                board: customBoard ? customBoard : JSON.parse(JSON.stringify(INITIAL_SETUP)),
                currentPlayer: PLAYERS.ORANGE,
                turnNumber: 1,
                moveHistory: [],
                boardStateHistory: {},
                gameOver: false,
                winner: null
            };
            // Reset PvP toggle state only if NOT loading from file
             if (!isLoadingFromFile) {
                isPlayerVsPlayerMode = false;
                const pvpToggle = document.getElementById('pvp-toggle');
                if (pvpToggle) pvpToggle.checked = false;
             } // Keep existing PvP state if loading from file

            if (aiMoveTimeoutId) { clearTimeout(aiMoveTimeoutId); aiMoveTimeoutId = null; }
            gameHistory = [];

            playerLastMoves = {
                [PLAYERS.ORANGE]: { from: null, to: null },
                [PLAYERS.YELLOW]: { from: null, to: null }
            };

            // --- Apply abilities/hungry status ---
             if (!customBoard) {
                 // Add abilities/initial state only if not loading custom board
                  Object.values(gameState.board).forEach(piece => {
                      if(piece) {
                         piece.isHungry = false;
                          const abilities = SPECIAL_ABILITIES[piece.rank];
                          if (abilities) { Object.assign(piece, abilities); }
                      }
                 });
             } else {
                  // When loading custom board, ensure hungry state is reset and abilities are present
                  Object.values(gameState.board).forEach(piece => {
                      if (piece) {
                          piece.isHungry = false; // Reset hungry status
                          const abilities = SPECIAL_ABILITIES[piece.rank];
                          if (abilities) {
                              // Ensure essential ability flags are set if missing in loaded state
                              piece.swims = piece.swims ?? abilities.swims ?? false;
                              piece.attacksElephant = piece.attacksElephant ?? abilities.attacksElephant ?? false;
                              piece.jumpH = piece.jumpH ?? abilities.jumpH ?? false;
                              piece.jumpV = piece.jumpV ?? abilities.jumpV ?? false;
                          } else {
                               // Ensure flags are false if no special abilities
                              piece.swims = false; piece.attacksElephant = false;
                              piece.jumpH = false; piece.jumpV = false;
                          }
                      }
                  });
             }

            createBoard();
            placePieces();

            moveLogElement.innerHTML = '';
            boardStateLogElement.textContent = '';
            updateStatus("Game Ready. Orange to move.");
            updateUI();
            clearHighlights();
            logBoardState(); // Log initial state
            enablePlayerInteraction(); // Enable interaction for Orange
            updateUndoButtonState();
            selectedPieceCoords = null;

            clearPlayerLastMoveHighlight(PLAYERS.ORANGE);
            clearPlayerLastMoveHighlight(PLAYERS.YELLOW);
            highlightLastMoves();

             // --- Start Orange's Clock ---
             if (!gameState.gameOver) { // Task 17
                startClock(PLAYERS.ORANGE); // Start the clock for the first player
             }

            console.log("Game Initialized. Orange starts.");
            playTurnSound(); // Play sound for the very first turn (Task 28)
        }


        // --- Input Handling (Drag & Drop, Touch, Click, Keyboard) ---

        /**
         * Handles the start of a drag operation on a piece.
         * Sets up data transfer, highlights valid moves, and applies dragging styles.
         * @param {DragEvent} e - The drag event object.
         */
        function handleDragStart(e) {
            const pieceDiv = e.target.closest('.piece');
            // Only allow dragging current player's pieces when game is active
            if (!pieceDiv || pieceDiv.dataset.player !== gameState.currentPlayer || gameState.gameOver) {
                e.preventDefault(); // Prevent drag if not allowed
                return;
            }
            isDragging = true;
            draggedPieceElement = pieceDiv; // Store reference to the dragged element
            sourceCoords = draggedPieceElement.dataset.coords; // Store starting position

            // Apply dragging style slightly after drag starts to avoid flicker
            setTimeout(() => {
                if (draggedPieceElement) draggedPieceElement.classList.add('dragging');
             }, 0);

            e.dataTransfer.effectAllowed = 'move'; // Indicate a move operation
            e.dataTransfer.setData('text/plain', sourceCoords); // Store source coords for drop handler

            highlightValidMoves(sourceCoords); // Show potential destinations
            draggedPieceElement.classList.add('selected'); // Visually mark the dragged piece
            selectedPieceCoords = sourceCoords; // Track selection
            console.log(`Drag Start: ${sourceCoords}`);
        }

        /**
         * Handles the end of a drag operation (whether successful drop or cancelled).
         * Cleans up dragging styles and resets related state variables.
         * @param {DragEvent} e - The drag event object.
         */
        function handleDragEnd(e) {
            isDragging = false;
            if (draggedPieceElement) {
                // Remove visual styles associated with dragging/selection
                draggedPieceElement.classList.remove('dragging', 'selected');
            }
            // Reset drag-related variables
            draggedPieceElement = null;
            sourceCoords = null;
            clearHighlights(); // Remove valid move highlights
            // Note: selectedPieceCoords is reset in handleDrop or if move fails
            console.log("Drag End");
        }

        /**
         * Handles the drag over event on potential drop targets (cells, pieces).
         * Prevents the default behavior to allow dropping.
         * @param {DragEvent} e - The drag event object.
         */
        function handleDragOver(e) {
            e.preventDefault(); // Necessary to allow dropping
            e.dataTransfer.dropEffect = 'move'; // Indicate that a move is possible
        }

        /**
         * Helper function to apply hover styling during drag based on the target element.
         * Adds 'valid-move' or 'valid-attack' class to the underlying cell if it's a valid target.
         * @param {HTMLElement} targetElement - The element being dragged over (cell or piece).
         */
        function handleDragEnterAny(targetElement) {
            if (!targetElement || !isDragging) return; // Only act if dragging
            const targetCoords = getCoordsFromElement(targetElement);
            const cellElement = targetCoords ? document.getElementById(getCellElementId(targetCoords)) : null;

            // Check if the underlying cell was highlighted as a potential move/attack
            if (cellElement && cellElement.classList.contains('valid-move-highlight')) {
                // Apply the appropriate hover style based on whether it's an attack or move square
                if (cellElement.classList.contains('valid-attack-highlight')) {
                    cellElement.classList.add('valid-attack'); // Red highlight
                } else {
                    cellElement.classList.add('valid-move'); // Green highlight
                }
            }
        }

        /**
         * Helper function to remove hover styling when the dragged piece leaves an element.
         * @param {HTMLElement} targetElement - The element being left.
         */
        function handleDragLeaveAny(targetElement) {
            if (!targetElement) return;
            const targetCoords = getCoordsFromElement(targetElement);
            const cellElement = targetCoords ? document.getElementById(getCellElementId(targetCoords)) : null;
            // Remove the temporary hover styles
            if (cellElement) {
                cellElement.classList.remove('valid-move', 'valid-attack');
            }
        }

        /**
         * Handles drag enter event specifically for cell elements.
         * @param {DragEvent} e - The drag event object.
         */
        function handleDragEnter(e) {
            e.preventDefault();
            const targetCell = e.target.closest('.cell');
            handleDragEnterAny(targetCell); // Use helper for styling
        }

        /**
         * Handles drag leave event specifically for cell elements.
         * @param {DragEvent} e - The drag event object.
         */
        function handleDragLeave(e) {
            const targetCell = e.target.closest('.cell');
            handleDragLeaveAny(targetCell); // Use helper for styling
        }

        /**
         * Handles drag enter event specifically for piece elements (potential capture targets).
         * @param {DragEvent} e - The drag event object.
         */
        function handleDragEnterPiece(e) {
            e.preventDefault();
            e.stopPropagation(); // Prevent event bubbling to the underlying cell
            const targetPiece = e.target.closest('.piece');
            handleDragEnterAny(targetPiece); // Use helper for styling
        }

        /**
         * Handles drag leave event specifically for piece elements.
         * @param {DragEvent} e - The drag event object.
         */
        function handleDragLeavePiece(e) {
            const targetPiece = e.target.closest('.piece');
            handleDragLeaveAny(targetPiece); // Use helper for styling
        }

        /**
         * Utility function to extract coordinates from a DOM element (cell or piece).
         * @param {HTMLElement} element - The DOM element.
         * @returns {string|null} The algebraic coordinates or null if not found.
         */
        function getCoordsFromElement(element) {
            if (!element) return null;
            // Check if the element itself is a piece or cell
            if (element.classList.contains('piece') || element.classList.contains('cell')) {
                return element.dataset.coords;
            }
            // Check if the element is inside a piece or cell
            const piece = element.closest('.piece');
            if (piece) return piece.dataset.coords;
            const cell = element.closest('.cell');
            if (cell) return cell.dataset.coords;
            return null; // Coordinates not found
        }

        /**
         * Handles the drop event when a piece is released over a target.
         * Validates the move and calls performMove if valid.
         * @param {DragEvent} e - The drop event object.
         */
        function handleDrop(e) {
            e.preventDefault();
            if (!draggedPieceElement) { // Should not happen if dragstart fired correctly
                clearHighlights();
                isDragging = false;
                return;
            }

            const targetElement = e.target; // The element directly under the cursor on drop
            let targetCoords = null;
            let targetCell = null;

            // Determine the target coordinates based on what was dropped onto
            const droppedOnPiece = targetElement.closest('.piece');
            // Case 1: Dropped onto another piece (potential capture)
            if (droppedOnPiece && droppedOnPiece !== draggedPieceElement && droppedOnPiece.dataset.player !== gameState.currentPlayer) {
                targetCoords = droppedOnPiece.dataset.coords;
                targetCell = document.getElementById(getCellElementId(targetCoords));
            }
            // Case 2: Dropped onto a cell
            else {
                targetCell = targetElement.closest('.cell');
                if (targetCell) {
                    targetCoords = targetCell.dataset.coords;
                }
                // Case 3: Dropped back onto the original piece (treat as drop on original cell)
                else if (targetElement === draggedPieceElement) {
                    targetCoords = draggedPieceElement.dataset.coords;
                    targetCell = document.getElementById(getCellElementId(targetCoords));
                }
            }

            // Retrieve the source coordinates (stored during dragstart)
            const dragSourceCoords = draggedPieceElement.dataset.coords || sourceCoords || e.dataTransfer.getData('text/plain');
            clearHighlights(); // Clean up highlights immediately after drop

            // Check if drop target is valid
            if (!targetCell || !targetCoords) {
                console.log("Drop outside valid target.");
                updateStatus("Invalid drop location.");
                selectedPieceCoords = null; // Deselect if drop is invalid
                isDragging = false;
                // Snap piece back to original position if drop is invalid
                if(draggedPieceElement && dragSourceCoords) positionElementOnBoard(draggedPieceElement, dragSourceCoords);
                return;
            }

            // Validate the move using game logic
            const validationResult = isValidMove(dragSourceCoords, targetCoords, getPieceData(dragSourceCoords));

            if (!validationResult.valid) {
                // If move is invalid, log reason, update status, and snap piece back
                console.log(`Drop on invalid target: ${targetCoords}. Reason: ${validationResult.reason}`);
                updateStatus(`Invalid move: ${validationResult.reason}`);
                selectedPieceCoords = null; // Deselect
                if(draggedPieceElement && dragSourceCoords) positionElementOnBoard(draggedPieceElement, dragSourceCoords);
            } else {
                // If move is valid, perform the move
                console.log(`Performing move via drop from ${dragSourceCoords} to ${targetCoords}`);
                performMove(dragSourceCoords, targetCoords);
                selectedPieceCoords = null; // Deselect after successful move
            }
            isDragging = false; // Reset dragging flag
        }


        // --- Touch Handlers ---
        let touchStartX, touchStartY; // Store initial touch coordinates

        /**
         * Handles the start of a touch interaction on a piece.
         * Initiates potential drag, stores start position, highlights moves.
         * @param {TouchEvent} e - The touch event object.
         */
        function handleTouchStart(e) {
            if (gameState.gameOver) return; // Ignore touches if game is over
            const pieceElement = e.target.closest('.piece');
            // Only handle touches on the current player's pieces
            if (!pieceElement || pieceElement.dataset.player !== gameState.currentPlayer) return;

            e.preventDefault(); // Prevent default touch behavior like scrolling
            draggedPieceElement = pieceElement; // Reference the touched piece
            sourceCoords = draggedPieceElement.dataset.coords; // Store start position
            selectedPieceCoords = sourceCoords; // Select the piece

            // Store initial touch coordinates for calculating movement delta
            const touch = e.changedTouches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;

            isDragging = false; // Not dragging yet, could be a tap
            // Temporarily disable smooth transition for direct manipulation
            draggedPieceElement.style.transition = 'none';
            draggedPieceElement.style.zIndex = '100'; // Bring to front

            highlightValidMoves(sourceCoords); // Show valid moves
            draggedPieceElement.classList.add('selected'); // Mark as selected
            console.log(`Touch Start: ${sourceCoords}`);
        }

        /**
         * Handles touch movement while holding a piece.
         * Updates the piece's position visually and detects if it's a drag vs. tap.
         * @param {TouchEvent} e - The touch event object.
         */
        function handleTouchMove(e) {
            if (!draggedPieceElement || !sourceCoords) return; // Only if a piece touch is active
            e.preventDefault(); // Prevent scrolling during piece drag

            const touch = e.changedTouches[0];
            const deltaX = touch.clientX - touchStartX; // Horizontal movement
            const deltaY = touch.clientY - touchStartY; // Vertical movement

            // Define a threshold to distinguish between a tap and a drag
            const touchDragThreshold = 10; // Pixels

            // If not already dragging, check if threshold is exceeded
            if (!isDragging && (Math.abs(deltaX) > touchDragThreshold || Math.abs(deltaY) > touchDragThreshold)) {
                isDragging = true; // It's now officially a drag
                draggedPieceElement.classList.add('dragging'); // Apply dragging style
                console.log("Touch drag initiated");
            }

            // If dragging, update the element's visual position using transform
            if (isDragging) {
                // Get the element currently under the touch point
                const elementUnderTouch = document.elementFromPoint(touch.clientX, touch.clientY);

                // Preserve scaling if already applied (e.g., dragging style)
                const currentTransform = draggedPieceElement.style.transform.match(/scale\(([^)]+)\)/);
                const currentScale = currentTransform ? parseFloat(currentTransform[1]) : 1;
                // Apply translation based on touch movement and maintain scale
                draggedPieceElement.style.transform = `translate(${deltaX}px, ${deltaY}px) scale(${currentScale})`;

                // Update cell highlighting based on where the finger is hovering
                // First, remove hover highlights from all cells
                document.querySelectorAll('.cell.valid-move, .cell.valid-attack').forEach(c => c.classList.remove('valid-move', 'valid-attack'));
                // Then, find the cell under the touch
                const targetCoords = getCoordsFromElement(elementUnderTouch);
                const cellUnderTouch = targetCoords ? document.getElementById(getCellElementId(targetCoords)) : null;
                // If over a valid move cell, apply the appropriate hover highlight
                if (cellUnderTouch && cellUnderTouch.classList.contains('valid-move-highlight')) {
                    if (cellUnderTouch.classList.contains('valid-attack-highlight')) {
                        cellUnderTouch.classList.add('valid-attack'); // Red highlight
                    } else {
                        cellUnderTouch.classList.add('valid-move'); // Green highlight
                    }
                }
            }
        }

        /**
         * Handles the end of a touch interaction (lifting the finger).
         * Determines if it was a tap (treated like click) or a drag (treated like drop).
         * @param {TouchEvent} e - The touch event object.
         */
        function handleTouchEnd(e) {
            if (!draggedPieceElement || !sourceCoords) return; // Only if a piece touch was active
            e.preventDefault();

            const wasDragging = isDragging; // Store whether a drag occurred
            isDragging = false; // Reset dragging flag
            draggedPieceElement.classList.remove('dragging'); // Remove dragging style
            draggedPieceElement.style.zIndex = '10'; // Restore default z-index
            draggedPieceElement.style.transform = ''; // Reset translation

            // Restore smooth CSS transition after a short delay
            setTimeout(() => {
                if (draggedPieceElement) {
                    draggedPieceElement.style.transition = 'transform 0.3s ease-in-out, box-shadow 0.2s ease, outline 0.2s ease, left 0.3s ease-in-out, top 0.3s ease-in-out';
                }
             }, 0);

             // If it wasn't a drag, treat it as a tap/click (handled by handlePieceClick)
             if (!wasDragging) {
                 console.log("TouchEnd: Detected as tap/click. Handled by click listener.");
                  draggedPieceElement = null;
                  sourceCoords = null;
                 return;
             }

            // If it was a drag, determine the drop target
            const touch = e.changedTouches[0];
            // Find element at the touch release point
            const elementUnderTouch = document.elementFromPoint(touch.clientX, touch.clientY);
            let targetCoords = null;
            let targetCell = null;

            // Determine target similar to handleDrop
            const droppedOnPiece = elementUnderTouch?.closest('.piece');
            if (droppedOnPiece && droppedOnPiece !== draggedPieceElement && droppedOnPiece.dataset.player !== gameState.currentPlayer) {
                targetCoords = droppedOnPiece.dataset.coords;
                targetCell = document.getElementById(getCellElementId(targetCoords));
            } else {
                targetCell = elementUnderTouch?.closest('.cell');
                if (targetCell) {
                    targetCoords = targetCell.dataset.coords;
                }
            }

            clearHighlights(); // Remove move highlights

            // If a valid target cell was found
            if (targetCell && targetCoords) {
                const validationResult = isValidMove(sourceCoords, targetCoords, getPieceData(sourceCoords));
                if (validationResult.valid) {
                    // Perform move if valid
                    console.log(`Performing move via touch from ${sourceCoords} to ${targetCoords}`);
                    performMove(sourceCoords, targetCoords);
                    selectedPieceCoords = null; // Deselect after move
                } else {
                    // If invalid, snap piece back
                    console.log("Touch end on invalid target:", validationResult.reason);
                    updateStatus(`Invalid move: ${validationResult.reason}`);
                    positionElementOnBoard(draggedPieceElement, sourceCoords);
                    selectedPieceCoords = null; // Deselect
                }
            } else {
                // If dropped outside a valid target, snap piece back
                console.log("Touch end outside valid target");
                positionElementOnBoard(draggedPieceElement, sourceCoords);
                selectedPieceCoords = null; // Deselect
            }

            // Clean up touch state variables
            draggedPieceElement = null;
            sourceCoords = null;
            console.log("Touch End (Drag)");
        }


        // --- Click Handlers ---

        /**
         * Handles clicking on a piece.
         * - Selects/deselects the player's own piece and highlights valid moves.
         * - If a player's piece is already selected, clicking an opponent's piece
         *   directly triggers a move validation and execution attempt (capture).
         * @param {MouseEvent} e - The click event object.
         */
        function handlePieceClick(e) {
            // Clicks on child elements (like the image) should still be handled here now.
            // We want the click on the opponent's piece representation to trigger the capture.
            // console.log("handlePieceClick triggered. Target:", e.target, "CurrentTarget:", e.currentTarget);

            // Ignore clicks during drag or if game is over
            if (isDragging) {
                console.log("Piece click ignored: Dragging.");
                return;
            }
            if (gameState.gameOver) {
                console.log("Piece click ignored: Game Over.");
                return;
            }

            // Use currentTarget to get the piece DIV the listener is attached to
            const pieceElement = e.currentTarget;
            if (!pieceElement || !pieceElement.classList.contains('piece')) {
                 console.warn("handlePieceClick: currentTarget is not a valid piece element.", pieceElement);
                 return; // Should not happen if listener attached correctly
            }

            const clickedCoords = pieceElement.dataset.coords; // Coords of the piece that was clicked
            const clickedPieceData = getPieceData(clickedCoords); // Data of the piece clicked

            // --- Scenario 1: A friendly piece is already selected ---
            if (selectedPieceCoords && selectedPieceCoords !== clickedCoords) {
                const selectedPieceData = getPieceData(selectedPieceCoords); // Data of the *selected* piece

                // Ensure selected piece data exists (sanity check)
                if (!selectedPieceData) {
                    console.warn(`handlePieceClick: Data for selected piece ${selectedPieceCoords} not found. Deselecting.`);
                    deselectPiece();
                    return;
                }

                // Check if the clicked piece is an opponent piece (Capture Attempt)
                if (clickedPieceData && clickedPieceData.player !== selectedPieceData.player) {
                    console.log(`handlePieceClick: Attempting CAPTURE. Selected: ${selectedPieceCoords}, Clicked Opponent: ${clickedCoords}`);

                    // *** Directly validate and perform the move ***
                    const validationResult = isValidMove(selectedPieceCoords, clickedCoords, selectedPieceData);
                    console.log(`handlePieceClick (Capture): Validation Result =`, JSON.parse(JSON.stringify(validationResult)));

                    if (validationResult.valid) {
                        console.log(`--> handlePieceClick (Capture): Validation SUCCESS. Calling performMove(${selectedPieceCoords}, ${clickedCoords})`);
                        performMove(selectedPieceCoords, clickedCoords);
                        // performMove handles deselecting the piece after a successful move
                    } else {
                        console.log(`--> handlePieceClick (Capture): Validation FAILED: ${validationResult.reason}`);
                        flashCell(clickedCoords, 'red', 300); // Flash the target piece's cell
                        updateStatus(`Invalid move: ${validationResult.reason}`);
                        // Keep the original piece selected to allow trying a different move.
                    }
                    return; // Action completed (capture attempt)
                }
                // If clicking another friendly piece while one is selected, switch selection
                else if (clickedPieceData && clickedPieceData.player === selectedPieceData.player) {
                    console.log(`handlePieceClick: Switching selection from ${selectedPieceCoords} to ${clickedCoords}`);
                    selectPiece(clickedCoords); // selectPiece handles deselecting the old one
                    return; // Action completed (switched selection)
                }
                // If clicking an empty square (handled by handleCellClick) or something unexpected
                else {
                     console.log(`handlePieceClick: Clicked on something unexpected (${clickedCoords}) while ${selectedPieceCoords} was selected. Letting cell handler manage.`);
                     // Do nothing here, let potential bubble to cell handler occur.
                     return;
                }
            }

            // --- Scenario 2: No friendly piece is selected, or clicking the selected piece again ---
            // Check if the clicked piece belongs to the current player
            if (clickedPieceData && clickedPieceData.player === gameState.currentPlayer) {
                // If clicking the already selected piece, deselect it
                if (selectedPieceCoords === clickedCoords) {
                    console.log(`handlePieceClick: Deselecting piece ${clickedCoords}`);
                    deselectPiece();
                }
                // Otherwise, select the clicked piece
                else {
                    console.log(`handlePieceClick: Selecting piece ${clickedCoords}`);
                    selectPiece(clickedCoords); // Selects and highlights moves
                }
            } else if (!selectedPieceCoords) {
                // If clicking an opponent piece when NOTHING is selected, do nothing.
                console.log(`handlePieceClick: Clicked opponent piece ${clickedCoords} with no friendly piece selected. Doing nothing.`);
                // Clear any stray highlights just in case
                clearHighlights();
            }

            console.log(`handlePieceClick: Action completed. Selected: ${selectedPieceCoords}`);
        }

        /**
         * Handles clicking on a cell. If a piece is selected, attempts to move it to the clicked cell.
         * Ignored if a drag operation is currently happening or no piece is selected.
         * @param {MouseEvent} e - The click event object.
         */
        function handleCellClick(e) {
            // MOVED LOG TO VERY TOP
            console.log("--- handleCellClick triggered --- Target:", e.target, "CurrentTarget:", e.currentTarget); // Added more detail

            // Use e.currentTarget to ensure we reference the cell the listener is attached to
            const targetCell = e.currentTarget;

            // Basic validation of the target cell itself
            if (!targetCell || !targetCell.classList.contains('cell') || !targetCell.dataset.coords) {
                console.log("handleCellClick ignored: event.currentTarget is not a valid cell element or missing coords.", targetCell);
                return;
            }
             const targetCoords = targetCell.dataset.coords;
             console.log(`handleCellClick: Target Cell Coords = ${targetCoords}`);

            // Ignore clicks during drag or if game is over
            if (isDragging) {
                console.log("handleCellClick ignored: isDragging is true.");
                return;
            }
            if (gameState.gameOver) {
                console.log("handleCellClick ignored: game is over.");
                return;
            }

            // Check if a piece is selected (critical for move/capture attempts)
            if (!selectedPieceCoords) {
                console.log("handleCellClick ignored: No piece selected (selectedPieceCoords is null/undefined).");
                return;
            }
            console.log(`handleCellClick: Proceeding. Selected piece = ${selectedPieceCoords}`);

            // Get data for the selected piece
            const pieceToMove = getPieceData(selectedPieceCoords);

            // Safety check for selected piece data
            if (!pieceToMove) {
                console.warn(`handleCellClick: Selected piece data unexpectedly not found for: ${selectedPieceCoords}. Deselecting.`);
                deselectPiece();
                clearHighlights();
                return;
            }
            console.log(`handleCellClick: Attempting move validation: ${selectedPieceCoords} (${RANK_TO_NAME[pieceToMove.rank]}) -> ${targetCoords}`);

            // Validate the move from the selected piece to the clicked cell
            const validationResult = isValidMove(selectedPieceCoords, targetCoords, pieceToMove);
             console.log(`handleCellClick: Validation Result =`, JSON.parse(JSON.stringify(validationResult)));

            if (validationResult.valid) {
                // Perform the move if valid
                console.log(`--> handleCellClick: Validation SUCCESS. Calling performMove(${selectedPieceCoords}, ${targetCoords})`);
                performMove(selectedPieceCoords, targetCoords);
            } else {
                // If invalid, provide feedback
                console.log(`--> handleCellClick: Validation FAILED: ${validationResult.reason}`);
                flashCell(targetCoords, 'red', 300);
                updateStatus(`Invalid move: ${validationResult.reason}`);
                // Do not deselect - allow user to try another target cell
            }
            console.log("--- /handleCellClick finished ---"); // Log exit
        }

        /**
         * Handles mouse entering a piece element. Shows potential moves if it's the player's piece
         * and no other piece is currently selected or being dragged. (Hover effect)
         * @param {MouseEvent} e - The mouse event object.
         */
        function handlePieceMouseOver(e) {
            const pieceElement = e.target.closest('.piece');
            // Ignore if game over, another piece is selected, dragging, or not a piece
            if (!pieceElement || gameState.gameOver || selectedPieceCoords || isDragging) return;

            const coords = pieceElement.dataset.coords;
            const pieceData = getPieceData(coords);

            // Only highlight moves on hover for the current player's pieces
            if (pieceData && pieceData.player === gameState.currentPlayer) {
                // Highlight moves but don't mark the piece as 'selected' (isSelection = false)
                highlightValidMoves(coords, false);
            }
        }

        /**
         * Handles mouse leaving a piece element. Clears temporary hover highlights
         * if no piece is actively selected or being dragged.
         * @param {MouseEvent} e - The mouse event object.
         */
        function handlePieceMouseOut(e) {
            // If no piece is selected and not dragging, clear any highlights shown on hover
            if (!selectedPieceCoords && !isDragging) {
                clearHighlights();
            }
        }


        // --- Keyboard Handlers ---

        /**
         * Handles keyboard navigation (arrow keys) and actions (Enter/Space, Escape)
         * for moving focus, selecting/deselecting pieces, and making moves.
         * Ignores input if the "Load State" input field is focused.
         * @param {KeyboardEvent} e - The keyboard event object.
         */
        function handleKeyDown(e) {
            // --- START: Add Input Focus Check ---
            if (isLoadStateInputFocused) {
                // Allow default browser behavior for input fields (typing, arrows for cursor, etc.)
                // but prevent game actions defined below.
                console.log(`Keydown (${e.key}) ignored: Load state input focused.`);
                return;
            }
            // --- END: Add Input Focus Check ---

            // Ignore keyboard input if game is over OR if it's AI's turn in PvE mode
            if (gameState.gameOver || (!isPlayerVsPlayerMode && gameState.currentPlayer === PLAYERS.YELLOW)) {
                 console.log(`KeyDown ignored: gameOver=${gameState.gameOver}, isPvP=${isPlayerVsPlayerMode}, currentPlayer=${gameState.currentPlayer}`);
                 return;
            }

            const { key } = e;
            let newRow, newCol, targetCoords, currentElement;

            // If no element currently has focus, set initial focus
            if (!focusedCoords) {
                const firstPiece = boardGridWrapper.querySelector(`.piece[data-player="${gameState.currentPlayer}"][tabindex="0"]`);
                if (firstPiece) {
                    focusedCoords = firstPiece.dataset.coords;
                    firstPiece.focus();
                } else {
                    boardElement.focus();
                    focusedCoords = getCoords(Math.floor(ROWS/2), Math.floor(COLS/2)) || 'd5';
                    focusOn(focusedCoords);
                }
                if (!focusedCoords) return;
            }

            const currentRC = getRowCol(focusedCoords);
            if (!currentRC) {
                console.warn("Keyboard nav: Invalid focusedCoords", focusedCoords);
                const firstPiece = boardGridWrapper.querySelector(`.piece[data-player="${gameState.currentPlayer}"][tabindex="0"]`);
                if (firstPiece) {
                    focusedCoords = firstPiece.dataset.coords;
                    firstPiece.focus();
                }
                return;
            }

            // Handle Arrow Key navigation
            switch (key) {
                case 'ArrowUp': newRow = currentRC.row - 1; newCol = currentRC.col; break;
                case 'ArrowDown': newRow = currentRC.row + 1; newCol = currentRC.col; break;
                case 'ArrowLeft': newRow = currentRC.row; newCol = currentRC.col - 1; break;
                case 'ArrowRight': newRow = currentRC.row; newCol = currentRC.col + 1; break;
                // Handle Action Keys (Enter/Space)
                case 'Enter':
                case ' ':
                    e.preventDefault();
                    currentElement = document.getElementById(getPieceElementId(focusedCoords)) || document.getElementById(getCellElementId(focusedCoords));
                    if (currentElement?.classList.contains('piece')) {
                        const pieceData = getPieceData(focusedCoords);
                        if (pieceData?.player === gameState.currentPlayer) {
                            if (selectedPieceCoords === focusedCoords) deselectPiece();
                            else selectPiece(focusedCoords);
                        }
                    } else if (currentElement?.classList.contains('cell') && selectedPieceCoords) {
                        const pieceToMove = getPieceData(selectedPieceCoords);
                        if (pieceToMove) {
                            const validationResult = isValidMove(selectedPieceCoords, focusedCoords, pieceToMove);
                            if (validationResult.valid) {
                                performMove(selectedPieceCoords, focusedCoords);
                            } else {
                                flashCell(focusedCoords, 'red', 300);
                                updateStatus(`Invalid move: ${validationResult.reason}`);
                            }
                        }
                    }
                    return;
                // Handle Escape Key
                case 'Escape':
                    e.preventDefault();
                    if (selectedPieceCoords) {
                        deselectPiece();
                        clearHighlights();
                    }
                    return;
                default:
                    return; // Ignore other keys for game actions
            }

            // If an arrow key was pressed, calculate the target coordinates
            targetCoords = getCoords(newRow, newCol);
            if (targetCoords) {
                e.preventDefault(); // Prevent default arrow key scrolling ONLY for game navigation
                focusOn(targetCoords); // Move focus to the new cell/piece
            }
        }

        /**
         * Programmatically sets focus on a specific cell or piece element.
         * @param {string} coords - The algebraic coordinates of the target element.
         */
        function focusOn(coords) {
            if (!coords) return;
            // Find the target element (piece first, then cell)
            let targetElement = document.getElementById(getPieceElementId(coords)) || document.getElementById(getCellElementId(coords));
            if (targetElement) {
                targetElement.focus(); // Set browser focus
                // focusedCoords is updated by the 'focus' event listener on cells/pieces
            }
        }


        // --- Selection and Interaction State ---

        /**
         * Selects a piece at the given coordinates.
         * Updates the selectedPieceCoords state, applies visual selection style,
         * highlights valid moves, and sets focus.
         * @param {string} coords - The algebraic coordinates of the piece to select.
         */
        function selectPiece(coords) {
            deselectPiece(); // Ensure only one piece is selected at a time
            const pieceElement = document.getElementById(getPieceElementId(coords));
            // Only select if it's the current player's piece
            if (pieceElement?.dataset.player === gameState.currentPlayer) {
                selectedPieceCoords = coords; // Update state
                pieceElement.classList.add('selected'); // Apply visual style
                highlightValidMoves(coords); // Show valid moves for this piece
                focusOn(coords); // Move focus to the selected piece
                console.log(`Selected piece at ${coords}`);
            }
        }

        /**
         * Deselects the currently selected piece.
         * Clears the selectedPieceCoords state, removes visual selection style,
         * and clears move highlights.
         */
        function deselectPiece() {
            if (selectedPieceCoords) {
                const pieceElement = document.getElementById(getPieceElementId(selectedPieceCoords));
                if (pieceElement) {
                    pieceElement.classList.remove('selected'); // Remove visual style
                }
                console.log(`Deselected piece at ${selectedPieceCoords}`);
                selectedPieceCoords = null; // Clear state
                clearHighlights(); // Remove move highlights
            }
        }

        /**
         * Enables user interaction with the board (dragging, clicking, keyboard).
         * Sets pointer-events, adds keydown listener, and updates piece accessibility.
         */
        function enablePlayerInteraction() {
            boardGridWrapper.style.pointerEvents = 'auto'; // Allow clicks/drags on the grid
            document.addEventListener('keydown', handleKeyDown); // Enable keyboard controls
            updateAllPieceAccessibility(); // Make current player's pieces draggable/focusable
            console.log("Player interaction enabled.");
        }

        /**
         * Disables user interaction with the board.
         * Used during AI's turn or when the game is over.
         */
        function disablePlayerInteraction() {
            boardGridWrapper.style.pointerEvents = 'none'; // Prevent clicks/drags on the grid
            document.removeEventListener('keydown', handleKeyDown); // Disable keyboard controls
            updateAllPieceAccessibility(); // Make all pieces non-interactive
            console.log("Player interaction disabled.");
        }


        // --- Move Logic & Validation ---

        /**
         * Executes a validated move, updating the game state, moving the piece element,
         * handling captures, checking for win/loss conditions, managing hungry/starve rules,
         * logging the move, checking for repetition/stalemate, switching the player,
         * potentially triggering the AI, and managing last move highlights and clocks.
         * Correctly appends 'x' for each starved piece in notation. // <-- Updated comment (Task 33)
         * @param {string} fromCoords - The starting coordinates of the move.
         * @param {string} toCoords - The ending coordinates of the move.
         */
        function performMove(fromCoords, toCoords) { // Task 17 & 28 Change
            const piece = getPieceData(fromCoords); // Get data *before* state change

            // --- Pre-move validation and setup ---
            if (!piece || piece.player !== gameState.currentPlayer || gameState.gameOver) {
                console.error("Invalid move attempt condition in performMove.");
                updateStatus("Cannot move now.");
                return;
            }
            const playerWhoMoved = gameState.currentPlayer; // Store player before any state changes
            // --- Define opponent early (Fix for Task 34 ReferenceError) ---
            const opponent = playerWhoMoved === PLAYERS.ORANGE ? PLAYERS.YELLOW : PLAYERS.ORANGE;

            // --- Clear Previous Highlight for Current Player ---
            clearPlayerLastMoveHighlight(playerWhoMoved);

            // Use a fresh copy of piece data for validation to avoid potential mutation issues
            const validationResult = isValidMove(fromCoords, toCoords, { ...piece });
            if (!validationResult.valid) {
                console.log(`Invalid move attempt in performMove: ${validationResult.reason}`);
                updateStatus(`Invalid move: ${validationResult.reason}`);
                flashCell(toCoords, 'red');
                // --- Re-apply highlight if move fails ---
                highlightLastMoves(); // Re-apply previous highlights if move invalid
                return;
            }

            // --- Save State & Clear UI ---
            saveGameState(); // Save state *after* clearing highlight but *before* making changes
            clearHighlights(); // General selection highlights (keep this)
            deselectPiece(); // Deselect piece visually

            // --- Execute the move ---
            const targetPiece = getPieceData(toCoords); // Check for piece at destination *before* state change
            const isAttack = !!targetPiece;
            let notation = `${RANK_TO_CODE[piece.rank]}`; // Start notation with Rank
            let statusAction = "";

            // --- Handle Starvation BEFORE the move ---
            const starvedPiecesCoords = checkAndApplyStarvation(fromCoords, isAttack);

            // --- Handle Capture (if applicable) ---
            if (isAttack) {
                console.log(`${playerWhoMoved} ${RANK_TO_NAME[piece.rank]} at ${fromCoords} captures ${targetPiece.player} ${RANK_TO_NAME[targetPiece.rank]} at ${toCoords}`);
                notation += 'x'; // Add 'x' for capture AFTER the rank
                statusAction = ` captures ${RANK_TO_NAME[targetPiece.rank]} at ${toCoords}`;
                const capturedElement = document.getElementById(getPieceElementId(toCoords));
                if (capturedElement) {
                    const capturedIndicator = capturedElement.querySelector('.trap-rank-indicator.visible');
                    if (capturedIndicator) capturedIndicator.classList.remove('visible');
                    capturedElement.classList.add('captured');
                    setTimeout(() => { capturedElement.remove(); }, 400);
                }
            }

            // --- Update Game State Board ---
            const pieceDataToMove = JSON.parse(JSON.stringify(piece));
            pieceDataToMove.isHungry = piece.isHungry; // Carry over hungry status
            gameState.board[toCoords] = pieceDataToMove; // Place piece data at the new location
            delete gameState.board[fromCoords]; // Remove piece data from the old location

            // --- Update Piece DOM Element ---
            // Find the element using its ORIGINAL ID (before the move)
            const pieceElement = document.getElementById(getPieceElementId(fromCoords));
            if (pieceElement) {
                // Update the element's ID to match its new coordinates
                pieceElement.id = getPieceElementId(toCoords);
                pieceElement.setAttribute('aria-label', `${playerWhoMoved} ${RANK_TO_NAME[piece.rank]} at ${toCoords}`);
                // Visually move the piece on the board
                positionElementOnBoard(pieceElement, toCoords); // This updates element's position & dataset.coords

                // Update Trap Indicator Visual
                const movedPieceData = gameState.board[toCoords];
                if (movedPieceData) {
                    const isNowOnTrap = isOnTrapSquare(toCoords);
                    updateTrapIndicatorVisual(toCoords, isNowOnTrap, pieceElement);
                } else {
                    console.warn(`performMove: Piece data not found at destination ${toCoords} after move, cannot update trap indicator.`);
                    updateTrapIndicatorVisual(toCoords, false, pieceElement); // Attempt to clear visually
                }

                // Update Attacker's Hungry Status After Capture
                 if (isAttack) {
                     const attackerPieceData = gameState.board[toCoords]; // Re-fetch data from final location
                     if (attackerPieceData) {
                         attackerPieceData.isHungry = false; // Attacker is no longer hungry
                         console.log(`Attacker ${RANK_TO_NAME[attackerPieceData.rank]}@${toCoords} state set to not hungry.`);
                         updateHungryVisual(toCoords, false, pieceElement); // Update visual using the element
                     }
                }
                // Accessibility update happens AFTER player switch usually, or via updateUI()

            } else {
                // Fallback if element somehow missing - redraw all pieces
                console.error(`!!! Piece element not found for move ${fromCoords} -> ${toCoords}! Could not update DOM element. Re-placing all pieces.`);
                placePieces(); // Less efficient, but ensures consistency
            }

            // --- Complete Move Notation (Destination, Hungry, Starvation) ---
            notation += toCoords; // Add destination coordinates

            // --- Declare Hungry Animals for the *Next* Player ---
            // Opponent is now defined, so this block is safe
            const { hungryCount, hungryPiecesMap } = declareHungryAnimals(opponent);
             Object.keys(gameState.board).forEach(coords => {
                 const p = gameState.board[coords];
                 // No need to redefine opponent here
                 if (p && p.player === opponent) { // Use the opponent variable
                     const isNowHungry = !!hungryPiecesMap[coords];
                     p.isHungry = isNowHungry;
                     updateHungryVisual(coords, isNowHungry);
                 }
             });
            if (hungryCount > 0) { notation += '+'.repeat(hungryCount); } // Add hungry markers

            // --- Add 'x' for each Starvation (Task 33 Fix) ---
            if (starvedPiecesCoords.length > 0) {
                notation += 'x'.repeat(starvedPiecesCoords.length); // Append 'x' for each starved piece
                // Update status message
                statusAction += ` (${starvedPiecesCoords.length} animal${starvedPiecesCoords.length > 1 ? 's' : ''} starved)`;
                console.log(`Applying Clesto rule: Starvation occurred. Appending ${starvedPiecesCoords.length} 'x' to notation: ${notation}`);
            }

            // --- Check Win Conditions ---
            // Opponent variable is already defined
            const opponentDen = playerWhoMoved === PLAYERS.ORANGE ? DENS.yellow : DENS.orange;
            if (toCoords === opponentDen) {
                gameState.winner = playerWhoMoved; gameState.gameOver = true;
                updateStatus(`${playerWhoMoved.toUpperCase()} wins by reaching the den!${statusAction}`);
                logMove(notation, playerWhoMoved); logBoardState(); updateUI(); disablePlayerInteraction();
                pauseAllClocks();
                updateUndoButtonState(); return;
            }
            // Check elimination win
            let opponentPieceCount = 0;
            for (const coords in gameState.board) { if (gameState.board[coords]?.player === opponent) { opponentPieceCount++; } }
            if (opponentPieceCount === 0) {
                gameState.winner = playerWhoMoved; gameState.gameOver = true;
                updateStatus(`${playerWhoMoved.toUpperCase()} wins by eliminating all opponent pieces!${statusAction}`);
                logMove(notation, playerWhoMoved); logBoardState(); updateUI(); disablePlayerInteraction();
                pauseAllClocks();
                updateUndoButtonState(); return;
            }

            // --- Log the Final Move & Board State ---
            logMove(notation, playerWhoMoved); // Log the fully constructed notation
            const boardStateString = logBoardState();

            // --- Store This Move for Highlighting ---
            playerLastMoves[playerWhoMoved] = { from: fromCoords, to: toCoords };
            highlightLastMoves(); // Apply highlights immediately *before* switching clocks/player

            // --- Switch Clocks (BEFORE switching player) ---
            switchClocks(playerWhoMoved);

            // --- Check Draw/Loss Conditions (Stalemate first, then Repetition) ---
            if (checkForStalemate(opponent)) { // opponent is defined
                gameState.winner = playerWhoMoved; // Stalemate = loss for opponent, win for current player
                gameState.gameOver = true;
                updateStatus(`Stalemate! ${opponent.toUpperCase()} has no valid moves. ${playerWhoMoved.toUpperCase()} wins!`);
                disablePlayerInteraction(); updateUI();
                pauseAllClocks();
                updateUndoButtonState(); return;
            }

            // --- Switch Player and Update UI ---
            gameState.currentPlayer = opponent; // Switch to the opponent (defined earlier)
            if (playerWhoMoved === PLAYERS.YELLOW) { gameState.turnNumber++; } // Increment turn after Yellow moves
            updateStatus(`${gameState.currentPlayer.toUpperCase()}'s turn.${statusAction}`); // Update status for the new current player
            updateUI(); // Includes accessibility update
            updateUndoButtonState(); // Update based on new state

            // --- Play Turn Sound ---
            if (!gameState.gameOver) { // Don't play sound if game just ended
                playTurnSound(); // Play sound for the player whose turn it now is (Task 28)
            }

            // --- Trigger AI if applicable ---
            if (!isPlayerVsPlayerMode && gameState.currentPlayer === PLAYERS.YELLOW && !gameState.gameOver) {
                disablePlayerInteraction();
                undoButton.disabled = true; // Disable undo during AI thinking
                if (aiMoveTimeoutId) clearTimeout(aiMoveTimeoutId);
                // AI clock is already running, just wait for think time
                aiMoveTimeoutId = setTimeout(triggerAIMove, 1500);
            } else if (!gameState.gameOver) {
                enablePlayerInteraction(); // Ensure interaction is enabled for human turn
            } else {
                 // Ensure clocks are stopped if game ended for any other reason here
                 pauseAllClocks();
            }

        } // End performMove (Modified Task 17, 28, 33, 34-Fix)


        /**
         * Checks if the specified player has any valid moves available in the current board state.
         * @param {string} playerToCheck - The player ('orange' or 'yellow') to check for stalemate.
         * @returns {boolean} True if the player has no valid moves (stalemate), false otherwise.
         */
        function checkForStalemate(playerToCheck) {
            // Iterate through all pieces belonging to the player
            for (const fromCoords in gameState.board) {
                const piece = gameState.board[fromCoords];
                if (piece?.player === playerToCheck) {
                    // Get all potential destination squares for this piece
                    const destinations = getPotentialMoveDestinations(fromCoords, piece);
                    // Check if *any* of these potential destinations result in a valid move
                    for (const toCoords of destinations) {
                        if (isValidMove(fromCoords, toCoords, piece).valid) {
                            // Found at least one valid move, so it's not stalemate
                            console.log(`Stalemate check: Found valid move for ${playerToCheck}: ${fromCoords} to ${toCoords}`);
                            return false;
                        }
                    }
                }
            }
            // If the loop completes without finding any valid moves, it's stalemate
            console.log(`Stalemate check: No valid moves found for ${playerToCheck}.`);
            return true;
        }

        /**
         * Determines if a move from `fromCoords` to `toCoords` is legal according to game rules.
         * Checks terrain, piece abilities, capture rules (including traps), jump paths,
         * AND the repetition rule for the leading player.
         * Returns additional reasonCode for specific failure types.
         * @param {string} fromCoords - Starting algebraic coordinates.
         * @param {string} toCoords - Ending algebraic coordinates.
         * @param {object} piece - The data object of the piece attempting the move (the ATTACKER).
         * @param {object} [currentBoardState=gameState.board] - Optional board state for simulation.
         * @param {boolean} [isSimulation=false] - Flag to suppress detailed logging during AI simulation. // NEW PARAMETER
         * @returns {{valid: boolean, reason: string, reasonCode?: string}} An object indicating validity and reason.
         */
        function isValidMove(fromCoords, toCoords, piece, currentBoardState = gameState.board, isSimulation = false) { // ADD isSimulation PARAMETER
            // --- Basic Checks ---
            if (!piece) return { valid: false, reason: "No piece selected." };
            if (fromCoords === toCoords) return { valid: false, reason: "Cannot move to the same square." };
            const fromRC = getRowCol(fromCoords);
            const toRC = getRowCol(toCoords);
            if (!fromRC || !toRC) return { valid: false, reason: "Invalid coordinates." };
            const targetPieceData = currentBoardState[toCoords] || null;
            const pieceRank = piece.rank;
            const pieceAbilities = SPECIAL_ABILITIES[pieceRank] || {};

            // --- Rule Checks ---
            if (targetPieceData?.player === piece.player) return { valid: false, reason: "Cannot capture your own piece." };
            const ownDen = piece.player === PLAYERS.ORANGE ? DENS.orange : DENS.yellow;
            if (toCoords === ownDen) return { valid: false, reason: "Cannot enter your own den." };
            if (piece.isHungry) {
                const opponentDen = piece.player === PLAYERS.ORANGE ? DENS.yellow : DENS.orange;
                if (toCoords === opponentDen) return { valid: false, reason: "Hungry animal cannot enter the den to win." };
            }

            // --- Movement Type Checks (Water, Jump) ---
            const isOrthogonal = (Math.abs(fromRC.row - toRC.row) === 1 && fromRC.col === toRC.col) || (Math.abs(fromRC.col - toRC.col) === 1 && fromRC.row === toRC.row);
            const isMovingToWater = WATER_SQUARES.has(toCoords);
            const isMovingFromWater = WATER_SQUARES.has(fromCoords);
            if (isMovingToWater && !pieceAbilities.swims) return { valid: false, reason: "This animal cannot enter water." };
            if (isMovingFromWater && isMovingToWater && targetPieceData && !pieceAbilities.swims) return { valid: false, reason: "Cannot attack into water (unless Rat/Dog)." };
            if (pieceRank === 1 && targetPieceData?.rank === 8 && isMovingFromWater) return { valid: false, reason: "Rat cannot attack Elephant from water."};
            if (isMovingFromWater && !isMovingToWater && targetPieceData && !pieceAbilities.swims) return { valid: false, reason: "Only Rat/Dog can attack land from water." };
            let isJumpValid = false;
             if (!isMovingFromWater && !isMovingToWater) {
                 const isVerticalJump = toRC.col === fromRC.col && Math.abs(toRC.row - fromRC.row) === 4 && (fromRC.col === 1 || fromRC.col === 2 || fromRC.col === 4 || fromRC.col === 5);
                 const isHorizontalJump = toRC.row === fromRC.row && Math.abs(toRC.col - fromRC.col) === 3 && (fromRC.row >= 3 && fromRC.row <= 5);
                 if (isVerticalJump || isHorizontalJump) {
                     if ((isVerticalJump && !pieceAbilities.jumpV) || (isHorizontalJump && !pieceAbilities.jumpH)) return { valid: false, reason: "This animal cannot jump that way." };
                     // Pass isSimulation down to checkJumpPathClear
                     if (!checkJumpPathClear(fromRC, toRC, piece.player, currentBoardState, isSimulation)) return { valid: false, reason: "Jump path blocked by opponent in water." };
                     isJumpValid = true;
                 }
             }
            if (!isOrthogonal && !isJumpValid) return { valid: false, reason: "Invalid move distance or type (not 1 square orthogonal or valid jump)." };

            // --- Capture Rules ---
            if (targetPieceData) {
                let attackerRank = pieceRank;
                let defenderOriginalRank = targetPieceData.rank;
                let defenderEffectiveRank = defenderOriginalRank;
                let defenderIsTrapped = false;
                if (isOnTrapSquare(toCoords)) {
                    defenderEffectiveRank = 0;
                    defenderIsTrapped = true;
                    // --- LOGGING WRAPPED ---
                    if (!isSimulation) {
                        console.log(`isValidMove Check: Defender ${targetPieceData.player} ${RANK_TO_NAME[targetPieceData.rank]}@${toCoords} is on a trap. Defender effective rank for capture = 0.`);
                    }
                    // --- END WRAP ---
                }
                const isRatAttackElephant = pieceRank === 1 && defenderOriginalRank === 8;
                if (isRatAttackElephant && !isMovingFromWater) return { valid: true };
                if (attackerRank < defenderEffectiveRank) {
                    const reasonMsg = `Cannot attack higher-ranked animal (${attackerRank} vs ${defenderOriginalRank}${defenderIsTrapped ? ' [Trap->0]' : ''}).`;
                    return { valid: false, reason: reasonMsg, reasonCode: 'RANK_TOO_LOW' };
                }
            }

            // --- START: Repetition Rule Check ---
            const restrictedPlayer = getRestrictedPlayer(currentBoardState);

            // Check only if the current piece's player is the one restricted by repetition
            if (piece.player === restrictedPlayer) {
                // Create a *temporary simulation* within this check
                // Avoid deep copy if possible, make changes, check, then revert? No, deep copy safer.
                const tempBoard = JSON.parse(JSON.stringify(currentBoardState));
                const pieceDataToMove = tempBoard[fromCoords];

                if (pieceDataToMove) {
                    if (tempBoard[toCoords]) { // Handle capture simulation
                        delete tempBoard[toCoords];
                    }
                    tempBoard[toCoords] = pieceDataToMove; // Move the piece data
                    delete tempBoard[fromCoords]; // Delete from original position

                    const resultingStateString = getBoardStateString(tempBoard);
                    // Access the *main* gameState's history for checking counts, even during simulation
                    const repetitionCount = gameState.boardStateHistory[resultingStateString] || 0;

                    if (repetitionCount >= 2) {
                         // --- LOGGING WRAPPED ---
                         if (!isSimulation) {
                            console.log(`isValidMove: Repetition rule block for ${piece.player}. Move ${fromCoords}->${toCoords} creates 3rd+ instance of state: ${resultingStateString} (Count: ${repetitionCount + 1})`);
                         }
                         // --- END WRAP ---
                        return { valid: false, reason: "Move creates 3rd repetition.", reasonCode: 'REPETITION_RULE' };
                    }
                } else {
                    // --- LOGGING WRAPPED ---
                    if (!isSimulation) {
                         console.warn(`isValidMove: Could not find piece data at ${fromCoords} during repetition check simulation.`);
                    }
                    // --- END WRAP ---
                }
            }
            // --- END: Repetition Rule Check ---

            return { valid: true };
        }


        /**
         * Checks if the path for a Lion/Tiger jump over water is clear of opponent swimming pieces (Rat/Dog).
         * @param {{row: number, col: number}} fromRC - Start row/col indices.
         * @param {{row: number, col: number}} toRC - End row/col indices.
         * @param {string} attackerPlayer - The player making the jump ('orange' or 'yellow').
         * @param {object} currentBoardState - The board state to check against.
         * @param {boolean} [isSimulation=false] - Flag to suppress detailed logging. // NEW PARAMETER
         * @returns {boolean} True if the path is clear, false otherwise.
         */
        function checkJumpPathClear(fromRC, toRC, attackerPlayer, currentBoardState, isSimulation = false) { // ADD isSimulation PARAMETER & currentBoardState
            const opponent = attackerPlayer === PLAYERS.ORANGE ? PLAYERS.YELLOW : PLAYERS.ORANGE;
            const startRow = Math.min(fromRC.row, toRC.row);
            const endRow = Math.max(fromRC.row, toRC.row);
            const startCol = Math.min(fromRC.col, toRC.col);
            const endCol = Math.max(fromRC.col, toRC.col);

            // Vertical Jump Check (column is the same)
            if (fromRC.col === toRC.col) {
                for (let r = startRow + 1; r < endRow; r++) {
                    const coords = getCoords(r, fromRC.col);
                    if (!WATER_SQUARES.has(coords)) {
                         // --- LOGGING WRAPPED ---
                         if (!isSimulation) console.warn(`Jump path check anomaly: ${coords} in vertical jump path is not water.`);
                         // --- END WRAP ---
                        return false;
                    }
                    // Use the provided board state
                    const blockingPiece = currentBoardState[coords]; // Check the simulated board
                    if (blockingPiece?.player === opponent) {
                         // --- LOGGING WRAPPED ---
                         if (!isSimulation) console.log(`Jump blocked by opponent ${RANK_TO_NAME[blockingPiece.rank]} at ${coords}`);
                         // --- END WRAP ---
                        return false;
                    }
                }
            }
            // Horizontal Jump Check (row is the same)
            else if (fromRC.row === toRC.row) {
                for (let c = startCol + 1; c < endCol; c++) {
                    const coords = getCoords(fromRC.row, c);
                    if (!WATER_SQUARES.has(coords)) {
                         // --- LOGGING WRAPPED ---
                         if (!isSimulation) console.warn(`Jump path check anomaly: ${coords} in horizontal jump path is not water.`);
                         // --- END WRAP ---
                        return false;
                    }
                    const blockingPiece = currentBoardState[coords]; // Check the simulated board
                    if (blockingPiece?.player === opponent) {
                         // --- LOGGING WRAPPED ---
                         if (!isSimulation) console.log(`Jump blocked by opponent ${RANK_TO_NAME[blockingPiece.rank]} at ${coords}`);
                         // --- END WRAP ---
                        return false;
                    }
                }
            } else {
                 // --- LOGGING WRAPPED ---
                 if (!isSimulation) console.error("checkJumpPathClear called with non-orthogonal jump coordinates.");
                 // --- END WRAP ---
                return false;
            }

            return true;
        }


        // --- Hungry/Starve Logic ---

         /**
         * Identifies all pieces for the specified player that are currently "hungry"
         * (i.e., have a valid capturing move available against an opponent piece).
         * Considers original ranks for triggering hunger, even if the target is trapped.
         * @param {string} playerToDeclareFor - The player ('orange' or 'yellow') whose pieces should be checked.
         * @param {object} [currentBoardState=gameState.board] - The board state to check against. // NEW PARAMETER
         * @param {boolean} [isSimulation=false] - Flag to suppress detailed logging. // NEW PARAMETER
         * @returns {{hungryCount: number, hungryPiecesMap: object}} An object containing the count of hungry pieces
         *          and a map `{ coords: true }` for each hungry piece.
         */
        function declareHungryAnimals(playerToDeclareFor, currentBoardState = gameState.board, isSimulation = false) { // ADD isSimulation PARAMETER & currentBoardState
            let hungryCount = 0;
            const hungryPiecesMap = {};
            const opponent = playerToDeclareFor === PLAYERS.ORANGE ? PLAYERS.YELLOW : PLAYERS.ORANGE;

            for (const coords in currentBoardState) { // Iterate over the passed board state
                const piece = currentBoardState[coords];
                if (piece?.player === playerToDeclareFor) {
                    const destinations = getPotentialMoveDestinations(coords, piece);
                    let pieceDeclaredHungry = false;

                    for (const targetCoords of destinations) {
                         if (pieceDeclaredHungry) break;

                        const targetPiece = currentBoardState[targetCoords]; // Check the simulated board

                        if (targetPiece?.player === opponent) {
                            // Pass isSimulation down to isValidMove
                            const validationResult = isValidMove(coords, targetCoords, piece, currentBoardState, isSimulation);

                            if (validationResult.valid) {
                                // --- LOGGING WRAPPED ---
                                if (!isSimulation) {
                                    console.log(`DeclareHungry: ${piece.player} ${RANK_TO_NAME[piece.rank]}@${coords} is hungry (can capture ${targetPiece.player} ${RANK_TO_NAME[targetPiece.rank]}@${targetCoords} - trap included).`);
                                }
                                // --- END WRAP ---
                                hungryPiecesMap[coords] = true;
                                hungryCount++;
                                pieceDeclaredHungry = true;
                            } else if (validationResult.reasonCode === 'RANK_TOO_LOW') {
                                // --- LOGGING WRAPPED ---
                                if (!isSimulation) {
                                    console.log(`DeclareHungry: ${piece.player} ${RANK_TO_NAME[piece.rank]}@${coords} vs ${targetPiece.player} ${RANK_TO_NAME[targetPiece.rank]}@${targetCoords} - Failed isValidMove due to rank. Checking original ranks...`);
                                }
                                // --- END WRAP ---

                                const attackerRank = piece.rank;
                                const defenderOriginalRank = targetPiece.rank;
                                let canCaptureIgnoringTrap = false;
                                const isRatVsElephant = attackerRank === 1 && defenderOriginalRank === 8;
                                const isMovingFromWater = WATER_SQUARES.has(coords);

                                if (isRatVsElephant && !isMovingFromWater) {
                                    canCaptureIgnoringTrap = true;
                                } else if (attackerRank >= defenderOriginalRank) {
                                    if (!(attackerRank === 8 && defenderOriginalRank === 1)) {
                                        canCaptureIgnoringTrap = true;
                                    }
                                }

                                if (canCaptureIgnoringTrap) {
                                    // --- LOGGING WRAPPED ---
                                    if (!isSimulation) {
                                        console.log(`DeclareHungry: ---> YES, ${piece.player} ${RANK_TO_NAME[piece.rank]}@${coords} becomes hungry (can capture ${targetPiece.player} ${RANK_TO_NAME[targetPiece.rank]}@${targetCoords} based on ORIGINAL ranks).`);
                                    }
                                    // --- END WRAP ---
                                    hungryPiecesMap[coords] = true;
                                    hungryCount++;
                                    pieceDeclaredHungry = true;
                                } else {
                                    // --- LOGGING WRAPPED ---
                                    if (!isSimulation) {
                                         console.log(`DeclareHungry: ---> NO, rank check failed even with original ranks.`);
                                    }
                                    // --- END WRAP ---
                                }
                            }
                        }
                    }
                }
            }

            // --- LOGGING WRAPPED ---
            if (hungryCount > 0 && !isSimulation) {
                console.log(`${playerToDeclareFor.toUpperCase()} has ${hungryCount} hungry animal(s) final map: ${Object.keys(hungryPiecesMap).join(', ')}`);
            }
            // --- END WRAP ---
            return { hungryCount, hungryPiecesMap };
        }


        /**
         * Checks if any hungry pieces of the current player failed to make a capture
         * during the move that just occurred. Removes starved pieces from the board state and DOM.
         * Called *before* the piece is moved in `performMove`.
         * @param {string} movedPieceCoords - The starting coordinates of the piece that is *about* to be moved.
         * @param {boolean} wasAttack - Indicates if the move being performed *is* a capture.
         * @returns {string[]} An array of coordinates of the pieces that starved.
         */
        function checkAndApplyStarvation(movedPieceCoords, wasAttack) {
            const currentPlayer = gameState.currentPlayer; // Player whose turn it *was*
            const starvedPiecesCoords = []; // Store coords of pieces to remove

            // Iterate through all pieces on the board
            for (const coords in gameState.board) {
                const piece = gameState.board[coords];
                // Check if it's the current player's piece AND it was marked as hungry *before* this move started
                if (piece?.player === currentPlayer && piece.isHungry) {
                    // Did *this specific piece* make the capturing move?
                    const didThisPieceAttack = (coords === movedPieceCoords) && wasAttack;

                    if (!didThisPieceAttack) {
                        // If this hungry piece did NOT make a capturing move, it starves
                        console.log(`STARVE: ${currentPlayer} ${RANK_TO_NAME[piece.rank]}@${coords} was hungry but did not attack. Starved.`);
                        starvedPiecesCoords.push(coords);
                    } else {
                        // If this hungry piece *did* make the attack, it's saved
                        console.log(`SAVED: ${currentPlayer} ${RANK_TO_NAME[piece.rank]}@${coords} attacked and is no longer hungry (for now).`);
                        // Note: Its isHungry status will be recalculated for the opponent's turn anyway.
                    }
                }
            }

            // Remove starved pieces from the board state and DOM
            starvedPiecesCoords.forEach(coords => {
                const starvedElement = document.getElementById(getPieceElementId(coords));
                const pieceData = gameState.board[coords]; // Get data before deleting
                if (pieceData) { // Ensure piece still exists (should always be true here)
                    console.log(`Removing starved piece ${RANK_TO_NAME[pieceData.rank]}@${coords}`);
                    delete gameState.board[coords]; // Remove from board state
                    // Animate and remove DOM element
                    if (starvedElement) {
                        starvedElement.classList.add('captured'); // Use capture animation for removal
                        setTimeout(() => starvedElement.remove(), 400);
                    }
                }
            });

            return starvedPiecesCoords; // Return list of starved piece coordinates for logging/notation
        }


        /**
         * Gets all geometrically possible destination squares for a piece, considering orthogonal moves and jumps.
         * Does not validate the move legality (terrain, captures), only potential squares.
         * @param {string} fromCoords - The starting coordinates.
         * @param {object} piece - The piece data object.
         * @returns {string[]} An array of potential destination coordinate strings.
         */
        function getPotentialMoveDestinations(fromCoords, piece) {
            const destinations = new Set(); // Use a Set to avoid duplicate coordinates
            const rc = getRowCol(fromCoords);
            if (!rc || !piece) return [];

            const { row, col } = rc;
            const abilities = SPECIAL_ABILITIES[piece.rank] || {};

            // 1. Orthogonal Moves (adjacent squares)
            const orthMoves = [
                getCoords(row + 1, col), // Down
                getCoords(row - 1, col), // Up
                getCoords(row, col + 1), // Right
                getCoords(row, col - 1)  // Left
            ];
            orthMoves.forEach(c => {
                if (c) destinations.add(c); // Add if valid coords
            });

            // 2. Jump Moves (Lion/Tiger/Leopard)
            // Vertical jumps (over cols 1, 2, 4, 5 river sections)
            if (abilities.jumpV && (col === 1 || col === 2 || col === 4 || col === 5)) {
                // Check jump up (possible from rows 3 to 8)
                if (row >= 3) { // Need 3 rows of water + 1 landing row above
                    const destUp = getCoords(row - 4, col); // 4 rows difference
                    if (destUp) destinations.add(destUp);
                }
                // Check jump down (possible from rows 0 to 5)
                if (row <= 5) { // Need 3 rows of water + 1 landing row below
                    const destDown = getCoords(row + 4, col);
                    if (destDown) destinations.add(destDown);
                }
            }
            // Horizontal jumps (over rows 3, 4, 5 river sections)
            if (abilities.jumpH && (row >= 3 && row <= 5)) { // Must be in a river row
                // Check jump left (possible from cols 3 to 6)
                if (col >= 3) { // Need 2 cols of water + 1 landing col left
                    const destLeft = getCoords(row, col - 3); // 3 cols difference
                    if (destLeft) destinations.add(destLeft);
                }
                 // Check jump right (possible from cols 0 to 3)
                if (col <= 3) { // Need 2 cols of water + 1 landing col right
                    const destRight = getCoords(row, col + 3);
                    if (destRight) destinations.add(destRight);
                }
            }

            return [...destinations]; // Convert Set back to an array
        }


        // --- AI Logic (Minimax) ---

        /**
         * Main AI decision function. Implements prioritized checks, dynamic depth, and falls back to Minimax.
         * Uses static evaluation for choosing counter-moves.
         */
        function triggerAIMove() {
            console.log("AI (Yellow) is thinking...");
            const player = PLAYERS.YELLOW;
            const aiStartTime = performance.now();

            // --- Calculate Dynamic Depth ---
            const totalPieces = Object.keys(gameState.board).length;
            let currentDepth = MINIMAX_DEPTH;
            if (totalPieces > 12) currentDepth = 2;
            else if (totalPieces > 8) currentDepth = 3;
            else currentDepth = Math.max(MINIMAX_DEPTH, 4);
            console.log(`AI using search depth: ${currentDepth} (Total Pieces: ${totalPieces})`);

            // 1. Get all valid moves for AI
            const allMyMoves = getAllValidMoves(gameState.board, player, false); // Not simulation

            if (allMyMoves.length === 0) {
                console.log("AI has no valid moves! Checking game end conditions.");
                if (!gameState.gameOver) {
                    if (checkForStalemate(player)) {
                        gameState.winner = null; gameState.gameOver = true;
                        updateStatus("Stalemate! AI (Yellow) has no valid moves.");
                        pauseAllClocks();
                    } else {
                        gameState.winner = PLAYERS.ORANGE; gameState.gameOver = true;
                        updateStatus("AI Error or No Moves Found! Orange wins!");
                        pauseAllClocks();
                    }
                    disablePlayerInteraction(); updateUI(); updateUndoButtonState();
                }
                return;
            }

            // --- Priority 1: Can AI win immediately? ---
            // Pass the simulation flag (false here, as it's the actual game state)
            const winningMove = findImmediateWinningMove(gameState.board, player, false); // Pass false
            if (winningMove) {
                const aiEndTime = performance.now();
                console.log(`AI Priority 1: Found winning move ${winningMove.from} -> ${winningMove.to}. Time: ${((aiEndTime - aiStartTime)/1000).toFixed(2)}s`);
                performMove(winningMove.from, winningMove.to);
                return;
            }

            // --- Priority 2: Can opponent win next turn? ---
            const opponentWinningMoves = getOpponentWinningMoves(gameState.board, player);
            if (opponentWinningMoves.length > 0) {
                console.log(`AI Priority 2: Opponent has potential winning move(s):`, opponentWinningMoves);
                const counterMoves = findCounterMoves(gameState, allMyMoves, opponentWinningMoves);

                if (counterMoves.length > 0) {
                    console.log(`AI Priority 2: Found counter-move(s):`, counterMoves);
                    // --- Use static evaluateBoard to choose BEST counter ---
                    let bestCounterMove = null;
                    let bestCounterScore = -Infinity;
                    for (const counter of counterMoves) {
                         const nextState = simulateMove(gameState, counter); // Simulate the counter move
                         const score = evaluateBoard(nextState.board, player); // Evaluate resulting board
                         if (score > bestCounterScore) {
                             bestCounterScore = score;
                             bestCounterMove = counter;
                         }
                    }
                     const aiEndTime = performance.now();
                     console.log(`AI Priority 2: Choosing best counter ${bestCounterMove.from} -> ${bestCounterMove.to} (Static Eval Score: ${bestCounterScore.toFixed(2)}). Time: ${((aiEndTime - aiStartTime)/1000).toFixed(2)}s`);
                    performMove(bestCounterMove.from, bestCounterMove.to);
                    return;
                } else {
                    console.log(`AI Priority 2: Cannot stop all opponent winning moves! Making default best move.`);
                    // Fall through to Minimax
                }
            }

            // --- Fallback: Use Minimax with dynamic depth ---
            console.log(`AI Fallback: Running Minimax (Depth: ${currentDepth})...`);
            const bestMoveResult = findBestMoveMinimax(currentDepth, gameState, player);

            if (bestMoveResult?.move) {
                 const aiEndTime = performance.now();
                console.log(`AI Fallback: Chose move ${bestMoveResult.move.from} -> ${bestMoveResult.move.to} (Score: ${bestMoveResult.score.toFixed(2)} @Depth ${currentDepth}). Time: ${((aiEndTime - aiStartTime)/1000).toFixed(2)}s`);
                performMove(bestMoveResult.move.from, bestMoveResult.move.to);
            } else {
                 const aiEndTime = performance.now();
                console.error(`AI ERROR: Minimax failed to find a move, but valid moves existed? Time: ${((aiEndTime - aiStartTime)/1000).toFixed(2)}s. Choosing random.`);
                 const randomMove = allMyMoves[Math.floor(Math.random() * allMyMoves.length)];
                 performMove(randomMove.from, randomMove.to);
            }
        }

        /**
         * Finds the best move for the AI using the Minimax algorithm at the root level.
         * Considers hungry piece obligations. PRIORITIZES statically evaluated near-win moves.
         * @param {number} depth - The maximum search depth for Minimax.
         * @param {object} currentGameState - The current state of the game.
         * @param {string} playerForMax - The player the AI is playing as (always YELLOW here).
         * @returns {{move: object, score: number}|null} The best move found ({from, to}) and its score, or null if no moves.
         */
        function findBestMoveMinimax(depth, currentGameState, playerForMax) {
            let bestScore = -Infinity;
            let bestMove = null;
            let bestNearWinMove = null; // Track the best move leading to a near-win state
            let bestNearWinStaticScore = -Infinity; // Track the static score of that near-win state

            const possibleMoves = getAllValidMoves(currentGameState.board, currentGameState.currentPlayer, true);
            const opponentDen = playerForMax === PLAYERS.ORANGE ? DENS.yellow : DENS.orange;

            if (possibleMoves.length === 0) {
                console.log("AI findBestMove: No possible moves found.");
                return null;
            }

            // --- Immediate Win Check ---
            for (const move of possibleMoves) {
                if (move.to === opponentDen) {
                    if (!currentGameState.board[move.from]?.isHungry) {
                         console.log("AI Found immediate winning move to Den:", move);
                         return { move: move, score: AI_WIN_SCORE + depth };
                     }
                }
            }

            // --- Handle Hungry Pieces Obligation ---
            const hungryMoves = possibleMoves.filter(move => currentGameState.board[move.from]?.isHungry);
            let movesToConsider = possibleMoves;
            console.log(`[findBestMove] Initial possible moves: ${possibleMoves.map(m => m.from + '->' + m.to).join(', ')}`);
            if (hungryMoves.length > 0) {
                const attackingHungryMoves = hungryMoves.filter(move => !!currentGameState.board[move.to]);
                if (attackingHungryMoves.length > 0) {
                    console.log("AI considering only ATTACKING moves by hungry pieces:", attackingHungryMoves);
                    movesToConsider = attackingHungryMoves;
                } else {
                    console.log("AI considering only non-attacking moves by hungry pieces:", hungryMoves);
                    movesToConsider = hungryMoves;
                }
            }
             console.log(`[findBestMove] Moves considered after hunger filter: ${movesToConsider.map(m => m.from + '->' + m.to).join(', ')}`);


            // --- Evaluate Moves using Minimax ---
            for (const move of movesToConsider) {
                const { nextState, moveInfo } = simulateMove(currentGameState, move);

                // --- Get Static Eval AFTER the move ---
                const staticEvalScore = evaluateBoard(nextState.board, playerForMax, moveInfo);
                console.log(`[findBestMove DEBUG] Move ${move.from}->${move.to}: Static Eval Score = ${staticEvalScore.toFixed(2)}`);

                // --- Run Minimax ---
                const score = minimax(depth - 1, nextState, false, -Infinity, Infinity, playerForMax);
                console.log(`[findBestMove DEBUG] Move ${move.from}->${move.to}: Minimax Score (Depth ${depth}) = ${score.toFixed(2)}`);

                // --- Check if this move leads to a near-win state (based on static eval) ---
                // Use a threshold slightly lower than the win-adjacent bonus itself
                const nearWinThreshold = AI_DEN_PROXIMITY_BONUS_SQ * 0.8; // e.g., 80% of the bonus
                if (staticEvalScore >= nearWinThreshold) {
                    // Is this near-win state better than the previous best near-win state?
                    // Or is it the first one we found?
                    if (bestNearWinMove === null || staticEvalScore > bestNearWinStaticScore) {
                       // Check if Minimax didn't reveal an immediate forced loss after this move
                       // (Allow a drop in score, but not a catastrophic one)
                       const catastrophicDropThreshold = AI_LOSE_SCORE / 2; // e.g., -5000
                       if (score > catastrophicDropThreshold) {
                            console.log(`[findBestMove DEBUG] *** Prioritizing Near-Win Move: ${move.from}->${move.to} (Static: ${staticEvalScore.toFixed(2)}, Minimax: ${score.toFixed(2)}) ***`);
                            bestNearWinMove = move;
                            bestNearWinStaticScore = staticEvalScore;
                       } else {
                            console.log(`[findBestMove DEBUG] Near-Win Move ${move.from}->${move.to} discarded (Minimax score ${score.toFixed(2)} too low - potential trap/loss).`);
                       }
                    }
                }

                // --- Standard Best Move Update (using Minimax score) ---
                let currentScore = score;
                if (Math.abs(score) < AI_WIN_SCORE / 1.1 && Math.abs(score) < Math.abs(AI_LOSE_SCORE) / 1.1 ) {
                    currentScore += (Math.random() - 0.5) * 0.1; // Add randomness for non-critical moves
                }
                if (currentScore > bestScore) {
                     console.log(`[findBestMove DEBUG] --- New Best Standard Move: ${move.from}->${move.to} (Minimax Score: ${currentScore.toFixed(2)} > Best: ${bestScore.toFixed(2)}) ---`);
                    bestScore = currentScore;
                    bestMove = move;
                }
            } // End loop through movesToConsider

            // --- Final Decision: Prioritize near-win move if found and viable ---
            if (bestNearWinMove) {
                 console.log(`[findBestMove] FINAL DECISION: Prioritizing Near-Win Move ${bestNearWinMove.from}->${bestNearWinMove.to}`);
                 // We use the near-win move, but report the actual minimax score for consistency if needed elsewhere
                 const finalMinimaxScoreForNearWin = minimax(depth - 1, simulateMove(currentGameState, bestNearWinMove).nextState, false, -Infinity, Infinity, playerForMax);
                 return { move: bestNearWinMove, score: finalMinimaxScoreForNearWin };
            }

            // --- Otherwise, use the best move found via standard Minimax ---
            if (bestMove) {
                 console.log(`[findBestMove] FINAL DECISION: Using Standard Best Move ${bestMove.from}->${bestMove.to}`);
                 return { move: bestMove, score: bestScore };
            }

            // --- Fallback if somehow no move was selected ---
            if (!bestMove && possibleMoves.length > 0) {
                 console.warn("Minimax didn't find ANY viable best move. Picking random valid move as fallback.");
                 const fallbackSet = movesToConsider.length > 0 ? movesToConsider : possibleMoves;
                 bestMove = fallbackSet[Math.floor(Math.random() * fallbackSet.length)];
                 bestScore = -Infinity;
                 return { move: bestMove, score: bestScore };
            }

             // Should be unreachable if possibleMoves.length > 0
             console.error("AI findBestMove: Reached end without selecting a move!");
             return null;
        }

        /**
         * The recursive Minimax function with Alpha-Beta Pruning.
         * Explores the game tree to a specified depth, evaluating board states.
         * Prioritizes near-winning moves in maximization.
         * @param {number} depth - Remaining depth to search.
         * @param {object} nodeGameState - The game state at the current node in the search tree.
         * @param {boolean} isMaximizingPlayer - True if the current node is for the AI (maximizing), false for the opponent (minimizing).
         * @param {number} alpha - The best score found so far for the maximizing player along the current path.
         * @param {number} beta - The best score found so far for the minimizing player along the current path.
         * @param {string} playerForMax - The player the AI controls (YELLOW).
         * @returns {number} The evaluated score for the current node.
         */
        function minimax(depth, nodeGameState, isMaximizingPlayer, alpha, beta, playerForMax) {
            // --- Base Cases for Recursion ---
            if (depth === 0 || nodeGameState.gameOver) {
                // Pass null for moveInfo when evaluating leaf/terminal nodes
                const baseScore = evaluateBoard(nodeGameState.board, playerForMax, null);
                if (baseScore >= AI_WIN_SCORE / 1.1) return baseScore + depth;
                if (baseScore <= AI_LOSE_SCORE / 1.1) return baseScore - depth;
                return baseScore;
            }

            const possibleMoves = getAllValidMoves(nodeGameState.board, nodeGameState.currentPlayer, true);

            if (possibleMoves.length === 0) {
                return isMaximizingPlayer ? (AI_LOSE_SCORE - depth) : (AI_WIN_SCORE + depth);
            }

            // --- Handle Hungry Pieces Obligation ---
            const hungryMoves = possibleMoves.filter(move => nodeGameState.board[move.from]?.isHungry);
            let movesToConsider = possibleMoves;
            if (hungryMoves.length > 0) {
                const attackingHungryMoves = hungryMoves.filter(move => !!nodeGameState.board[move.to]);
                if (attackingHungryMoves.length > 0) {
                    movesToConsider = attackingHungryMoves;
                } else {
                    movesToConsider = hungryMoves;
                }
            }

            // --- Recursive Exploration ---
            if (isMaximizingPlayer) { // AI's turn (maximize score)
                let maxEval = -Infinity;

                // --- Priority Check for Near-Win States ---
                for (const move of movesToConsider) {
                    // Simulate move AND get move info
                    const { nextState: tempNextState, moveInfo: tempMoveInfo } = simulateMove(nodeGameState, move);
                    // Evaluate the immediate result, passing move info
                    const immediateEval = evaluateBoard(tempNextState.board, playerForMax, tempMoveInfo);
                    if (immediateEval >= AI_WIN_SCORE / 1.5) {
                        maxEval = Math.max(maxEval, immediateEval + depth);
                        alpha = Math.max(alpha, maxEval);
                    }
                     if (beta <= alpha) break;
                }
                // --- End Priority Check ---

                // --- Standard Minimax Loop ---
                for (const move of movesToConsider) {
                    const { nextState, moveInfo } = simulateMove(nodeGameState, move); // Get moveInfo
                    // Pass moveInfo to recursive call's evaluation? No, evaluate the state *reached*.
                    // We evaluate the state `nextState` based on *its* potential, not just the move that got there.
                    // The evaluation of the *current* node *does* consider the move via the `immediateEval` above
                    // and the `clear hunger` bonus check within evaluateBoard if needed.
                    const evaluation = minimax(depth - 1, nextState, false, alpha, beta, playerForMax);
                    maxEval = Math.max(maxEval, evaluation);
                    alpha = Math.max(alpha, evaluation);
                    if (beta <= alpha) {
                        break; // Beta cutoff
                    }
                }

                // Fallback check
                 if (maxEval === -Infinity && possibleMoves.length > 0 && movesToConsider.length < possibleMoves.length) {
                      const nonHungryMove = possibleMoves.find(m => !movesToConsider.some(consMove => consMove.from === m.from && consMove.to === m.to)) || possibleMoves[0];
                      const { nextState: fallbackState } = simulateMove(nodeGameState, nonHungryMove); // Simulate fallback
                      return minimax(depth -1, fallbackState, false, alpha, beta, playerForMax);
                 }
                return maxEval;

            } else { // Opponent's turn (minimize score)
                let minEval = Infinity;

                 // --- Check for near-loss states ---
                 for (const move of movesToConsider) {
                    const { nextState: tempNextState, moveInfo: tempMoveInfo } = simulateMove(nodeGameState, move);
                    // Evaluate resulting board from AI perspective, passing move info
                    const immediateEval = evaluateBoard(tempNextState.board, playerForMax, tempMoveInfo);
                    if (immediateEval <= AI_LOSE_SCORE / 1.5) {
                         minEval = Math.min(minEval, immediateEval - depth);
                         beta = Math.min(beta, minEval);
                     }
                     if (beta <= alpha) break;
                 }
                 // --- End Near-Loss Check ---

                // --- Standard Minimax Loop ---
                for (const move of movesToConsider) {
                    const { nextState } = simulateMove(nodeGameState, move); // Don't need moveInfo here
                    const evaluation = minimax(depth - 1, nextState, true, alpha, beta, playerForMax);
                    minEval = Math.min(minEval, evaluation);
                    beta = Math.min(beta, evaluation);
                    if (beta <= alpha) {
                        break; // Alpha cutoff
                    }
                }

                // Fallback check
                 if (minEval === Infinity && possibleMoves.length > 0 && movesToConsider.length < possibleMoves.length) {
                     const nonHungryMove = possibleMoves.find(m => !movesToConsider.some(consMove => consMove.from === m.from && consMove.to === m.to)) || possibleMoves[0];
                     const { nextState: fallbackState } = simulateMove(nodeGameState, nonHungryMove);
                     return minimax(depth -1, fallbackState, true, alpha, beta, playerForMax);
                 }
                return minEval;
            }
        }

        /**
         * Generates a list of all valid moves for a given player in a specific board state.
         * @param {object} boardState - The board state object ({ coords: pieceData }).
         * @param {string} player - The player ('orange' or 'yellow') whose moves to find.
         * @param {boolean} [isSimulation=false] - Flag to pass down to isValidMove. // NEW PARAMETER
         * @returns {Array<object>} An array of valid move objects [{ from, to }, ...].
         */
        function getAllValidMoves(boardState, player, isSimulation = false) { // ADD isSimulation
            const validMoves = [];
            if (!boardState) return []; // Safety check

            // Iterate through all squares on the board
            for (const fromCoords in boardState) {
                const piece = boardState[fromCoords];
                // Check if the piece belongs to the specified player
                if (piece?.player === player) {
                    // Get potential destinations (geometric moves)
                    const destinations = getPotentialMoveDestinations(fromCoords, piece);
                    // Validate each potential destination
                    for (const toCoords of destinations) {
                        // Use isValidMove with a copy of piece data and pass isSimulation flag
                        if (isValidMove(fromCoords, toCoords, { ...piece }, boardState, isSimulation).valid) { // Pass isSimulation
                            validMoves.push({ from: fromCoords, to: toCoords });
                        }
                    }
                }
            }
            return validMoves;
        }

        /**
         * Creates a new game state object representing the result of making a specific move.
         * Updates hungry status for the *next* player. Does not handle full starvation rules.
         * Returns the *next* state and info about the move made. // <-- Updated comment
         * @param {object} currentGameState - The game state *before* the move.
         * @param {object} move - The move object { from, to }.
         * @returns {{nextState: object, moveInfo: object}} An object containing the new game state and move details.
         */
        function simulateMove(currentGameState, move) {
            const nextState = {
                board: JSON.parse(JSON.stringify(currentGameState.board)),
                currentPlayer: currentGameState.currentPlayer,
                gameOver: false,
                winner: null,
            };
            const moveInfo = { // Store info about the move being simulated
                from: move.from,
                to: move.to,
                pieceRank: null,
                wasCapture: false,
                wasHungry: false // Was the moving piece hungry *before* this simulated move?
            };

            const piece = nextState.board[move.from];

            if (!piece) {
                console.error("SimulateMove Error: Piece not found at source", move.from);
                nextState.gameOver = true;
                nextState.winner = currentGameState.currentPlayer === PLAYERS.ORANGE ? PLAYERS.YELLOW : PLAYERS.ORANGE;
                return { nextState, moveInfo }; // Return early on error
            }

            // Store piece info before moving
            moveInfo.pieceRank = piece.rank;
            moveInfo.wasHungry = piece.isHungry || false; // Record if it was hungry

            // Simulate capture
            const targetPiece = nextState.board[move.to];
            if (targetPiece) {
                moveInfo.wasCapture = true;
                delete nextState.board[move.to];
            }

            // Move the piece & reset its hungry status
            nextState.board[move.to] = piece;
            delete nextState.board[move.from];
            nextState.board[move.to].isHungry = false; // Moving/attacking piece is no longer hungry

            // --- Simplified Win Condition Checks ---
            const opponent = piece.player === PLAYERS.ORANGE ? PLAYERS.YELLOW : PLAYERS.ORANGE;
            const opponentDen = piece.player === PLAYERS.ORANGE ? DENS.yellow : DENS.orange;
            if (move.to === opponentDen) {
                nextState.gameOver = true;
                nextState.winner = piece.player;
            } else {
                let opponentPieceCount = 0;
                for (const coords in nextState.board) { if (nextState.board[coords]?.player === opponent) { opponentPieceCount++; break; } }
                if (opponentPieceCount === 0) {
                    nextState.gameOver = true;
                    nextState.winner = piece.player;
                }
            }

            // --- Switch Player and Update Hungry Status ---
            nextState.currentPlayer = opponent;
            if (!nextState.gameOver) { // Only declare hungry if game is not over
                 const { hungryPiecesMap } = declareHungryAnimals(nextState.currentPlayer, nextState.board, true);
                 Object.keys(nextState.board).forEach(coords => {
                     const p = nextState.board[coords];
                     if (p) p.isHungry = !!hungryPiecesMap[coords];
                 });
            }

            return { nextState, moveInfo }; // Return both the new state and info about the move
        }

        /**
         * Evaluates the static board state from the perspective of the AI player (playerForMax).
         * Incorporates heuristics favoring specific piece roles, den proximity, captures,
         * and clearing hunger via attack. Penalizes Wolf/Cat advancement.
         * Uses tunable constants for easier balancing.
         * @param {object} boardState - The board state to evaluate.
         * @param {string} playerForMax - The player considered "maximizing" (AI, usually Yellow).
         * @param {object|null} [originalPieceIfMove=null] - If evaluating *after* a move, the data of the piece that just moved. // NEW Param
         * @returns {number} A numerical score representing the board state's favorability for playerForMax.
         */
        function evaluateBoard(boardState, playerForMax, originalPieceIfMove = null) { // Task 39 - Add Hunger Clear Bonus
            let score = 0;
            const opponent = playerForMax === PLAYERS.ORANGE ? PLAYERS.YELLOW : PLAYERS.ORANGE;
            const totalPieces = Object.keys(boardState).length;
            const isEarlyGame = totalPieces > 12;
            const isMidGame = totalPieces > 8 && totalPieces <= 12;

            // Use constants
            const pieceValues = AI_PIECE_VALUES;
            const maxDen = playerForMax === PLAYERS.ORANGE ? DENS.orange : DENS.yellow;
            const minDen = playerForMax === PLAYERS.ORANGE ? DENS.yellow : DENS.orange;
            const maxTraps = playerForMax === PLAYERS.ORANGE ? TRAPS.yellow : TRAPS.orange;
            const minTraps = playerForMax === PLAYERS.ORANGE ? TRAPS.orange : TRAPS.yellow;

            const adjacentToMaxDen = getAdjacentCoords(maxDen);
            const adjacentToMinDen = getAdjacentCoords(minDen);
            const twoSquaresFromMinDen = new Set();
            adjacentToMinDen.forEach(sq1 => {
                getAdjacentCoords(sq1).forEach(sq2 => {
                    if (sq2 !== minDen && !adjacentToMinDen.includes(sq2)) {
                        twoSquaresFromMinDen.add(sq2);
                    }
                });
            });

            const adjacentToMinTraps = getAdjacentCoordsSet(minTraps);
            const riverRowStart = 3;
            const riverRowEnd = 5;
            const centerCols = [2, 3, 4];
            const jumpLandingCols = [1, 2, 4, 5];

            let maxPieceCount = 0;
            let minPieceCount = 0;
            let maxPiecesNearOppDen = 0;

            // --- Pre-checks ---
            if (boardState[maxDen]?.player === opponent) return AI_LOSE_SCORE;
            if (boardState[minDen]?.player === playerForMax) return AI_WIN_SCORE;

            // --- Pre-calculate Threats & Back Row Jumpers ---
            const threatsTo = {};
            const threatenedBy = {};
            const allOpponentMoves = getAllValidMoves(boardState, opponent, true);
            const allMyMoves = getAllValidMoves(boardState, playerForMax, true);
            let backRowJumpersExist = false;

            for (const move of allOpponentMoves) { if (boardState[move.to]?.player === playerForMax) threatsTo[move.to] = true; }
            for (const move of allMyMoves) { if (boardState[move.to]?.player === opponent) threatenedBy[move.to] = true; }
            for (const coords in boardState) {
                 const piece = boardState[coords];
                 if (piece?.player === playerForMax && (piece.rank === 7 || piece.rank === 6)) {
                     const rc = getRowCol(coords);
                     if (rc && ((playerForMax === PLAYERS.YELLOW && rc.row >= 6) || (playerForMax === PLAYERS.ORANGE && rc.row <= 2))) {
                         backRowJumpersExist = true; break;
                     }
                 }
            }

            // --- Iterate through pieces ---
            for (const coords in boardState) {
                const piece = boardState[coords];
                if (!piece) continue;
                const rc = getRowCol(coords);
                if (!rc) continue;

                let pieceScore = pieceValues[piece.rank] || 0;
                const pieceAbilities = SPECIAL_ABILITIES[piece.rank] || {};
                const isWolfOrCat = piece.rank === 4 || piece.rank === 2;

                // --- Calculate Mobility & Capture Potential ---
                let offensiveMovesCount = 0;
                let captureBonusFromThisPiece = 0;
                const pieceMoves = allMyMoves.filter(m => m.from === coords);
                let madeHungryAttack = false; // Flag if this piece made a required attack

                for (const move of pieceMoves) {
                    const targetRC = getRowCol(move.to);
                    const targetPiece = boardState[move.to];
                    let isForward = false;
                    if (targetRC) isForward = (playerForMax === PLAYERS.YELLOW && targetRC.row < rc.row) || (playerForMax === PLAYERS.ORANGE && targetRC.row > rc.row);
                    const isAttack = !!targetPiece && targetPiece.player === opponent;

                    if (isAttack) {
                        offensiveMovesCount++;
                        let targetRank = targetPiece.rank;
                        if (isOnTrapSquare(move.to)) targetRank = 0;
                        const currentRank = piece.rank;
                        const isRatVsElephant = currentRank === 1 && targetPiece.rank === 8;
                        if (isRatVsElephant || currentRank >= targetRank) {
                             let capturedValue = pieceValues[targetPiece.rank] || 10;
                             captureBonusFromThisPiece += capturedValue * AI_CAPTURE_BONUS_MULT;
                        }
                        // Check if this attack satisfied hunger
                        if (originalPieceIfMove && originalPieceIfMove.from === coords && originalPieceIfMove.to === move.to && originalPieceIfMove.wasHungry) {
                             madeHungryAttack = true;
                        }

                    } else if (isForward) { offensiveMovesCount++; }
                }
                const offensiveMobilityBonus = offensiveMovesCount * AI_OFFENSIVE_MOBILITY_BONUS_MULT;


                if (piece.player === playerForMax) { // AI's piece (Maximizing)
                    maxPieceCount++;
                    score += pieceScore;
                    score += offensiveMobilityBonus;
                    score += captureBonusFromThisPiece;

                    // Bonus for making a necessary hungry attack
                    if (madeHungryAttack) {
                        score += AI_CLEAR_HUNGER_ATTACK_BONUS;
                    }

                    // A) Den Proximity Bonus (VERY HIGH)
                    if (adjacentToMinDen.includes(coords)) {
                        score += AI_DEN_PROXIMITY_BONUS_SQ;
                        if (isValidMove(coords, minDen, piece, boardState, true).valid && !piece.isHungry) {
                           score += AI_WIN_SCORE / AI_WIN_ADJACENT_BONUS_FACTOR; // Use factor
                        }
                    } else if (twoSquaresFromMinDen.has(coords)) {
                         score += AI_DEN_PROXIMITY_BONUS_2SQ;
                    }

                    // B) Advancement & Positional Bonuses (Piece Specific)
                    const rowsAdvanced = playerForMax === PLAYERS.YELLOW ? (rc.row) : (ROWS - 1 - rc.row);
                    const isPastRiver = (playerForMax === PLAYERS.YELLOW && rc.row > riverRowEnd) || (playerForMax === PLAYERS.ORANGE && rc.row < riverRowStart);
                    const defensiveRowThreshold = playerForMax === PLAYERS.YELLOW ? 6 : 2;

                    if (isWolfOrCat) {
                        score += rowsAdvanced * AI_WOLF_CAT_ADVANCE_PENALTY_MULT;
                        if ((isEarlyGame || isMidGame) && ((playerForMax === PLAYERS.YELLOW && rc.row >= defensiveRowThreshold) || (playerForMax === PLAYERS.ORANGE && rc.row <= defensiveRowThreshold))) {
                             score += AI_WOLF_CAT_DEFENSE_BONUS;
                        }
                        const isBlockingRow = (playerForMax === PLAYERS.YELLOW && (rc.row === riverRowEnd + 1 || rc.row === riverRowEnd + 2)) ||
                                              (playerForMax === PLAYERS.ORANGE && (rc.row === riverRowStart - 1 || rc.row === riverRowStart - 2));
                        const isBlockingCol = jumpLandingCols.includes(rc.col);
                        if (backRowJumpersExist && isBlockingRow && isBlockingCol) {
                            score += AI_BLOCKING_JUMPER_PENALTY;
                        }
                    } else {
                        score += rowsAdvanced * AI_ADVANCE_BONUS_MULT;
                        if (piece.rank === 7 || piece.rank === 6) score += rowsAdvanced * AI_JUMPER_OFFENSE_BONUS;
                        if (piece.rank === 5) score += rowsAdvanced * AI_LEOPARD_OFFENSE_BONUS;
                        if (piece.rank === 3) score += rowsAdvanced * AI_DOG_OFFENSE_BONUS;
                        if (piece.rank === 1) score += rowsAdvanced * AI_RAT_OFFENSE_BONUS;
                        if (isEarlyGame && piece.rank !== 8 && ((playerForMax === PLAYERS.YELLOW && rc.row >= defensiveRowThreshold) || (playerForMax === PLAYERS.ORANGE && rc.row <= defensiveRowThreshold))) {
                             score += AI_PIECE_TOO_DEFENSIVE_PENALTY;
                        }
                    }

                    // C) Past River & Center Control Bonus
                    if (isPastRiver) {
                        score += AI_PAST_RIVER_BONUS;
                        if (centerCols.includes(rc.col)) score += AI_CENTER_CONTROL_BONUS;
                    }

                    // D) Water Control Bonus
                    if ((piece.rank === 1 || piece.rank === 3) && WATER_SQUARES.has(coords)) {
                        score += AI_WATER_CONTROL_BONUS;
                    }

                    // E) Near Opponent Den General Bonus
                    const nearThreshold = playerForMax === PLAYERS.YELLOW ? 2 : 6;
                     if ((playerForMax === PLAYERS.YELLOW && rc.row <= nearThreshold) || (playerForMax === PLAYERS.ORANGE && rc.row >= nearThreshold)) {
                        maxPiecesNearOppDen++;
                        score += AI_NEAR_OPP_DEN_BONUS;
                    }

                    // F) Trap Safety/Danger
                    if (isOnTrapSquare(coords)) {
                         const adjacent = getAdjacentCoords(coords);
                         for(const adjCoord of adjacent) {
                            const adjPiece = boardState[adjCoord];
                            if(adjPiece?.player === opponent && isValidMove(adjCoord, coords, adjPiece, boardState, true).valid) { score += AI_TRAP_DANGER_PENALTY; break; }
                         }
                    } else {
                         const adjacent = getAdjacentCoords(coords);
                         for(const adjCoord of adjacent) {
                            const adjPiece = boardState[adjCoord];
                            if(adjPiece?.player === opponent) {
                                const trapsNearOpponent = getAdjacentCoords(adjCoord).filter(c => isOnTrapSquare(c));
                                for (const trapCoord of trapsNearOpponent) {
                                    if (trapCoord !== coords && isValidMove(adjCoord, trapCoord, adjPiece, boardState, true).valid) {
                                        const canCaptureFromTrap = adjPiece.rank >= piece.rank || (adjPiece.rank === 1 && piece.rank === 8 && !WATER_SQUARES.has(trapCoord));
                                        if(canCaptureFromTrap) { score += AI_TRAP_ATTACK_VULNERABILITY; break; }
                                    }
                                }
                            }
                             if(score < 0 && score <= AI_TRAP_ATTACK_VULNERABILITY) break;
                         }
                    }

                    // G) Bonus for being near opponent's traps
                    if (adjacentToMinTraps.has(coords)) score += AI_NEAR_OPP_TRAP_BONUS;

                    // H) Bonus/Penalty based on Threats
                     let isThreateningOpponent = false;
                     for(const move of pieceMoves){ if(boardState[move.to]?.player === opponent) { isThreateningOpponent = true; break; } }
                     if(isThreateningOpponent) score += AI_THREATENS_OPPONENT_BONUS;
                    if (threatsTo[coords]) score += AI_IS_THREATENED_PENALTY;

                }
                // --- Evaluate OPPONENT PIECES ---
                else {
                    minPieceCount++;
                    score -= pieceScore;
                    score -= offensiveMobilityBonus; // Subtract opponent's offensive potential

                    // Subtract opponent threat bonus
                     let opponentIsThreatening = false;
                     const oppPieceMoves = allOpponentMoves.filter(m => m.from === coords);
                     for(const oppMove of oppPieceMoves){ if(boardState[oppMove.to]?.player === playerForMax){ opponentIsThreatening = true; break; } }
                     if(opponentIsThreatening) score -= AI_THREATENS_OPPONENT_BONUS;

                    // 1. Immediate Threat Penalty
                    const isOnMaxTrap = maxTraps.has(coords);
                    const isAdjacentToMaxDen = adjacentToMaxDen.includes(coords);
                    if (isAdjacentToMaxDen || isOnMaxTrap) {
                        score += AI_NEAR_OWN_DEN_PENALTY;
                         if (isValidMove(coords, maxDen, piece, boardState, true).valid && !piece.isHungry) {
                             score += AI_IMMEDIATE_WIN_THREAT_PENALTY;
                         }
                    }
                     // Reward AI if opponent piece IS threatened by AI
                     if (threatenedBy[coords]) {
                         score -= AI_IS_THREATENED_PENALTY;
                     }
                }
            }

            // --- Post-Iteration Checks ---
            if (minPieceCount === 0) return AI_WIN_SCORE;
            if (maxPieceCount === 0) return AI_LOSE_SCORE;

             if (maxPiecesNearOppDen >= 2) {
                 score += AI_MULTI_ATTACKER_BONUS * maxPiecesNearOppDen;
             }

            // Add a small random factor
            score += (Math.random() - 0.5) * 0.1;

            return score;
        }


        // --- UI Update & Logging ---

        /**
         * Updates the main UI elements (turn indicator, button states) based on the current game state.
         */
        function updateUI() {
            if (gameState.gameOver) {
                // Display Game Over message and winner
                turnIndicator.textContent = `Game Over - ${gameState.winner ? gameState.winner.toUpperCase() : 'DRAW'} Wins!`;
                turnIndicator.className = 'game-over'; // Apply game over style
            } else {
                // Display current player's turn
                turnIndicator.textContent = gameState.currentPlayer.toUpperCase();
                turnIndicator.className = gameState.currentPlayer; // Apply player color style
            }
            updateUndoButtonState(); // Enable/disable undo button
            updateAllPieceAccessibility(); // Update piece interactivity based on current player/game state
        }

        /**
         * Updates the status message display area and logs the message to the console.
         * @param {string} message - The message to display.
         */
        function updateStatus(message) {
            statusMessage.textContent = message; // Update the DOM element
            console.log("Status:", message); // Also log to console (and potentially debug panel)
        }

        /**
         * Creates and appends a log entry element to the visual move log panel.
         * Adds data-tooltip attribute for hover/focus interaction handled by global listeners.
         * @param {number} turn - The turn number.
         * @param {string|null} orangeMove - The notation for Orange's move this turn, or null.
         * @param {string|null} yellowMove - The notation for Yellow's move this turn, or null.
         */
        function addLogEntryToDOM(turn, orangeMove, yellowMove) { // Task 25 Change (JS Tooltip)
            const logEntryDiv = document.createElement('div');
            logEntryDiv.classList.add('log-entry');
            logEntryDiv.dataset.turn = turn;

            // Turn Number Span
            const turnSpan = document.createElement('span');
            turnSpan.classList.add('turn-number');
            turnSpan.textContent = `${turn}.`;
            logEntryDiv.appendChild(turnSpan);

            // Helper function to create and configure the move span
            const createMoveSpan = (moveNotation, playerClass) => {
                const span = document.createElement('span');
                span.classList.add(playerClass); // Add class regardless

                if (moveNotation && moveNotation !== '...') { // Check for actual notation
                    const description = generateMoveDescription(moveNotation);
                    span.textContent = moveNotation;
                    if (description) { // Only add tooltip attributes if description exists
                        span.setAttribute('data-tooltip', description);
                        span.setAttribute('tabindex', '0'); // Make focusable
                        // Set aria attributes for accessibility
                        span.setAttribute('role', 'button'); // Treat as interactive element
                        span.setAttribute('aria-describedby', 'move-log-tooltip'); // Point to the shared tooltip ID
                        span.setAttribute('aria-label', `Move: ${description}`); // Provide context
                    } else {
                         span.style.cursor = 'default';
                    }
                } else {
                    // Display placeholder if no move yet
                    span.textContent = '...';
                    span.classList.add('placeholder'); // Add placeholder class
                    span.style.cursor = 'default';
                }
                return span;
            };

            // Create and append Orange Move Span (always needed)
            const orangeSpan = createMoveSpan(orangeMove, 'log-orange');
            logEntryDiv.appendChild(orangeSpan);

            // Create and append Yellow Move Span ONLY if yellowMove has a value
            if (yellowMove) {
                 const yellowSpan = createMoveSpan(yellowMove, 'log-yellow');
                 logEntryDiv.appendChild(yellowSpan);
            }
            // If yellowMove is null, no yellow span is added yet. Orange move + padding handles the space.

            moveLogElement.appendChild(logEntryDiv);

            // Scroll only if the log isn't actively being hovered
            if (!moveLogElement.matches(':hover')) {
                moveLogElement.scrollTop = moveLogElement.scrollHeight;
            }
        }

        /**
         * Logs a move to the `gameState.moveHistory` array and updates the visual move log panel.
         * Handles creating new turn entries or updating existing ones.
         * @param {string} notation - The algebraic notation of the move (e.g., "8xg7++s").
         * @param {string} playerWhoMoved - The player who made the move ('orange' or 'yellow').
         */
        function logMove(notation, playerWhoMoved) {
            const turnNum = gameState.turnNumber; // Get the current turn number

            // Find if an entry for this turn already exists in the history
            let currentTurnEntry = gameState.moveHistory.find(entry => entry.turn === turnNum);
            // Find if a DOM element for this turn already exists
            let existingLogDiv = moveLogElement.querySelector(`div.log-entry[data-turn="${turnNum}"]`);

            if (playerWhoMoved === PLAYERS.ORANGE) {
                // If Orange moves, it's always the start of a new turn entry (or overwriting if undo occurred)
                if (!currentTurnEntry) {
                    // Create new entry in history
                    currentTurnEntry = { turn: turnNum, orange: notation, yellow: null };
                    gameState.moveHistory.push(currentTurnEntry);
                    // Remove existing DOM element if any (e.g., after undo) and add the new one
                    if (existingLogDiv) existingLogDiv.remove();
                    addLogEntryToDOM(turnNum, notation, null);
                } else {
                    // This case might occur after an undo/redo sequence. Update the existing entry.
                    console.warn("Updating Orange's move in existing turn entry:", turnNum);
                    currentTurnEntry.orange = notation;
                    // Update the DOM if it exists
                    if (existingLogDiv) {
                        let orangeSpan = existingLogDiv.querySelector('.log-orange'); // Find specifically orange span
                        if (orangeSpan) { // Update existing orange span
                             orangeSpan.textContent = notation;
                             const description = generateMoveDescription(notation);
                             if (description) {
                                 orangeSpan.setAttribute('data-tooltip', description);
                                 orangeSpan.setAttribute('aria-label', `Move: ${description}`);
                                 orangeSpan.setAttribute('tabindex', '0');
                                 orangeSpan.style.cursor = 'help';
                                 orangeSpan.classList.remove('placeholder');
                             } else {
                                orangeSpan.removeAttribute('data-tooltip');
                                orangeSpan.removeAttribute('aria-label');
                                orangeSpan.setAttribute('tabindex', '-1');
                                orangeSpan.style.cursor = 'default';
                             }
                        } else { // If only placeholder existed, need to replace
                             let placeholderSpan = existingLogDiv.querySelector('.placeholder');
                             if(placeholderSpan) placeholderSpan.remove(); // Remove placeholder if found
                             addLogEntryToDOM(turnNum, notation, currentTurnEntry.yellow); // Re-add might be simpler
                        }
                    } else {
                         // If DOM element missing unexpectedly, recreate it
                        addLogEntryToDOM(turnNum, notation, currentTurnEntry.yellow);
                    }
                }
            } else { // Yellow moved
                // Yellow always completes a turn entry initiated by Orange
                if (currentTurnEntry) {
                    // Update the history entry
                    currentTurnEntry.yellow = notation;
                    // Update the DOM element
                    if (existingLogDiv) {
                        let yellowSpan = existingLogDiv.querySelector('.log-yellow');
                        // If yellow span doesn't exist yet, create it (shouldn't happen with new addLogEntryDOM logic)
                        if (!yellowSpan) {
                            console.warn("Yellow span missing in existing log div for turn", turnNum, "Recreating span.");
                            // Remove potential placeholder before adding
                            let placeholderSpan = existingLogDiv.querySelector('.placeholder:not(.log-orange)');
                            if (placeholderSpan) placeholderSpan.remove();
                            // Create and append the actual yellow span
                            yellowSpan = document.createElement('span');
                            yellowSpan.classList.add('log-yellow');
                            existingLogDiv.appendChild(yellowSpan);
                        }
                        // Update the yellow span content and attributes
                        yellowSpan.textContent = notation;
                         const description = generateMoveDescription(notation);
                         if (description) {
                             yellowSpan.setAttribute('data-tooltip', description);
                             yellowSpan.setAttribute('aria-label', `Move: ${description}`);
                             yellowSpan.setAttribute('tabindex', '0');
                             yellowSpan.style.cursor = 'help';
                             yellowSpan.classList.remove('placeholder'); // Ensure placeholder class removed
                         } else {
                             yellowSpan.removeAttribute('data-tooltip');
                             yellowSpan.removeAttribute('aria-label');
                             yellowSpan.setAttribute('tabindex', '-1');
                             yellowSpan.style.cursor = 'default';
                         }
                    } else {
                        // Log error if DOM element is missing when it shouldn't be
                        console.error("Log div missing for Yellow's move in turn", turnNum);
                        // Attempt to recreate the full log entry
                        addLogEntryToDOM(turnNum, currentTurnEntry.orange || '...', notation);
                    }
                } else {
                    // Log error if Yellow moves but no history entry exists (shouldn't happen)
                    console.error("Yellow moved but no history entry found for turn", turnNum);
                    // Create a new history entry anyway
                    currentTurnEntry = { turn: turnNum, orange: null, yellow: notation };
                    gameState.moveHistory.push(currentTurnEntry);
                    if (existingLogDiv) existingLogDiv.remove(); // Remove potentially incomplete DOM entry
                    addLogEntryToDOM(turnNum, null, notation); // Add correct entry
                }
            }
            // Ensure log scrolls to bottom (with hover check)
            if (!moveLogElement.matches(':hover')) {
                 moveLogElement.scrollTop = moveLogElement.scrollHeight;
            }
        }


        /**
         * Generates a unique string representation of the current board state.
         * Used for detecting repetitions. Format: "RankCoordsUpper/Lower,RankCoordsUpper/Lower,..." sorted alphabetically.
         * Example: "1a7,1g3,2b2,..." (Upper = Orange, Lower = Yellow)
         * @param {object} [board=gameState.board] - The board state to stringify. Defaults to current game state.
         * @returns {string} The sorted comma-separated string representation.
         */
        function getBoardStateString(board = gameState.board) {
            const pieces = [];
            // Get coordinates and sort them alphabetically/numerically for consistency
            const coordsList = Object.keys(board).sort((a, b) => {
                // Sort primarily by column, then by row number descending
                const colA = a.charCodeAt(0);
                const colB = b.charCodeAt(0);
                if (colA !== colB) return colA - colB;
                const rowA = parseInt(a.substring(1));
                const rowB = parseInt(b.substring(1));
                return rowB - rowA; // Higher row number (e.g., 9) comes first
            });

            for (const coords of coordsList) {
                const piece = board[coords];
                if (piece) {
                    // Format: Rank followed by Coords. Uppercase coords for Orange, lowercase for Yellow.
                    const stateOutput = piece.player === PLAYERS.ORANGE ?
                        `${piece.rank}${coords.toUpperCase()}` : // e.g., 8A3
                        `${piece.rank}${coords.toLowerCase()}`; // e.g., 7a9
                    pieces.push(stateOutput);
                }
            }
            // Final sort of the generated piece strings ensures the overall string is unique per state
            // pieces.sort(); // This secondary sort might be redundant if coordsList is sorted robustly
            return pieces.join(','); // Join with commas
        }

        /**
         * Parses a board state string into a board object suitable for gameState.board.
         * String format: "RankCoordsUpper/Lower,RankCoordsUpper/Lower,..." (e.g., "8A3,7G1,1a7")
         * Uppercase coords = Orange, Lowercase = Yellow.
         * @param {string} stateString - The board state string to parse.
         * @returns {object|null} A board object { coords: pieceData } or null if parsing fails.
         */
        function parseBoardStateString(stateString) {
            if (!stateString || typeof stateString !== 'string') {
                console.error("Parse Error: Invalid input string.");
                return null;
            }

            const parsedBoard = {};
            const pieceStrings = stateString.trim().split(',');
            const pieceRegex = /^([1-8])([a-gA-G][1-9])$/; // Matches Rank (1-8) and Coords (e.g., a1, G9)

            for (const pieceStr of pieceStrings) {
                if (!pieceStr) continue; // Skip empty parts if trailing comma etc.
                const match = pieceStr.match(pieceRegex);

                if (!match) {
                    console.error(`Parse Error: Invalid piece format "${pieceStr}" in state string.`);
                    return null; // Invalid format for a piece
                }

                const rank = parseInt(match[1], 10);
                const coordsRaw = match[2];
                const coordsLower = coordsRaw.toLowerCase(); // Key for the board object is always lowercase

                // Validate coordinates range after converting to lowercase
                const rc = getRowCol(coordsLower);
                if (!rc) {
                    console.error(`Parse Error: Invalid coordinates "${coordsRaw}" in state string.`);
                    return null;
                }

                // Determine player based on original case
                const player = (coordsRaw === coordsRaw.toUpperCase()) ? PLAYERS.ORANGE : PLAYERS.YELLOW;

                // Create piece data object
                const pieceData = {
                    player: player,
                    rank: rank,
                    isHungry: false // Pieces always start not hungry when loading state
                };

                // Add special abilities based on rank
                const abilities = SPECIAL_ABILITIES[rank];
                if (abilities) {
                    pieceData.swims = abilities.swims || false;
                    pieceData.attacksElephant = abilities.attacksElephant || false;
                    pieceData.jumpH = abilities.jumpH || false;
                    pieceData.jumpV = abilities.jumpV || false;
                } else {
                    pieceData.swims = false; pieceData.attacksElephant = false;
                    pieceData.jumpH = false; pieceData.jumpV = false;
                }

                // Check for duplicate piece placement
                if (parsedBoard[coordsLower]) {
                     console.error(`Parse Error: Duplicate piece placement at "${coordsLower}" in state string.`);
                     return null;
                }

                parsedBoard[coordsLower] = pieceData;
            }

            // Basic sanity check: ensure at least one piece exists? (Optional)
            if (Object.keys(parsedBoard).length === 0 && stateString.length > 0) {
                 console.error("Parse Error: String provided but no valid pieces parsed.");
                 return null;
            }


            console.log("Successfully parsed board state:", parsedBoard);
            return parsedBoard;
        }

        /**
         * Logs the current board state string to the console and the board state log element.
         * Increments the count for this state in `gameState.boardStateHistory` unless restoring.
         * @param {boolean} [isRestoring=false] - If true, logs the state but doesn't increment the history count (used during undo).
         * @returns {string} The generated board state string.
         */
        function logBoardState(isRestoring = false) {
            const stateString = getBoardStateString();
            boardStateLogElement.textContent = stateString; // Display in UI

            if (!isRestoring) {
                // Increment the count for this state in the history object
                gameState.boardStateHistory[stateString] = (gameState.boardStateHistory[stateString] || 0) + 1;
                console.log(`Board State (${gameState.boardStateHistory[stateString]}x):`, stateString);
            } else {
                // Just log that the state was restored
                console.log(`Restored Board State:`, stateString);
            }
            return stateString; // Return the generated string
        }

        /**
         * Shows or hides the "(0)" trap rank indicator on a piece's DOM element.
         * Can accept coordinates OR a direct element reference for robustness.
         * @param {string} coords - The coordinates of the piece.
         * @param {boolean} isTrapped - Whether the piece should show the trapped indicator.
         * @param {HTMLElement|null} [element=null] - Optional: Direct reference to the piece element.
         */
        function updateTrapIndicatorVisual(coords, isTrapped, element = null) {
            // Prioritize the passed element reference if available
            const pieceElement = element || document.getElementById(getPieceElementId(coords));
            if (!pieceElement) {
                 // Element might legitimately not exist if piece was captured/starved before update could happen.
                return;
            }

            // Find the indicator span within the piece element
            const indicatorSpan = pieceElement.querySelector('.trap-rank-indicator');
            if (!indicatorSpan) {
                console.warn("Trap indicator span not found for piece at", coords);
                return;
            }

            // Add or remove the 'visible' class based on the isTrapped flag
            if (isTrapped) {
                if (!indicatorSpan.classList.contains('visible')) { // Check before adding
                    indicatorSpan.classList.add('visible');
                }
            } else {
                if (indicatorSpan.classList.contains('visible')) { // Check before removing
                    indicatorSpan.classList.remove('visible');
                }
            }
        }

        /**
         * Adds or removes the 'hungry' class from a piece's DOM element.
         * Can accept coordinates OR a direct element reference.
         * @param {string} coords - The coordinates of the piece (used if element is not provided).
         * @param {boolean} isHungry - Whether the piece should be marked as hungry.
         * @param {HTMLElement|null} [element=null] - Optional: Direct reference to the piece element.
         */
        function updateHungryVisual(coords, isHungry, element = null) { // Added element parameter
            // Prioritize the passed element reference if available
            const pieceElement = element || document.getElementById(getPieceElementId(coords));

            if (pieceElement) {
                if (isHungry) {
                    pieceElement.classList.add('hungry'); // Add red glow
                } else {
                    try {
                         pieceElement.classList.remove('hungry'); // Remove red glow
                    } catch (e) {
                        console.error(`Error removing hungry class from element for ${coords}:`, e, pieceElement);
                    }
                }
            } else {
                 console.warn(`updateHungryVisual: Element not found for ${coords} (even with potential direct reference).`);
            }
        }


        // --- Highlighting & Visual Feedback ---

        /**
         * Highlights valid move and attack squares for a given piece.
         * Adds temporary highlight classes ('valid-move-highlight', 'valid-attack-highlight')
         * and, if `isSelection` is true, applies persistent visual styles ('valid-move', 'valid-attack').
         * Moves blocked by the repetition rule are styled red.
         * @param {string} fromCoords - The coordinates of the piece whose moves to highlight.
         * @param {boolean} [isSelection=true] - If true, apply persistent styles (for click/drag selection).
         *                                      If false, only add highlight classes (for hover).
         */
        function highlightValidMoves(fromCoords, isSelection = true) {
            clearHighlights(); // Clear previous highlights first
            const piece = gameState.board[fromCoords];

             // Don't highlight if no piece or (if selecting) it's not current player's piece
            if (!piece || (isSelection && piece.player !== gameState.currentPlayer)) return;

            // Get all potential destinations (geometrically possible)
            const destinations = getPotentialMoveDestinations(fromCoords, piece);

            destinations.forEach(toCoords => {
                const cell = document.getElementById(getCellElementId(toCoords));
                if (!cell) return; // Skip if cell not found

                // Validate the move legally, including the NEW repetition check
                // Pass a copy of piece data to avoid potential side effects during validation
                const validation = isValidMove(fromCoords, toCoords, { ...piece });

                // --- START: Updated Highlighting Logic ---
                if (validation.valid) {
                    // Standard valid move highlighting (Green)
                    cell.classList.add('valid-move-highlight');
                    if (gameState.board[toCoords]) { // Attack move
                        cell.classList.add('valid-attack-highlight');
                        if (isSelection) cell.classList.add('valid-attack'); // Red for attack target
                    } else { // Non-attack move
                        if (isSelection) cell.classList.add('valid-move'); // Green for empty square
                    }
                     // Make valid destination cells focusable via keyboard nav
                     cell.setAttribute('tabindex', '0');
                } else if (validation.reasonCode === 'REPETITION_RULE') {
                    // Highlight as blocked by repetition (Red)
                     console.log(`Highlighting: ${toCoords} blocked by repetition rule for ${piece.player}.`);
                    cell.classList.add('valid-attack-highlight'); // Use attack class for red border effect
                    if (isSelection) {
                        cell.classList.add('valid-attack'); // Use attack class for red background fill
                    }
                     // Keep blocked cells non-focusable via keyboard
                     cell.setAttribute('tabindex', '-1');
                }
                // --- END: Updated Highlighting Logic ---
            });

            // If this is a selection (not just hover), mark the source piece as selected
            if (isSelection) {
                const pieceEl = document.getElementById(getPieceElementId(fromCoords));
                if (pieceEl) pieceEl.classList.add('selected');
            }
        }

        /**
         * Removes all move/attack highlights and selection styles from cells and pieces.
         * Resets cell tabindex attributes.
         */
        function clearHighlights() {
            // Remove highlight classes from all cells
            boardGridWrapper.querySelectorAll('.cell').forEach(cell => {
                cell.classList.remove('valid-move', 'valid-attack', 'valid-move-highlight', 'valid-attack-highlight');
                 // Reset tabindex for cells (only valid moves should be tabbable temporarily)
                cell.setAttribute('tabindex', '-1');
            });

            // If no piece is currently selected, remove selection style from any piece that might have it
            if (!selectedPieceCoords) {
                boardGridWrapper.querySelectorAll('.piece.selected').forEach(p => p.classList.remove('selected'));
            }
            // Ensure pieces' tabindex is correctly set (only current player's pieces should be 0)
             updateAllPieceAccessibility();

             // Restore tabindex=0 for the currently focused element if focus wasn't lost
            if (focusedCoords) {
                let focusedEl = document.getElementById(getCellElementId(focusedCoords)) || document.getElementById(getPieceElementId(focusedCoords));
                 // Check if the focused element should indeed be focusable
                 const shouldBeFocusable = focusedEl?.classList.contains('piece') && focusedEl?.dataset.player === gameState.currentPlayer && !gameState.gameOver;
                if (focusedEl && shouldBeFocusable) {
                    focusedEl.setAttribute('tabindex', '0');
                } else if (focusedEl && !focusedEl.classList.contains('piece')) {
                     // Cells generally aren't focusable unless a valid move target
                     focusedEl.setAttribute('tabindex', '-1');
                }
            }
        }


        /**
         * Briefly flashes the background color of a cell for visual feedback.
         * @param {string} coords - The coordinates of the cell to flash.
         * @param {string} [color='red'] - The color to flash ('red' or 'green').
         * @param {number} [duration=300] - The total duration of the flash in milliseconds.
         */
        function flashCell(coords, color = 'red', duration = 300) {
            const cell = document.getElementById(getCellElementId(coords));
            if (cell) {
                const originalTransition = cell.style.transition; // Store original transition
                // Apply flash color quickly
                cell.style.transition = `background-color ${duration / 2}ms ease-out`;
                cell.style.backgroundColor = color === 'red' ? 'rgba(255,0,0,0.5)' : 'rgba(0,255,0,0.5)';
                // After half the duration, start fading back to original
                setTimeout(() => {
                    cell.style.backgroundColor = ''; // Remove inline style, revert to CSS background
                    // After fade out, restore original transition property
                    setTimeout(() => {
                        cell.style.transition = originalTransition;
                     }, 50); // Small delay to ensure background removal registers before transition change
                }, duration / 2);
            }
        }

        /**
         * Removes the visual highlighting from the last move squares for a specific player.
         * @param {string} player - The player ('orange' or 'yellow') whose highlights to clear.
         */
        function clearPlayerLastMoveHighlight(player) {
            if (!player || !playerLastMoves[player]) return; // Ensure valid player

            const lastMove = playerLastMoves[player];
            // console.log(`Clearing highlights for ${player}:`, lastMove); // Debug log

            // Function to remove classes from a cell if it exists
            const removeClasses = (coords) => {
                if (!coords) return;
                const cell = document.getElementById(getCellElementId(coords));
                if (cell) {
                    cell.classList.remove('last-move-from', 'last-move-to', `${player}-last-move`);
                }
            };

            removeClasses(lastMove.from);
            removeClasses(lastMove.to);
        }

        /**
         * Highlights the starting and ending squares of the last known moves for both players.
         */
        function highlightLastMoves() {
            // console.log("Highlighting last moves:", playerLastMoves); // Debug log

            // Clear ALL existing highlights first to prevent conflicts
             boardGridWrapper.querySelectorAll('.cell.last-move-from, .cell.last-move-to, .cell.orange-last-move, .cell.yellow-last-move').forEach(cell => {
                 cell.classList.remove('last-move-from', 'last-move-to', 'orange-last-move', 'yellow-last-move');
             });


            // Apply highlights for each player
            for (const player in playerLastMoves) {
                const move = playerLastMoves[player];
                if (move.from && move.to) {
                    const fromCell = document.getElementById(getCellElementId(move.from));
                    const toCell = document.getElementById(getCellElementId(move.to));

                    if (fromCell) {
                        fromCell.classList.add('last-move-from');
                        fromCell.classList.add(`${player}-last-move`); // Add player class
                    }
                    if (toCell) {
                        toCell.classList.add('last-move-to');
                        toCell.classList.add(`${player}-last-move`); // Add player class
                    }
                }
            }
        }


        // --- Shared Tooltip Logic (Task 25) ---
        let tooltipHideTimeout = null; // Timeout to delay hiding

        /**
         * Shows the shared tooltip positioned near the target element.
         * @param {HTMLElement} targetElement - The element triggering the tooltip (e.g., the move span).
         */
        function showSharedTooltip(targetElement) {
            if (!targetElement || !sharedMoveTooltip) return;
            const tooltipText = targetElement.dataset.tooltip;

            if (!tooltipText) {
                hideSharedTooltip(); // Hide if target has no tooltip data
                return;
            }

            // Clear any pending hide timeout
            if (tooltipHideTimeout) {
                clearTimeout(tooltipHideTimeout);
                tooltipHideTimeout = null;
            }

            // Set text and calculate position
            sharedMoveTooltip.textContent = tooltipText;
            sharedMoveTooltip.style.visibility = 'hidden'; // Keep hidden while calculating size
            sharedMoveTooltip.style.opacity = '0';
            // We need to temporarily make it visible (but off-screen) to measure it accurately
            sharedMoveTooltip.style.top = '-9999px';
            sharedMoveTooltip.style.left = '-9999px';
            sharedMoveTooltip.style.visibility = 'visible'; // Briefly visible for measurement

            const targetRect = targetElement.getBoundingClientRect();
            const tooltipRect = sharedMoveTooltip.getBoundingClientRect(); // Get size *after* setting text

            // Calculate position (prefer above, centered)
            let top = targetRect.top - tooltipRect.height - 8; // Position above target + margin
            let left = targetRect.left + (targetRect.width / 2) - (tooltipRect.width / 2); // Center horizontally

            // Adjust if tooltip goes off-screen top
            if (top < 5) { // Use a small buffer (5px) from the top edge
                top = targetRect.bottom + 8; // Position below instead
            }

            // Adjust if tooltip goes off-screen left/right
            if (left < 5) { // Small buffer from left edge
                left = 5;
            } else if (left + tooltipRect.width > window.innerWidth - 5) { // Small buffer from right edge
                left = window.innerWidth - tooltipRect.width - 5;
            }

            // Apply position and make visible with transition
            sharedMoveTooltip.style.top = `${top}px`;
            sharedMoveTooltip.style.left = `${left}px`;
            // sharedMoveTooltip.style.visibility = 'visible'; // Already set for measurement
            sharedMoveTooltip.style.opacity = '1';
            sharedMoveTooltip.setAttribute('aria-hidden', 'false');
        }

        /**
         * Hides the shared tooltip, potentially with a delay.
         */
        function hideSharedTooltip() {
            // Use a small timeout to prevent flickering when moving mouse
             if (tooltipHideTimeout) clearTimeout(tooltipHideTimeout); // Clear existing timeout

             tooltipHideTimeout = setTimeout(() => {
                 if (sharedMoveTooltip) {
                    sharedMoveTooltip.style.visibility = 'hidden';
                    sharedMoveTooltip.style.opacity = '0';
                    sharedMoveTooltip.setAttribute('aria-hidden', 'true');
                    // Reset position off-screen to prevent interfering with other elements
                    sharedMoveTooltip.style.top = '-9999px';
                    sharedMoveTooltip.style.left = '-9999px';
                 }
                  tooltipHideTimeout = null;
             }, 100); // 100ms delay
        }

        // Add delegated event listeners to the move log container
        if (moveLogElement) {
            // Show on mouseover or focusin
            moveLogElement.addEventListener('mouseover', (event) => {
                const target = event.target.closest('.log-orange[data-tooltip], .log-yellow[data-tooltip]');
                if (target) {
                    showSharedTooltip(target);
                }
            });
            moveLogElement.addEventListener('focusin', (event) => {
                 const target = event.target.closest('.log-orange[data-tooltip], .log-yellow[data-tooltip]');
                if (target) {
                    showSharedTooltip(target);
                }
            });

            // Hide on mouseout or focusout
            moveLogElement.addEventListener('mouseout', (event) => {
                 const target = event.target.closest('.log-orange[data-tooltip], .log-yellow[data-tooltip]');
                 // Hide if mouse moves off the target element, let the delay handle flicker
                 if (target) {
                     hideSharedTooltip();
                 }
            });
            moveLogElement.addEventListener('focusout', (event) => {
                 const target = event.target.closest('.log-orange[data-tooltip], .log-yellow[data-tooltip]');
                 // Hide if focus moves away from a tooltip trigger element
                 if (target) {
                      hideSharedTooltip();
                 }
            });
        }
        // --- End Shared Tooltip Logic ---


        // --- Event Listeners Setup ---
        resetButton.addEventListener('click', () => initializeGame()); // Reset with default setup
        undoButton.addEventListener('click', undoMove); // Undo move on button click

        // --- Load State Button Listener ---
        const loadStateButton = document.getElementById('load-state-button');
        const boardStateInput = document.getElementById('board-state-input');
        const loadStatusMessage = document.getElementById('load-status-message');

        if (loadStateButton && boardStateInput && loadStatusMessage) {
            loadStateButton.addEventListener('click', () => {
                // Get the raw value from the input field
                const rawStateString = boardStateInput.value;

                if (!rawStateString || rawStateString.trim() === '') {
                    loadStatusMessage.textContent = "Please paste a state string first.";
                    loadStatusMessage.style.color = 'red';
                    return;
                }

                // --- Clean the input string ---
                const cleanedStateString = rawStateString
                    .split(',')
                    .map(piece => piece.trim()) // Remove leading/trailing spaces from each part
                    .filter(piece => piece !== '') // Remove empty strings
                    .join(','); // Reconstruct the string

                console.log("Raw input:", rawStateString);
                console.log("Cleaned input for parsing:", cleanedStateString);

                // Attempt to parse the *cleaned* string
                const parsedBoard = parseBoardStateString(cleanedStateString);

                if (parsedBoard) {
                    // --- Pass flag to initializeGame --- (Task 17)
                    initializeGame(parsedBoard, true); // Pass true for isLoadingFromFile
                    loadStatusMessage.textContent = "Board state loaded successfully!";
                    loadStatusMessage.style.color = '#28a745'; // Green color for success
                    boardStateInput.value = ''; // Clear the input field on success
                    // Initial status and clocks are handled by initializeGame now
                } else {
                    // If parsing failed, show an error message
                    loadStatusMessage.textContent = "Invalid state string format. Please check console for details.";
                    loadStatusMessage.style.color = 'red'; // Red color for error
                    boardStateInput.style.borderColor = 'red';
                    setTimeout(() => { boardStateInput.style.borderColor = 'var(--medium-gray)'; }, 2000);
                }
            });

            // Focus/Blur Listeners
            boardStateInput.addEventListener('focus', () => {
                isLoadStateInputFocused = true;
                console.log("Load state input focused, game keyboard shortcuts disabled.");
            });
            boardStateInput.addEventListener('blur', () => {
                isLoadStateInputFocused = false;
                console.log("Load state input blurred, game keyboard shortcuts enabled.");
            });

        } else {
            console.error("Could not find Load State button, input field, or status message element.");
        }
        // --- End Load State Button Listener ---

        // --- Accordion Logic ---
        const rulesButton = document.getElementById('rules-toggle-button');
        const rulesContent = document.getElementById('rules-content');

        if (rulesButton && rulesContent) {
            rulesButton.addEventListener('click', () => {
                const isExpanded = rulesButton.getAttribute('aria-expanded') === 'true';

                rulesButton.setAttribute('aria-expanded', !isExpanded);
                rulesContent.setAttribute('aria-hidden', isExpanded);

                rulesButton.classList.toggle('active');
                rulesContent.classList.toggle('expanded');

                if (!isExpanded) {
                    rulesContent.style.maxHeight = rulesContent.scrollHeight + 'px';
                    rulesButton.querySelector('.rules-button-text').textContent = 'Hide Game Rules';
                } else {
                    rulesContent.style.maxHeight = null;
                    rulesButton.querySelector('.rules-button-text').textContent = 'Show Game Rules';
                }
            });
        } else {
            console.warn("Rules accordion button or content not found.");
        }
        // --- End Accordion Logic ---

        // --- PvP Toggle Listener ---
        const pvpToggleButton = document.getElementById('pvp-toggle');

        if (pvpToggleButton) {
            pvpToggleButton.addEventListener('change', (event) => { // Task 17 & 28 Change
                isPlayerVsPlayerMode = event.target.checked;
                console.log(`Player vs Player mode ${isPlayerVsPlayerMode ? 'ENABLED' : 'DISABLED'}`);
                if (aiMoveTimeoutId) { clearTimeout(aiMoveTimeoutId); aiMoveTimeoutId = null; }

                // --- Pause Clocks During Switch ---
                pauseAllClocks();

                // Determine required interaction state and resume clock
                if (isPlayerVsPlayerMode) {
                    // Switching TO PvP: Enable interaction, resume clock for current player
                    console.log("PvP Mode ACTIVE: Ensuring player interaction is enabled.");
                    enablePlayerInteraction();
                    updateStatus(`${gameState.currentPlayer.toUpperCase()}'s turn (PvP Mode)`);
                    resumeClockForCurrentPlayer(); // Start the appropriate clock
                    playTurnSound(); // Play sound for current player's turn (Task 28)
                } else {
                    // Switching TO PvE:
                    if (gameState.currentPlayer === PLAYERS.YELLOW && !gameState.gameOver) {
                        // AI's turn: Disable interaction, start AI clock, schedule AI move.
                        console.log("PvE Mode ACTIVE and Yellow's turn: Disabling interaction, scheduling AI move.");
                        disablePlayerInteraction();
                        undoButton.disabled = true; // Disable undo during AI thinking
                        startClock(PLAYERS.YELLOW); // Start AI clock *before* the delay
                        playTurnSound(); // Play sound for AI turn start (Task 28)
                        aiMoveTimeoutId = setTimeout(triggerAIMove, 1500);
                    } else {
                        // Human's turn (Orange): Enable interaction, start Orange clock.
                        console.log("PvE Mode ACTIVE and Orange's turn: Ensuring player interaction is enabled.");
                        enablePlayerInteraction();
                        resumeClockForCurrentPlayer(); // Start Orange's clock
                        playTurnSound(); // Play sound for Orange's turn (Task 28)
                    }
                }

                // Update accessibility and Undo button state
                updateAllPieceAccessibility();
                updateUndoButtonState();
            });
        } else {
            console.warn("PvP toggle button not found.");
        }
        // --- End PvP Toggle Listener ---

        // --- Initial Game Setup ---
        console.log("Initializing Clesto Game...");
        initializeGame(); // Start the game when the DOM is ready
        console.log("Game setup complete. Board and UI ready.");

    }); // End window.load event listener
    </script>

</body>

</html>